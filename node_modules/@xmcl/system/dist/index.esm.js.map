{"version":3,"file":"index.esm.js","sources":["../../system.ts","../../index.ts"],"sourcesContent":["export abstract class FileSystem {\n    abstract readonly root: string;\n    abstract readonly sep: string;\n    abstract readonly type: \"zip\" | \"path\";\n    abstract readonly writeable: boolean;\n\n    // base methods\n\n    abstract join(...paths: string[]): string;\n\n    abstract isDirectory(name: string): Promise<boolean>;\n    abstract existsFile(name: string): Promise<boolean>;\n    abstract readFile(name: string, encoding: \"utf-8\" | \"base64\"): Promise<string>;\n    abstract readFile(name: string, encoding: undefined): Promise<Uint8Array>;\n    abstract readFile(name: string): Promise<Uint8Array>;\n    abstract readFile(name: string, encoding?: \"utf-8\" | \"base64\"): Promise<Uint8Array | string>;\n\n    /**\n     * Get the url for a file entry. If the system does not support get url. This should return an empty string.\n     */\n    getUrl(name: string): string { return \"\"; }\n\n    abstract listFiles(name: string): Promise<string[]>;\n\n    abstract cd(name: string): void;\n\n    close(): void { }\n\n    // extension methods\n\n    async missingFile(name: string) {\n        return this.existsFile(name).then((v) => !v);\n    }\n\n    async walkFiles(target: string, walker: (path: string) => void | Promise<void>) {\n        if (await this.isDirectory(target)) {\n            const childs = await this.listFiles(target);\n            for (const child of childs) {\n                await this.walkFiles(this.join(target, child), walker);\n            }\n        } else {\n            const result = walker(this.join(target));\n            if (result instanceof Promise) {\n                await result;\n            }\n        }\n    }\n}\n","import { open, readEntry, readAllEntries } from \"@xmcl/unzip\";\nimport { access, stat, writeFile, readFile, readdir } from \"fs\";\nimport { join, sep } from \"path\";\nimport { FileSystem } from \"./system\";\nimport { promisify } from \"util\";\nimport { ZipFile, Entry } from \"yauzl\";\n\nconst paccess = promisify(access);\nconst pstat = promisify(stat);\nconst pwriteFile = promisify(writeFile);\nconst preadFile = promisify(readFile);\nconst preaddir = promisify(readdir);\n\nexport async function openFileSystem(basePath: string | Uint8Array): Promise<FileSystem> {\n    if (typeof basePath === \"string\") {\n        const stat = await pstat(basePath);\n        if (stat.isDirectory()) {\n            return new NodeFileSystem(basePath);\n        } else {\n            const zip = await open(basePath);\n            const entries = await readAllEntries(zip);\n            const entriesRecord: Record<string, Entry> = {};\n            for (const entry of entries) {\n                entriesRecord[entry.fileName] = entry;\n            }\n            return new NodeZipFileSystem(basePath, zip, entriesRecord);\n        }\n    } else {\n        const zip = await open(basePath as Buffer);\n        const entries = await readAllEntries(zip);\n        const entriesRecord: Record<string, Entry> = {};\n        for (const entry of entries) {\n            entriesRecord[entry.fileName] = entry;\n        }\n        return new NodeZipFileSystem(\"\", zip, entriesRecord);\n    }\n}\nexport function resolveFileSystem(base: string | Uint8Array | FileSystem): Promise<FileSystem> {\n    if (typeof base === \"string\" || base instanceof Uint8Array) {\n        return openFileSystem(base);\n    } else {\n        return Promise.resolve(base);\n    }\n}\n\nclass NodeFileSystem extends FileSystem {\n    sep = sep;\n    type = \"path\" as const;\n    writeable = true;\n    join(...paths: string[]): string {\n        return join(...paths);\n    }\n    getUrl(name: string) {\n        return `file://${this.join(this.root, name)}`;\n    }\n    isDirectory(name: string): Promise<boolean> {\n        return pstat(join(this.root, name)).then((s) => s.isDirectory());\n    }\n    writeFile(name: string, data: Uint8Array): Promise<void> {\n        return pwriteFile(join(this.root, name), data);\n    }\n    existsFile(name: string): Promise<boolean> {\n        return paccess(join(this.root, name)).then(() => true, () => false);\n    }\n    readFile(name: any, encoding?: any) {\n        return preadFile(join(this.root, name), { encoding }) as any;\n    }\n    listFiles(name: string): Promise<string[]> {\n        return preaddir(join(this.root, name));\n    }\n    cd(name: string): void {\n        this.root = join(this.root, name);\n    }\n    constructor(public root: string) { super(); }\n}\nclass NodeZipFileSystem extends FileSystem {\n    sep = \"/\";\n    type = \"zip\" as const;\n    writeable = false;\n\n    private zipRoot: string = \"\";\n\n    private fileRoot: string;\n\n    constructor(root: string, private zip: ZipFile, private entries: Record<string, Entry>) {\n        super();\n        this.fileRoot = root;\n    }\n\n    close(): void {\n        this.zip.close();\n    }\n\n    get root() { return this.fileRoot + (this.zipRoot.length === 0 ? \"\" : `/${this.zipRoot}`); }\n\n    protected normalizePath(name: string): string {\n        if (name.startsWith(\"/\")) {\n            name = name.substring(1);\n        }\n        if (this.zipRoot !== \"\") {\n            name = [this.root, name].join(\"/\")\n        }\n        return name;\n    }\n\n    join(...paths: string[]): string {\n        return paths.join(\"/\");\n    }\n    isDirectory(name: string): Promise<boolean> {\n        name = this.normalizePath(name);\n        if (name === \"\") {\n            return Promise.resolve(true);\n        }\n        if (this.entries[name]) {\n            return Promise.resolve(name.endsWith(\"/\"));\n        }\n        if (this.entries[name + \"/\"]) {\n            return Promise.resolve(true);\n        }\n        // the root dir won't have entries\n        // therefore we need to do an extra track here\n        const entries = Object.keys(this.entries);\n        return Promise.resolve(entries.some((e) => e.startsWith(name + \"/\")));\n    }\n    existsFile(name: string): Promise<boolean> {\n        name = this.normalizePath(name);\n        if (this.entries[name]\n            || this.entries[name + \"/\"]) { return Promise.resolve(true); }\n        // the root dir won't have entries\n        // therefore we need to do an extra track here\n        const entries = Object.keys(this.entries);\n        return Promise.resolve(entries.some((e) => e.startsWith(name + \"/\")));\n    }\n    async readFile(name: string, encoding?: \"utf-8\" | \"base64\"): Promise<any> {\n        name = this.normalizePath(name);\n        const entry = this.entries[name];\n        if (!entry) { throw new Error(`Not found file named ${name}`); }\n        const buffer = await readEntry(this.zip, entry);\n        if (encoding === \"utf-8\") {\n            return buffer.toString(\"utf-8\");\n        }\n        if (encoding === \"base64\") {\n            return buffer.toString(\"base64\");\n        }\n        return buffer;\n    }\n    listFiles(name: string): Promise<string[]> {\n        name = this.normalizePath(name);\n        return Promise.resolve([\n            ...new Set(Object.keys(this.entries)\n                .filter((n) => n.startsWith(name))\n                .map((n) => n.substring(name.length))\n                .map((n) => n.startsWith(\"/\") ? n.substring(1) : n)\n                .map((n) => n.split(\"/\")[0])),\n        ]);\n    }\n    cd(name: string): void {\n        if (name.startsWith(\"/\")) {\n            this.zipRoot = name.substring(1);\n            return;\n        }\n        let paths = name.split(\"/\");\n        for (let path of paths) {\n            if (path === \".\") {\n                continue;\n            } else if (path === \"..\") {\n                let sub = this.zipRoot.split(\"/\");\n                if (sub.length > 0) {\n                    sub.pop();\n                    this.zipRoot = sub.join(\"/\");\n                }\n            } else {\n                if (this.zipRoot === \"\") {\n                    this.zipRoot = path;\n                } else {\n                    this.zipRoot += `/${path}`;\n                }\n            }\n        }\n    }\n    async walkFiles(startingDir: string, walker: (path: string) => void | Promise<void>) {\n        startingDir = this.normalizePath(startingDir);\n        const root = startingDir.startsWith(\"/\") ? startingDir.substring(1) : startingDir;\n        for (const child of Object.keys(this.entries).filter((e) => e.startsWith(root))) {\n            if (child.endsWith(\"/\")) { continue; }\n            const result = walker(child);\n            if (result instanceof Promise) {\n                await result;\n            }\n        }\n    }\n}\n\nexport * from \"./system\";\n\n"],"names":[],"mappings":"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"}