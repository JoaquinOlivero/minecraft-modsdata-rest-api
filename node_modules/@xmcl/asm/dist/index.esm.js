/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
/**
 * Defines the JVM opcodes, access flags and array type codes. This interface
 * does not define all the JVM opcodes because some opcodes are automatically
 * handled. For example, the xLOAD and xSTORE opcodes are automatically replaced
 * by xLOAD_n and xSTORE_n opcodes when possible. The xLOAD_n and xSTORE_n
 * opcodes are therefore not defined in this interface. Likewise for LDC,
 * automatically replaced by LDC_W or LDC2_W when necessary, WIDE, GOTO_W and
 * JSR_W.
 *
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
var Opcodes;
(function (Opcodes) {
    Opcodes.ASM4 = 4 << 16 | 0 << 8 | 0;
    Opcodes.ASM5 = 5 << 16 | 0 << 8 | 0;
    Opcodes.V1_1 = 3 << 16 | 45;
    Opcodes.V1_2 = 0 << 16 | 46;
    Opcodes.V1_3 = 0 << 16 | 47;
    Opcodes.V1_4 = 0 << 16 | 48;
    Opcodes.V1_5 = 0 << 16 | 49;
    Opcodes.V1_6 = 0 << 16 | 50;
    Opcodes.V1_7 = 0 << 16 | 51;
    Opcodes.V1_8 = 0 << 16 | 52;
    Opcodes.ACC_PUBLIC = 1;
    Opcodes.ACC_PRIVATE = 2;
    Opcodes.ACC_PROTECTED = 4;
    Opcodes.ACC_STATIC = 8;
    Opcodes.ACC_FINAL = 16;
    Opcodes.ACC_SUPER = 32;
    Opcodes.ACC_SYNCHRONIZED = 32;
    Opcodes.ACC_VOLATILE = 64;
    Opcodes.ACC_BRIDGE = 64;
    Opcodes.ACC_VARARGS = 128;
    Opcodes.ACC_TRANSIENT = 128;
    Opcodes.ACC_NATIVE = 256;
    Opcodes.ACC_INTERFACE = 512;
    Opcodes.ACC_ABSTRACT = 1024;
    Opcodes.ACC_STRICT = 2048;
    Opcodes.ACC_SYNTHETIC = 4096;
    Opcodes.ACC_ANNOTATION = 8192;
    Opcodes.ACC_ENUM = 16384;
    Opcodes.ACC_MANDATED = 32768;
    Opcodes.ACC_DEPRECATED = 131072;
    Opcodes.T_BOOLEAN = 4;
    Opcodes.T_CHAR = 5;
    Opcodes.T_FLOAT = 6;
    Opcodes.T_DOUBLE = 7;
    Opcodes.T_BYTE = 8;
    Opcodes.T_SHORT = 9;
    Opcodes.T_INT = 10;
    Opcodes.T_LONG = 11;
    Opcodes.H_GETFIELD = 1;
    Opcodes.H_GETSTATIC = 2;
    Opcodes.H_PUTFIELD = 3;
    Opcodes.H_PUTSTATIC = 4;
    Opcodes.H_INVOKEVIRTUAL = 5;
    Opcodes.H_INVOKESTATIC = 6;
    Opcodes.H_INVOKESPECIAL = 7;
    Opcodes.H_NEWINVOKESPECIAL = 8;
    Opcodes.H_INVOKEINTERFACE = 9;
    /**
     * Represents an expanded frame. See {@link ClassReader#EXPAND_FRAMES}.
     */
    Opcodes.F_NEW = -1;
    /**
     * Represents a compressed frame with compexport conste frame data.
     */
    Opcodes.F_FULL = 0;
    /**
     * Represents a compressed frame where locals are the same as the locals in
     * the previous frame, except that additional 1-3 locals are defined, and
     * with an empty stack.
     */
    Opcodes.F_APPEND = 1;
    /**
     * Represents a compressed frame where locals are the same as the locals in
     * the previous frame, except that the last 1-3 locals are absent and with
     * an empty stack.
     */
    Opcodes.F_CHOP = 2;
    /**
     * Represents a compressed frame with exactly the same locals as the
     * previous frame and with an empty stack.
     */
    Opcodes.F_SAME = 3;
    /**
     * Represents a compressed frame with exactly the same locals as the
     * previous frame and with a single value on the stack.
     */
    Opcodes.F_SAME1 = 4;
    Opcodes.TOP = new Number(0);
    Opcodes.INTEGER = new Number(1);
    Opcodes.FLOAT = new Number(2);
    Opcodes.DOUBLE = new Number(3);
    Opcodes.LONG = new Number(4);
    Opcodes.NULL = new Number(5);
    Opcodes.UNINITIALIZED_THIS = new Number(6);
    Opcodes.NOP = 0;
    Opcodes.ACONST_NULL = 1;
    Opcodes.ICONST_M1 = 2;
    Opcodes.ICONST_0 = 3;
    Opcodes.ICONST_1 = 4;
    Opcodes.ICONST_2 = 5;
    Opcodes.ICONST_3 = 6;
    Opcodes.ICONST_4 = 7;
    Opcodes.ICONST_5 = 8;
    Opcodes.LCONST_0 = 9;
    Opcodes.LCONST_1 = 10;
    Opcodes.FCONST_0 = 11;
    Opcodes.FCONST_1 = 12;
    Opcodes.FCONST_2 = 13;
    Opcodes.DCONST_0 = 14;
    Opcodes.DCONST_1 = 15;
    Opcodes.BIPUSH = 16;
    Opcodes.SIPUSH = 17;
    Opcodes.LDC = 18;
    Opcodes.ILOAD = 21;
    Opcodes.LLOAD = 22;
    Opcodes.FLOAD = 23;
    Opcodes.DLOAD = 24;
    Opcodes.ALOAD = 25;
    Opcodes.IALOAD = 46;
    Opcodes.LALOAD = 47;
    Opcodes.FALOAD = 48;
    Opcodes.DALOAD = 49;
    Opcodes.AALOAD = 50;
    Opcodes.BALOAD = 51;
    Opcodes.CALOAD = 52;
    Opcodes.SALOAD = 53;
    Opcodes.ISTORE = 54;
    Opcodes.LSTORE = 55;
    Opcodes.FSTORE = 56;
    Opcodes.DSTORE = 57;
    Opcodes.ASTORE = 58;
    Opcodes.IASTORE = 79;
    Opcodes.LASTORE = 80;
    Opcodes.FASTORE = 81;
    Opcodes.DASTORE = 82;
    Opcodes.AASTORE = 83;
    Opcodes.BASTORE = 84;
    Opcodes.CASTORE = 85;
    Opcodes.SASTORE = 86;
    Opcodes.POP = 87;
    Opcodes.POP2 = 88;
    Opcodes.DUP = 89;
    Opcodes.DUP_X1 = 90;
    Opcodes.DUP_X2 = 91;
    Opcodes.DUP2 = 92;
    Opcodes.DUP2_X1 = 93;
    Opcodes.DUP2_X2 = 94;
    Opcodes.SWAP = 95;
    Opcodes.IADD = 96;
    Opcodes.LADD = 97;
    Opcodes.FADD = 98;
    Opcodes.DADD = 99;
    Opcodes.ISUB = 100;
    Opcodes.LSUB = 101;
    Opcodes.FSUB = 102;
    Opcodes.DSUB = 103;
    Opcodes.IMUL = 104;
    Opcodes.LMUL = 105;
    Opcodes.FMUL = 106;
    Opcodes.DMUL = 107;
    Opcodes.IDIV = 108;
    Opcodes.LDIV = 109;
    Opcodes.FDIV = 110;
    Opcodes.DDIV = 111;
    Opcodes.IREM = 112;
    Opcodes.LREM = 113;
    Opcodes.FREM = 114;
    Opcodes.DREM = 115;
    Opcodes.INEG = 116;
    Opcodes.LNEG = 117;
    Opcodes.FNEG = 118;
    Opcodes.DNEG = 119;
    Opcodes.ISHL = 120;
    Opcodes.LSHL = 121;
    Opcodes.ISHR = 122;
    Opcodes.LSHR = 123;
    Opcodes.IUSHR = 124;
    Opcodes.LUSHR = 125;
    Opcodes.IAND = 126;
    Opcodes.LAND = 127;
    Opcodes.IOR = 128;
    Opcodes.LOR = 129;
    Opcodes.IXOR = 130;
    Opcodes.LXOR = 131;
    Opcodes.IINC = 132;
    Opcodes.I2L = 133;
    Opcodes.I2F = 134;
    Opcodes.I2D = 135;
    Opcodes.L2I = 136;
    Opcodes.L2F = 137;
    Opcodes.L2D = 138;
    Opcodes.F2I = 139;
    Opcodes.F2L = 140;
    Opcodes.F2D = 141;
    Opcodes.D2I = 142;
    Opcodes.D2L = 143;
    Opcodes.D2F = 144;
    Opcodes.I2B = 145;
    Opcodes.I2C = 146;
    Opcodes.I2S = 147;
    Opcodes.LCMP = 148;
    Opcodes.FCMPL = 149;
    Opcodes.FCMPG = 150;
    Opcodes.DCMPL = 151;
    Opcodes.DCMPG = 152;
    Opcodes.IFEQ = 153;
    Opcodes.IFNE = 154;
    Opcodes.IFLT = 155;
    Opcodes.IFGE = 156;
    Opcodes.IFGT = 157;
    Opcodes.IFLE = 158;
    Opcodes.IF_ICMPEQ = 159;
    Opcodes.IF_ICMPNE = 160;
    Opcodes.IF_ICMPLT = 161;
    Opcodes.IF_ICMPGE = 162;
    Opcodes.IF_ICMPGT = 163;
    Opcodes.IF_ICMPLE = 164;
    Opcodes.IF_ACMPEQ = 165;
    Opcodes.IF_ACMPNE = 166;
    Opcodes.GOTO = 167;
    Opcodes.JSR = 168;
    Opcodes.RET = 169;
    Opcodes.TABLESWITCH = 170;
    Opcodes.LOOKUPSWITCH = 171;
    Opcodes.IRETURN = 172;
    Opcodes.LRETURN = 173;
    Opcodes.FRETURN = 174;
    Opcodes.DRETURN = 175;
    Opcodes.ARETURN = 176;
    Opcodes.RETURN = 177;
    Opcodes.GETSTATIC = 178;
    Opcodes.PUTSTATIC = 179;
    Opcodes.GETFIELD = 180;
    Opcodes.PUTFIELD = 181;
    Opcodes.INVOKEVIRTUAL = 182;
    Opcodes.INVOKESPECIAL = 183;
    Opcodes.INVOKESTATIC = 184;
    Opcodes.INVOKEINTERFACE = 185;
    Opcodes.INVOKEDYNAMIC = 186;
    Opcodes.NEW = 187;
    Opcodes.NEWARRAY = 188;
    Opcodes.ANEWARRAY = 189;
    Opcodes.ARRAYLENGTH = 190;
    Opcodes.ATHROW = 191;
    Opcodes.CHECKCAST = 192;
    Opcodes.INSTANCEOF = 193;
    Opcodes.MONITORENTER = 194;
    Opcodes.MONITOREXIT = 195;
    Opcodes.MULTIANEWARRAY = 197;
    Opcodes.IFNULL = 198;
    Opcodes.IFNONNULL = 199;
})(Opcodes || (Opcodes = {}));

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class AnnotationVisitor {
    /**
     * Constructs a new {@link AnnotationVisitor}.
     *
     * @param api
     * the ASM API version implemented by this visitor. Must be one
     * of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param av
     * the annotation visitor to which this visitor must delegate
     * method calls. May be null.
     */
    constructor(api, av = null) {
        this.api = 0;
        if (api !== Opcodes.ASM4 && api !== Opcodes.ASM5) {
            throw new Error();
        }
        this.api = api;
        this.av = av;
    }
    /**
     * Visits a primitive value of the annotation.
     *
     * @param name
     * the value name.
     * @param value
     * the actual value, whose type must be {@link Byte},
     * {@link Boolean}, {@link Character}, {@link Short},
     * {@link Integer} , {@link Long}, {@link Float}, {@link Double},
     * {@link String} or {@link Type} of OBJECT or ARRAY sort. This
     * value can also be an array of byte, boolean, short, char, int,
     * long, float or double values (this is equivalent to using
     * {@link #visitArray visitArray} and visiting each array element
     * in turn, but is more convenient).
     */
    visit(name, value) {
        if (this.av != null) {
            this.av.visit(name, value);
        }
    }
    /**
     * Visits an enumeration value of the annotation.
     *
     * @param name
     * the value name.
     * @param desc
     * the class descriptor of the enumeration class.
     * @param value
     * the actual enumeration value.
     */
    visitEnum(name, desc, value) {
        if (this.av != null) {
            this.av.visitEnum(name, desc, value);
        }
    }
    /**
     * Visits a nested annotation value of the annotation.
     *
     * @param name
     * the value name.
     * @param desc
     * the class descriptor of the nested annotation class.
     * @return a visitor to visit the actual nested annotation value, or
     * <tt>null</tt> if this visitor is not interested in visiting this
     * nested annotation. <i>The nested annotation value must be fully
     * visited before calling other methods on this annotation
     * visitor</i>.
     */
    visitAnnotation(name, desc) {
        if (this.av != null) {
            return this.av.visitAnnotation(name, desc);
        }
        return null;
    }
    /**
     * Visits an array value of the annotation. Note that arrays of primitive
     * types (such as byte, boolean, short, char, int, long, float or double)
     * can be passed as value to {@link #visit visit}. This is what
     * {@link ClassReader} does.
     *
     * @param name
     * the value name.
     * @return a visitor to visit the actual array value elements, or
     * <tt>null</tt> if this visitor is not interested in visiting these
     * values. The 'name' parameters passed to the methods of this
     * visitor are ignored. <i>All the array values must be visited
     * before calling other methods on this annotation visitor</i>.
     */
    visitArray(name) {
        if (this.av != null) {
            return this.av.visitArray(name);
        }
        return null;
    }
    /**
     * Visits the end of the annotation.
     */
    visitEnd() {
        if (this.av != null) {
            this.av.visitEnd();
        }
    }
}

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
/**
 * A dynamically extensible vector of bytes. This class is roughly equivalent to
 * a DataOutputStream on top of a ByteArrayOutputStream, but is more efficient.
 *
 * @author Eric Bruneton
 */
class ByteVector {
    /**
     * Constructs a new {@link ByteVector ByteVector} with the given initial
     * size.
     *
     * @param initialSize
     * the initial size of the byte vector to be constructed.
     */
    constructor(initialSize = 64) {
        /**
         * Actual number of bytes in this vector.
         */
        this.length = 0;
        this.data = new Uint8Array(initialSize);
    }
    /**
     * Puts a byte into this byte vector. The byte vector is automatically
     * enlarged if necessary.
     *
     * @param b
     * a byte.
     * @return this byte vector.
     */
    putByte(b) {
        let length = this.length;
        if (length + 1 > this.data.length) {
            this.enlarge(1);
        }
        this.data[length++] = (b | 0);
        this.length = length;
        return this;
    }
    /**
     * Puts two bytes into this byte vector. The byte vector is automatically
     * enlarged if necessary.
     *
     * @param b1
     * a byte.
     * @param b2
     * another byte.
     * @return this byte vector.
     */
    put11(b1, b2) {
        let length = this.length;
        if (length + 2 > this.data.length) {
            this.enlarge(2);
        }
        let data = this.data;
        data[length++] = (b1 | 0);
        data[length++] = (b2 | 0);
        this.length = length;
        return this;
    }
    /**
     * Puts a short into this byte vector. The byte vector is automatically
     * enlarged if necessary.
     *
     * @param s
     * a short.
     * @return this byte vector.
     */
    putShort(s) {
        let length = this.length;
        if (length + 2 > this.data.length) {
            this.enlarge(2);
        }
        let data = this.data;
        data[length++] = ((s >>> 8) | 0);
        data[length++] = (s | 0);
        this.length = length;
        return this;
    }
    /**
     * Puts a byte and a short into this byte vector. The byte vector is
     * automatically enlarged if necessary.
     *
     * @param b a byte.
     * @param s a short.
     * @return this byte vector.
     */
    put12(b, s) {
        let length = this.length;
        if (length + 3 > this.data.length) {
            this.enlarge(3);
        }
        let data = this.data;
        data[length++] = (b | 0);
        data[length++] = ((s >>> 8) | 0);
        data[length++] = (s | 0);
        this.length = length;
        return this;
    }
    /**
     * Puts an int into this byte vector. The byte vector is automatically
     * enlarged if necessary.
     *
     * @param i
     * an int.
     * @return this byte vector.
     */
    putInt(i) {
        let length = this.length;
        if (length + 4 > this.data.length) {
            this.enlarge(4);
        }
        let data = this.data;
        data[length++] = ((i >>> 24) | 0);
        data[length++] = ((i >>> 16) | 0);
        data[length++] = ((i >>> 8) | 0);
        data[length++] = (i | 0);
        this.length = length;
        return this;
    }
    /**
     * Puts a long into this byte vector. The byte vector is automatically
     * enlarged if necessary.
     *
     * @param l
     * a long.
     * @return this byte vector.
     */
    putLong(l) {
        let length = this.length;
        if (length + 8 > this.data.length) {
            this.enlarge(8);
        }
        let data = this.data;
        let i = l.getHighBits();
        data[length++] = (i >>> 24) & 256;
        data[length++] = (i >>> 16) & 256;
        data[length++] = (i >>> 8) & 256;
        data[length++] = i & 256;
        i = l.getLowBits();
        data[length++] = ((i >>> 24) & 256);
        data[length++] = ((i >>> 16) & 256);
        data[length++] = ((i >>> 8) & 256);
        data[length++] = (i & 256);
        this.length = length;
        return this;
    }
    /**
     * Puts an UTF8 string into this byte vector. The byte vector is
     * automatically enlarged if necessary.
     *
     * @param s
     * a String whose UTF8 encoded length must be less than 65536.
     * @return this byte vector.
     */
    putUTF8(s) {
        let charLength = s.length;
        if (charLength > 65535) {
            throw new Error();
        }
        let len = this.length;
        if (len + 2 + charLength > this.data.length) {
            this.enlarge(2 + charLength);
        }
        let data = this.data;
        data[len++] = ((charLength >>> 8) | 0);
        data[len++] = (charLength | 0);
        for (let i = 0; i < charLength; ++i) {
            let c = s.charAt(i);
            if ((c).charCodeAt(0) >= ("\u0001").charCodeAt(0) && (c).charCodeAt(0) <= ("\u007f").charCodeAt(0)) {
                data[len++] = (c).charCodeAt(0);
            }
            else {
                this.length = len;
                return this.encodeUTF8(s, i, 65535);
            }
        }
        this.length = len;
        return this;
    }
    /**
     * Puts an UTF8 string into this byte vector. The byte vector is
     * automatically enlarged if necessary. The string length is encoded in two
     * bytes before the encoded characters, if there is space for that (i.e. if
     * this.length - i - 2 >= 0).
     *
     * @param s
     * the String to encode.
     * @param i
     * the index of the first character to encode. The previous
     * characters are supposed to have already been encoded, using
     * only one byte per character.
     * @param maxByteLength
     * the maximum byte length of the encoded string, including the
     * already encoded characters.
     * @return this byte vector.
     */
    encodeUTF8(s, i, maxByteLength) {
        let charLength = s.length;
        let byteLength = i;
        let c;
        for (let j = i; j < charLength; ++j) {
            c = s.charAt(j);
            if ((c).charCodeAt(0) >= ("\u0001").charCodeAt(0) && (c).charCodeAt(0) <= ("\u007f").charCodeAt(0)) {
                byteLength++;
            }
            else if ((c).charCodeAt(0) > ("\u07ff").charCodeAt(0)) {
                byteLength += 3;
            }
            else {
                byteLength += 2;
            }
        }
        if (byteLength > maxByteLength) {
            throw new Error();
        }
        let start = this.length - i - 2;
        if (start >= 0) {
            this.data[start] = ((byteLength >>> 8) | 0);
            this.data[start + 1] = (byteLength | 0);
        }
        if (this.length + byteLength - i > this.data.length) {
            this.enlarge(byteLength - i);
        }
        let len = this.length;
        for (let j = i; j < charLength; ++j) {
            c = s.charAt(j);
            if ((c).charCodeAt(0) >= ("\u0001").charCodeAt(0) && (c).charCodeAt(0) <= ("\u007f").charCodeAt(0)) {
                this.data[len++] = (c).charCodeAt(0);
            }
            else if ((c).charCodeAt(0) > ("\u07ff").charCodeAt(0)) {
                this.data[len++] = ((224 | (c).charCodeAt(0) >> 12 & 15) | 0);
                this.data[len++] = ((128 | (c).charCodeAt(0) >> 6 & 63) | 0);
                this.data[len++] = ((128 | (c).charCodeAt(0) & 63) | 0);
            }
            else {
                this.data[len++] = ((192 | (c).charCodeAt(0) >> 6 & 31) | 0);
                this.data[len++] = ((128 | (c).charCodeAt(0) & 63) | 0);
            }
        }
        this.length = len;
        return this;
    }
    /**
     * Puts an array of bytes into this byte vector. The byte vector is
     * automatically enlarged if necessary.
     *
     * @param b
     * an array of bytes. May be <tt>null</tt> to put <tt>len</tt>
     * null bytes into this byte vector.
     * @param off
     * index of the fist byte of b that must be copied.
     * @param len
     * number of bytes of b that must be copied.
     * @return this byte vector.
     */
    putByteArray(b, off, len) {
        if (this.length + len > this.data.length) {
            this.enlarge(len);
        }
        if (b != null) {
            for (let i = 0; i < len; i++) {
                this.data[i + this.length] = b[i + off];
            }
            // java.lang.System.arraycopy(b, off, this.data, this.length, len);
        }
        this.length += len;
        return this;
    }
    /**
     * Enlarge this byte vector so that it can receive n more bytes.
     *
     * @param size
     * number of additional bytes that this byte vector should be
     * able to receive.
     */
    enlarge(size) {
        let length1 = 2 * this.data.length;
        let length2 = this.length + size;
        const newArr = new Uint8Array(length1 > length2 ? length1 : length2);
        newArr.set(this.data);
        this.data = newArr;
    }
}

function assert(v) {
    if (!v) {
        throw new Error("nullptr");
    }
}

class Attribute {
    /**
     * Constructs a new empty attribute.
     *
     * @param type
     * the type of the attribute.
     */
    constructor(type) {
        /**
         * The next attribute in this attribute list. May be <tt>null</tt>.
         */
        this.next = null;
        this.type = type;
    }
    /**
     * Returns <tt>true</tt> if this type of attribute is unknown. The default
     * implementation of this method always returns <tt>true</tt>.
     *
     * @return <tt>true</tt> if this type of attribute is unknown.
     */
    isUnknown() {
        return true;
    }
    /**
     * Returns <tt>true</tt> if this type of attribute is a code attribute.
     *
     * @return <tt>true</tt> if this type of attribute is a code attribute.
     */
    isCodeAttribute() {
        return false;
    }
    /**
     * Returns the labels corresponding to this attribute.
     *
     * @return the labels corresponding to this attribute, or <tt>null</tt> if
     * this attribute is not a code attribute that contains labels.
     */
    getLabels() {
        return null;
    }
    /**
     * Reads a {@link #type type} attribute. This method must return a
     * <i>new</i> {@link Attribute} object, of type {@link #type type},
     * corresponding to the <tt>len</tt> bytes starting at the given offset, in
     * the given class reader.
     *
     * @param cr
     * the class that contains the attribute to be read.
     * @param off
     * index of the first byte of the attribute's content in
     * {@link ClassReader#b cr.b}. The 6 attribute header bytes,
     * containing the type and the length of the attribute, are not
     * taken into account here.
     * @param len
     * the length of the attribute's content.
     * @param buf
     * buffer to be used to call {@link ClassReader#readUTF8
     * readUTF8}, {@link ClassReader#readClass(int,char[]) readClass}
     * or {@link ClassReader#readConst readConst}.
     * @param codeOff
     * index of the first byte of code's attribute content in
     * {@link ClassReader#b cr.b}, or -1 if the attribute to be read
     * is not a code attribute. The 6 attribute header bytes,
     * containing the type and the length of the attribute, are not
     * taken into account here.
     * @param labels
     * the labels of the method's code, or <tt>null</tt> if the
     * attribute to be read is not a code attribute.
     * @return a <i>new</i> {@link Attribute} object corresponding to the given
     * bytes.
     */
    read(cr, off, len, buf, codeOff, labels) {
        let attr = new Attribute(this.type);
        attr.value = cr.buf.slice(0, len);
        // java.lang.System.arraycopy(cr.b, off, attr.value, 0, len);
        return attr;
    }
    /**
     * Returns the byte array form of this attribute.
     *
     * @param cw
     * the class to which this attribute must be added. This
     * parameter can be used to add to the constant pool of this
     * class the items that corresponds to this attribute.
     * @param code
     * the bytecode of the method corresponding to this code
     * attribute, or <tt>null</tt> if this attribute is not a code
     * attributes.
     * @param len
     * the length of the bytecode of the method corresponding to this
     * code attribute, or <tt>null</tt> if this attribute is not a
     * code attribute.
     * @param maxStack
     * the maximum stack size of the method corresponding to this
     * code attribute, or -1 if this attribute is not a code
     * attribute.
     * @param maxLocals
     * the maximum number of local variables of the method
     * corresponding to this code attribute, or -1 if this attribute
     * is not a code attribute.
     * @return the byte array form of this attribute.
     */
    write(cw, code, len, maxStack, maxLocals) {
        let v = new ByteVector();
        v.data = this.value;
        v.length = this.value.length;
        return v;
    }
    /**
     * Returns the length of the attribute list that begins with this attribute.
     *
     * @return the length of the attribute list that begins with this attribute.
     */
    getCount() {
        let count = 0;
        let attr = this;
        while ((attr != null)) {
            count += 1;
            attr = attr.next;
        }
        return count;
    }
    /**
     * Returns the size of all the attributes in this attribute list.
     *
     * @param cw
     * the class writer to be used to convert the attributes into
     * byte arrays, with the {@link #write write} method.
     * @param code
     * the bytecode of the method corresponding to these code
     * attributes, or <tt>null</tt> if these attributes are not code
     * attributes.
     * @param len
     * the length of the bytecode of the method corresponding to
     * these code attributes, or <tt>null</tt> if these attributes
     * are not code attributes.
     * @param maxStack
     * the maximum stack size of the method corresponding to these
     * code attributes, or -1 if these attributes are not code
     * attributes.
     * @param maxLocals
     * the maximum number of local variables of the method
     * corresponding to these code attributes, or -1 if these
     * attributes are not code attributes.
     * @return the size of all the attributes in this attribute list. This size
     * includes the size of the attribute headers.
     */
    getSize(cw, code, len, maxStack, maxLocals) {
        let attr = this;
        let size = 0;
        while ((attr != null)) {
            assert(attr.type);
            cw.newUTF8(attr.type);
            size += attr.write(cw, code, len, maxStack, maxLocals).length + 6;
            attr = attr.next;
        }
        return size;
    }
    /**
     * Writes all the attributes of this attribute list in the given byte
     * vector.
     *
     * @param cw
     * the class writer to be used to convert the attributes into
     * byte arrays, with the {@link #write write} method.
     * @param code
     * the bytecode of the method corresponding to these code
     * attributes, or <tt>null</tt> if these attributes are not code
     * attributes.
     * @param len
     * the length of the bytecode of the method corresponding to
     * these code attributes, or <tt>null</tt> if these attributes
     * are not code attributes.
     * @param maxStack
     * the maximum stack size of the method corresponding to these
     * code attributes, or -1 if these attributes are not code
     * attributes.
     * @param maxLocals
     * the maximum number of local variables of the method
     * corresponding to these code attributes, or -1 if these
     * attributes are not code attributes.
     * @param out
     * where the attributes must be written.
     */
    put(cw, code, len, maxStack, maxLocals, out) {
        let attr = this;
        while ((attr != null)) {
            let b = attr.write(cw, code, len, maxStack, maxLocals);
            assert(attr.type);
            out.putShort(cw.newUTF8(attr.type)).putInt(b.length);
            out.putByteArray(b.data, 0, b.length);
            attr = attr.next;
        }
    }
}

/**
 * A Java field or method type. This class can be used to make it easier to
 * manipulate type and method descriptors.
 *
 * @author Eric Bruneton
 * @author Chris Nokleberg
 */
class Type {
    /**
     * Constructs a reference type.
     *
     * @param sort the sort of the reference type to be constructed.
     * @param buf  a buffer containing the descriptor of the previous type.
     * @param off  the offset of this descriptor in the previous buffer.
     * @param len  the length of this descriptor.
     */
    constructor(sort, buf, off, len) {
        this.sort = 0;
        this.off = 0;
        this.len = 0;
        this.sort = sort;
        this.buf = buf !== null && buf !== void 0 ? buf : "";
        this.off = off;
        this.len = len;
    }
    /**
     * Returns the Java type corresponding to the given internal name.
     *
     * @param internalName an internal name.
     * @return the Java type corresponding to the given internal name.
     */
    static getObjectType(internalName) {
        return new Type(internalName[0] === "[" ? Type.ARRAY : Type.OBJECT, internalName, 0, internalName.length);
    }
    /**
     * Returns the Java type corresponding to the given method descriptor.
     * Equivalent to <code>Type.getType(methodDescriptor)</code>.
     *
     * @param methodDescriptor a method descriptor.
     * @return the Java type corresponding to the given method descriptor.
     */
    static getMethodType(methodDescriptor) {
        return Type.getType(methodDescriptor, 0);
    }
    /**
     * Returns the Java types corresponding to the argument types of the given
     * method descriptor.
     *
     * @param methodDescriptor a method descriptor.
     * @return the Java types corresponding to the argument types of the given
     * method descriptor.
     */
    static getArgumentTypes(methodDescriptor) {
        let off = 1;
        let size = 0;
        while ((true)) {
            let car = methodDescriptor[off++];
            if (car === ")") {
                break;
            }
            else if (car === "L") {
                while ((methodDescriptor[off++] !== ";")) {
                }
                ++size;
            }
            else if (car !== "[") {
                ++size;
            }
        }
        let args = new Array(size);
        off = 1;
        size = 0;
        while ((methodDescriptor[off] !== ")")) {
            args[size] = Type.getType(methodDescriptor, off);
            off += args[size].len + (args[size].sort === Type.OBJECT ? 2 : 0);
            size += 1;
        }
        return args;
    }
    /**
     * Computes the size of the arguments and of the return value of a method.
     *
     * @param desc the descriptor of a method.
     * @return the size of the arguments of the method (plus one for the
     * implicit this argument), argSize, and the size of its return
     * value, retSize, packed into a single int i =
     * <tt>(argSize &lt;&lt; 2) | retSize</tt> (argSize is therefore equal to
     * <tt>i &gt;&gt; 2</tt>, and retSize to <tt>i &amp; 0x03</tt>).
     */
    static getArgumentsAndReturnSizes(desc) {
        let n = 1;
        let c = 1;
        while ((true)) {
            let car = desc.charAt(c++);
            if (car === ")") {
                car = desc.charAt(c);
                return n << 2 | (car === "V" ? 0 : (car === "D" || car === "J" ? 2 : 1));
            }
            else if (car === "L") {
                while ((desc.charAt(c++) !== ";")) {
                }
                n += 1;
            }
            else if (car === "[") {
                while (((car = desc.charAt(c)) === "[")) {
                    ++c;
                }
                if (car === "D" || car === "J") {
                    n -= 1;
                }
            }
            else if (car === "D" || car === "J") {
                n += 2;
            }
            else {
                n += 1;
            }
        }
        return 0;
    }
    /**
     * Returns the Java type corresponding to the given type descriptor. For
     * method descriptors, buf is supposed to contain nothing more than the
     * descriptor itself.
     *
     * @param buf a buffer containing a type descriptor.
     * @param off the offset of this descriptor in the previous buffer.
     * @return the Java type corresponding to the given type descriptor.
     */
    static getType(str, off = 0) {
        let len;
        let buf = "".concat(str);
        switch (buf[off]) {
            case "V":
                return Type.VOID_TYPE;
            case "Z":
                return Type.BOOLEAN_TYPE;
            case "C":
                return Type.CHAR_TYPE;
            case "B":
                return Type.BYTE_TYPE;
            case "S":
                return Type.SHORT_TYPE;
            case "I":
                return Type.INT_TYPE;
            case "F":
                return Type.FLOAT_TYPE;
            case "J":
                return Type.LONG_TYPE;
            case "D":
                return Type.DOUBLE_TYPE;
            case "[":
                len = 1;
                while ((buf[off + len] === "[")) {
                    ++len;
                }
                if (buf[off + len] === "L") {
                    ++len;
                    while ((buf[off + len] !== ";")) {
                        ++len;
                    }
                }
                return new Type(Type.ARRAY, buf, off, len + 1);
            case "L":
                len = 1;
                while ((buf[off + len] !== ";")) {
                    ++len;
                }
                return new Type(Type.OBJECT, buf, off + 1, len - 1);
            default:
                return new Type(Type.METHOD, buf, off, buf.length - off);
        }
    }
    /**
       * Returns the internal name of the class corresponding to this object or
       * array type. The internal name of a class is its fully qualified name (as
       * returned by Class.getName(), where '.' are replaced by '/'. This method
       * should only be used for an object or array type.
       *
       * @return the internal name of the class corresponding to this object type.
       */
    get internalName() {
        return this.buf.substr(this.off, this.len);
    }
    /**
     * Appends the descriptor corresponding to this Java type to the given
     * string buffer.
     *
     * @param buf the string buffer to which the descriptor must be appended.
     */
    getDescriptor(buf = "") {
        if (this.sort == Type.OBJECT) {
            buf += ("L");
            for (let i = 0; i < this.len; i++) {
                buf += this.buf[i + this.off];
            }
            // buf.append(this.buf, off, len);
            buf += (";");
        }
        else { // sort == ARRAY || sort == METHOD
            for (let i = 0; i < this.len; i++) {
                buf += this.buf[i + this.off];
            }
            // buf.append(this.buf, this.off, this.len);
        }
    }
    /**
        * Returns the size of values of this type. This method must not be used for
        * method types.
        *
        * @return the size of values of this type, i.e., 2 for <tt>long</tt> and
        * <tt>double</tt>, 0 for <tt>void</tt> and 1 otherwise.
        */
    get size() {
        return this.buf == null ? (this.off & 255) : 1;
    }
    /**
     * Tests if the given object is equal to this type.
     *
     * @param o the object to be compared to this type.
     * @return <tt>true</tt> if the given object is equal to this type.
     */
    equals(o) {
        if (this === o) {
            return true;
        }
        if (!(o != null && o instanceof Type)) {
            return false;
        }
        let t = o;
        if (this.sort !== t.sort) {
            return false;
        }
        if (this.sort >= Type.ARRAY) {
            if (this.len !== t.len) {
                return false;
            }
            for (let i = this.off, j = t.off, end = i + this.len; i < end; i++, j++) {
                if (this.buf[i] !== t.buf[j]) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Returns a hash code value for this type.
     *
     * @return a hash code value for this type.
     */
    hashCode() {
        let hc = 13 * this.sort;
        if (this.sort >= Type.ARRAY) {
            for (let i = this.off, end = i + this.len; i < end; i++) {
                hc = 17 * (hc + (this.buf[i]).charCodeAt(0));
            }
        }
        return hc;
    }
    /**
     * Returns a string representation of this type.
     *
     * @return the descriptor of this type.
     */
    toString() {
        return this.getDescriptor();
    }
}
/**
* The sort of the <tt>void</tt> type. See {@link #getSort getSort}.
*/
Type.VOID = 0;
/**
 * The sort of the <tt>boolean</tt> type. See {@link #getSort getSort}.
 */
Type.BOOLEAN = 1;
/**
 * The sort of the <tt>char</tt> type. See {@link #getSort getSort}.
 */
Type.CHAR = 2;
/**
 * The sort of the <tt>byte</tt> type. See {@link #getSort getSort}.
 */
Type.BYTE = 3;
/**
 * The sort of the <tt>short</tt> type. See {@link #getSort getSort}.
 */
Type.SHORT = 4;
/**
 * The sort of the <tt>int</tt> type. See {@link #getSort getSort}.
 */
Type.INT = 5;
/**
 * The sort of the <tt>float</tt> type. See {@link #getSort getSort}.
 */
Type.FLOAT = 6;
/**
 * The sort of the <tt>long</tt> type. See {@link #getSort getSort}.
 */
Type.LONG = 7;
/**
 * The sort of the <tt>double</tt> type. See {@link #getSort getSort}.
 */
Type.DOUBLE = 8;
/**
 * The sort of array reference types. See {@link #getSort getSort}.
 */
Type.ARRAY = 9;
/**
 * The sort of object reference types. See {@link #getSort getSort}.
 */
Type.OBJECT = 10;
/**
 * The sort of method types. See {@link #getSort getSort}.
 */
Type.METHOD = 11;
/**
 * The <tt>void</tt> type.
 */
Type.VOID_TYPE = new Type(Type.VOID, null, (("V").charCodeAt(0) << 24) | (5 << 16), 1);
/**
 * The <tt>boolean</tt> type.
 */
Type.BOOLEAN_TYPE = new Type(Type.BOOLEAN, null, (("Z").charCodeAt(0) << 24) | (5 << 8) | 1, 1);
/**
 * The <tt>char</tt> type.
 */
Type.CHAR_TYPE = new Type(Type.CHAR, null, (("C").charCodeAt(0) << 24) | (6 << 8) | 1, 1);
/**
 * The <tt>byte</tt> type.
 */
Type.BYTE_TYPE = new Type(Type.BYTE, null, (("B").charCodeAt(0) << 24) | (5 << 8) | 1, 1);
/**
 * The <tt>short</tt> type.
 */
Type.SHORT_TYPE = new Type(Type.SHORT, null, (("S").charCodeAt(0) << 24) | (7 << 8) | 1, 1);
/**
 * The <tt>int</tt> type.
 */
Type.INT_TYPE = new Type(Type.INT, null, (("I").charCodeAt(0) << 24) | 1, 1);
/**
 * The <tt>float</tt> type.
 */
Type.FLOAT_TYPE = new Type(Type.FLOAT, null, (("F").charCodeAt(0) << 24) | (2 << 16) | (2 << 8) | 1, 1);
/**
 * The <tt>long</tt> type.
 */
Type.LONG_TYPE = new Type(Type.LONG, null, (("J").charCodeAt(0) << 24) | (1 << 16) | (1 << 8) | 2, 1);
/**
 * The <tt>double</tt> type.
 */
Type.DOUBLE_TYPE = new Type(Type.DOUBLE, null, (("D").charCodeAt(0) << 24) | (3 << 16) | (3 << 8) | 2, 1);

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
// import * as Long from 'long'
class AnnotationWriter extends AnnotationVisitor {
    /**
     * Constructs a new {@link AnnotationWriter}.
     *
     * @param cw
     * the class writer to which this annotation must be added.
     * @param named
     * <tt>true<tt> if values are named, <tt>false</tt> otherwise.
     * @param bv
     * where the annotation values must be stored.
     * @param parent
     * where the number of annotation values must be stored.
     * @param offset
     * where in <tt>parent</tt> the number of annotation values must
     * be stored.
     */
    constructor(cw, named, bv, parent = null, offset) {
        super(Opcodes.ASM5);
        /**
         * Next annotation writer. This field is used to store annotation lists.
         */
        this.next = null;
        /**
         * Previous annotation writer. This field is used to store annotation lists.
         */
        this.prev = null;
        this.size = 0;
        this.named = false;
        this.offset = 0;
        this.cw = cw;
        this.named = named;
        this.bv = bv;
        this.parent = parent;
        this.offset = offset;
    }
    visit(name, value) {
        ++this.size;
        if (this.named) {
            this.bv.putShort(this.cw.newUTF8(name));
        }
        if (typeof value === "string") {
            this.bv.put12(("s").charCodeAt(0), this.cw.newUTF8(value));
        }
        else if (typeof value === "number") {
            this.bv.put12(("B").charCodeAt(0), this.cw.newInteger(value).index);
        }
        else if (typeof value === "boolean") {
            let v = (value) ? 1 : 0;
            this.bv.put12(("Z").charCodeAt(0), this.cw.newInteger(v).index);
        }
        else if (typeof value === "string") {
            this.bv.put12(("C").charCodeAt(0), this.cw.newInteger((value).charCodeAt(0)).index);
        }
        else if (typeof value === "number") {
            this.bv.put12(("S").charCodeAt(0), this.cw.newInteger((value)).index);
        }
        else if (value != null && value instanceof Type) {
            this.bv.put12(("c").charCodeAt(0), this.cw.newUTF8((value).getDescriptor()));
        }
        else if (value != null && value instanceof Array) {
            let v = value;
            this.bv.put12(("[").charCodeAt(0), v.length);
            for (let i = 0; i < v.length; i++) {
                this.bv.put12(("B").charCodeAt(0), this.cw.newInteger(v[i]).index);
            }
        }
        else if (value != null && value instanceof Array) {
            let v = value;
            this.bv.put12(("[").charCodeAt(0), v.length);
            for (let i = 0; i < v.length; i++) {
                this.bv.put12(("Z").charCodeAt(0), this.cw.newInteger(v[i] ? 1 : 0).index);
            }
        }
        else if (value != null && value instanceof Array) {
            let v = value;
            this.bv.put12(("[").charCodeAt(0), v.length);
            for (let i = 0; i < v.length; i++) {
                this.bv.put12(("S").charCodeAt(0), this.cw.newInteger(v[i]).index);
            }
        }
        else if (value != null && value instanceof Array) {
            let v = value;
            this.bv.put12(("[").charCodeAt(0), v.length);
            for (let i = 0; i < v.length; i++) {
                this.bv.put12(("C").charCodeAt(0), this.cw.newInteger((v[i]).charCodeAt(0)).index);
            }
        }
        else if (value != null && value instanceof Array) {
            let v = value;
            this.bv.put12(("[").charCodeAt(0), v.length);
            for (let i = 0; i < v.length; i++) {
                this.bv.put12(("I").charCodeAt(0), this.cw.newInteger(v[i]).index);
            }
        }
        else if (value != null && value instanceof Array) {
            let v = value;
            this.bv.put12(("[").charCodeAt(0), v.length);
            for (let i = 0; i < v.length; i++) {
                // break...
                // this.bv.put12(('J').charCodeAt(0), this.cw.newLong(v[i]).index);
            }
        }
        else if (value != null && value instanceof Array) {
            let v = value;
            this.bv.put12(("[").charCodeAt(0), v.length);
            for (let i = 0; i < v.length; i++) {
                this.bv.put12(("F").charCodeAt(0), this.cw.newFloat(v[i]).index);
            }
        }
        else if (value != null && value instanceof Array) {
            let v = value;
            this.bv.put12(("[").charCodeAt(0), v.length);
            for (let i = 0; i < v.length; i++) {
                this.bv.put12(("D").charCodeAt(0), this.cw.newDouble(v[i]).index);
            }
        }
        else {
            let i = this.cw.newConstItem(value);
            this.bv.put12((".s.IFJDCS".charAt(i.type)).charCodeAt(0), i.index);
        }
    }
    visitEnum(name, desc, value) {
        ++this.size;
        if (this.named) {
            this.bv.putShort(this.cw.newUTF8(name));
        }
        this.bv.put12(("e").charCodeAt(0), this.cw.newUTF8(desc)).putShort(this.cw.newUTF8(value));
    }
    visitAnnotation(name, desc) {
        ++this.size;
        if (this.named) {
            this.bv.putShort(this.cw.newUTF8(name));
        }
        this.bv.put12(("@").charCodeAt(0), this.cw.newUTF8(desc)).putShort(0);
        return new AnnotationWriter(this.cw, true, this.bv, this.bv, this.bv.length - 2);
    }
    visitArray(name) {
        ++this.size;
        if (this.named) {
            this.bv.putShort(this.cw.newUTF8(name));
        }
        this.bv.put12(("[").charCodeAt(0), 0);
        return new AnnotationWriter(this.cw, false, this.bv, this.bv, this.bv.length - 2);
    }
    visitEnd() {
        if (this.parent != null) {
            let data = this.parent.data;
            data[this.offset] = ((this.size >>> 8) | 0);
            data[this.offset + 1] = (this.size | 0);
        }
    }
    /**
     * Returns the size of this annotation writer list.
     *
     * @return the size of this annotation writer list.
     */
    getSize() {
        let size = 0;
        let aw = this;
        while ((aw != null)) {
            size += aw.bv.length;
            aw = aw.next;
        }
        return size;
    }
    /**
     * Puts the annotations of this annotation writer list into the given byte
     * vector.
     *
     * @param out
     * where the annotations must be put.
     */
    put(out) {
        let n = 0;
        let size = 2;
        let aw = this;
        let last = null;
        while ((aw != null)) {
            ++n;
            size += aw.bv.length;
            aw.visitEnd();
            aw.prev = last;
            last = aw;
            aw = aw.next;
        }
        out.putInt(size);
        out.putShort(n);
        aw = last;
        while ((aw != null)) {
            out.putByteArray(aw.bv.data, 0, aw.bv.length);
            aw = aw.prev;
        }
    }
    /**
     * Puts the given annotation lists into the given byte vector.
     *
     * @param panns
     * an array of annotation writer lists.
     * @param off
     * index of the first annotation to be written.
     * @param out
     * where the annotations must be put.
     */
    static put(panns, off, out) {
        let size = 1 + 2 * (panns.length - off);
        for (let i = off; i < panns.length; ++i) {
            size += panns[i] == null ? 0 : panns[i].getSize();
        }
        out.putInt(size).putByte(panns.length - off);
        for (let i = off; i < panns.length; ++i) {
            let aw = panns[i];
            let last = null;
            let n = 0;
            while ((aw != null)) {
                ++n;
                aw.visitEnd();
                aw.prev = last;
                last = aw;
                aw = aw.next;
            }
            out.putShort(n);
            aw = last;
            while ((aw != null)) {
                out.putByteArray(aw.bv.data, 0, aw.bv.length);
                aw = aw.prev;
            }
        }
    }
    /**
     * Puts the given type reference and type path into the given bytevector.
     * LOCAL_VARIABLE and RESOURCE_VARIABLE target types are not supported.
     *
     * @param typeRef
     * a reference to the annotated type. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param out
     * where the type reference and type path must be put.
     */
    static putTarget(typeRef, typePath, out) {
        switch ((typeRef >>> 24)) {
            case 0:
            case 1:
            case 22:
                out.putShort(typeRef >>> 16);
                break;
            case 19:
            case 20:
            case 21:
                out.putByte(typeRef >>> 24);
                break;
            case 71:
            case 72:
            case 73:
            case 74:
            case 75:
                out.putInt(typeRef);
                break;
            default:
                out.put12(typeRef >>> 24, (typeRef & 16776960) >> 8);
                break;
        }
        if (typePath == null) {
            out.putByte(0);
        }
        else {
            let length = typePath.buf[typePath.offset] * 2 + 1;
            out.putByteArray(typePath.buf, typePath.offset, length);
        }
    }
}

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class ClassVisitor {
    /**
     * Constructs a new {@link ClassVisitor}.
     *
     * @param api
     * the ASM API version implemented by this visitor. Must be one
     * of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param cv
     * the class visitor to which this visitor must delegate method
     * calls. May be null.
     */
    constructor(api, cv = null) {
        this.api = 0;
        if (api !== Opcodes.ASM4 && api !== Opcodes.ASM5) {
            throw new Error();
        }
        this.api = api;
        this.cv = cv;
    }
    /**
     * Visits the header of the class.
     *
     * @param version
     * the class version.
     * @param access
     * the class's access flags (see {@link Opcodes}). This parameter
     * also indicates if the class is deprecated.
     * @param name
     * the internal name of the class (see
     * {@link Type#getInternalName() getInternalName}).
     * @param signature
     * the signature of this class. May be <tt>null</tt> if the class
     * is not a generic one, and does not extend or implement generic
     * classes or interfaces.
     * @param superName
     * the internal of name of the super class (see
     * {@link Type#getInternalName() getInternalName}). For
     * interfaces, the super class is {@link Object}. May be
     * <tt>null</tt>, but only for the {@link Object} class.
     * @param interfaces
     * the internal names of the class's interfaces (see
     * {@link Type#getInternalName() getInternalName}). May be
     * <tt>null</tt>.
     */
    visit(version, access, name, signature, superName, interfaces) {
        if (this.cv != null) {
            this.cv.visit(version, access, name, signature, superName, interfaces);
        }
    }
    /**
     * Visits the source of the class.
     *
     * @param source
     * the name of the source file from which the class was compiled.
     * May be <tt>null</tt>.
     * @param debug
     * additional debug information to compute the correspondance
     * between source and compiled elements of the class. May be
     * <tt>null</tt>.
     */
    visitSource(source, debug) {
        if (this.cv != null) {
            this.cv.visitSource(source, debug);
        }
    }
    /**
     * Visits the enclosing class of the class. This method must be called only
     * if the class has an enclosing class.
     *
     * @param owner
     * internal name of the enclosing class of the class.
     * @param name
     * the name of the method that contains the class, or
     * <tt>null</tt> if the class is not enclosed in a method of its
     * enclosing class.
     * @param desc
     * the descriptor of the method that contains the class, or
     * <tt>null</tt> if the class is not enclosed in a method of its
     * enclosing class.
     */
    visitOuterClass(owner, name, desc) {
        if (this.cv != null) {
            this.cv.visitOuterClass(owner, name, desc);
        }
    }
    /**
     * Visits an annotation of the class.
     *
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitAnnotation(desc, visible) {
        if (this.cv != null) {
            return this.cv.visitAnnotation(desc, visible);
        }
        return null;
    }
    /**
     * Visits an annotation on a type in the class signature.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#CLASS_TYPE_PARAMETER
     * CLASS_TYPE_PARAMETER},
     * {@link TypeReference#CLASS_TYPE_PARAMETER_BOUND
     * CLASS_TYPE_PARAMETER_BOUND} or
     * {@link TypeReference#CLASS_EXTENDS CLASS_EXTENDS}. See
     * {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitTypeAnnotation(typeRef, typePath, desc, visible) {
        if (this.api < Opcodes.ASM5) {
            throw new Error();
        }
        if (this.cv != null) {
            return this.cv.visitTypeAnnotation(typeRef, typePath, desc, visible);
        }
        return null;
    }
    /**
     * Visits a non standard attribute of the class.
     *
     * @param attr
     * an attribute.
     */
    visitAttribute(attr) {
        if (this.cv != null) {
            this.cv.visitAttribute(attr);
        }
    }
    /**
     * Visits information about an inner class. This inner class is not
     * necessarily a member of the class being visited.
     *
     * @param name
     * the internal name of an inner class (see
     * {@link Type#getInternalName() getInternalName}).
     * @param outerName
     * the internal name of the class to which the inner class
     * belongs (see {@link Type#getInternalName() getInternalName}).
     * May be <tt>null</tt> for not member classes.
     * @param innerName
     * the (simple) name of the inner class inside its enclosing
     * class. May be <tt>null</tt> for anonymous inner classes.
     * @param access
     * the access flags of the inner class as originally declared in
     * the enclosing class.
     */
    visitInnerClass(name, outerName, innerName, access) {
        if (this.cv != null) {
            this.cv.visitInnerClass(name, outerName, innerName, access);
        }
    }
    /**
     * Visits a field of the class.
     *
     * @param access
     * the field's access flags (see {@link Opcodes}). This parameter
     * also indicates if the field is synthetic and/or deprecated.
     * @param name
     * the field's name.
     * @param desc
     * the field's descriptor (see {@link Type Type}).
     * @param signature
     * the field's signature. May be <tt>null</tt> if the field's
     * type does not use generic types.
     * @param value
     * the field's initial value. This parameter, which may be
     * <tt>null</tt> if the field does not have an initial value,
     * must be an {@link Integer}, a {@link Float}, a {@link Long}, a
     * {@link Double} or a {@link String} (for <tt>int</tt>,
     * <tt>float</tt>, <tt>long</tt> or <tt>String</tt> fields
     * respectively). <i>This parameter is only used for static
     * fields</i>. Its value is ignored for non static fields, which
     * must be initialized through bytecode instructions in
     * constructors or methods.
     * @return a visitor to visit field annotations and attributes, or
     * <tt>null</tt> if this class visitor is not interested in visiting
     * these annotations and attributes.
     */
    visitField(access, name, desc, signature, value) {
        if (this.cv != null) {
            return this.cv.visitField(access, name, desc, signature, value);
        }
        return null;
    }
    /**
     * Visits a method of the class. This method <i>must</i> return a new
     * {@link MethodVisitor} instance (or <tt>null</tt>) each time it is called,
     * i.e., it should not return a previously returned visitor.
     *
     * @param access
     * the method's access flags (see {@link Opcodes}). This
     * parameter also indicates if the method is synthetic and/or
     * deprecated.
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor (see {@link Type Type}).
     * @param signature
     * the method's signature. May be <tt>null</tt> if the method
     * parameters, return type and exceptions do not use generic
     * types.
     * @param exceptions
     * the internal names of the method's exception classes (see
     * {@link Type#getInternalName() getInternalName}). May be
     * <tt>null</tt>.
     * @return an object to visit the byte code of the method, or <tt>null</tt>
     * if this class visitor is not interested in visiting the code of
     * this method.
     */
    visitMethod(access, name, desc, signature, exceptions) {
        if (this.cv != null) {
            return this.cv.visitMethod(access, name, desc, signature, exceptions);
        }
        return null;
    }
    /**
     * Visits the end of the class. This method, which is the last one to be
     * called, is used to inform the visitor that all the fields and methods of
     * the class have been visited.
     */
    visitEnd() {
        if (this.cv != null) {
            this.cv.visitEnd();
        }
    }
}

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class FieldVisitor {
    /**
     * Constructs a new {@link FieldVisitor}.
     *
     * @param api
     * the ASM API version implemented by this visitor. Must be one
     * of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param fv
     * the field visitor to which this visitor must delegate method
     * calls. May be null.
     */
    constructor(api, fv = null) {
        this.api = 0;
        if (api !== Opcodes.ASM4 && api !== Opcodes.ASM5) {
            throw new Error();
        }
        this.api = api;
        this.fv = fv;
    }
    /**
     * Visits an annotation of the field.
     *
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitAnnotation(desc, visible) {
        if (this.fv != null) {
            return this.fv.visitAnnotation(desc, visible);
        }
        return null;
    }
    /**
     * Visits an annotation on the type of the field.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#FIELD FIELD}. See
     * {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitTypeAnnotation(typeRef, typePath, desc, visible) {
        if (this.api < Opcodes.ASM5) {
            throw new Error();
        }
        if (this.fv != null) {
            return this.fv.visitTypeAnnotation(typeRef, typePath, desc, visible);
        }
        return null;
    }
    /**
     * Visits a non standard attribute of the field.
     *
     * @param attr
     * an attribute.
     */
    visitAttribute(attr) {
        if (this.fv != null) {
            this.fv.visitAttribute(attr);
        }
    }
    /**
     * Visits the end of the field. This method, which is the last one to be
     * called, is used to inform the visitor that all the annotations and
     * attributes of the field have been visited.
     */
    visitEnd() {
        if (this.fv != null) {
            this.fv.visitEnd();
        }
    }
}

class FieldWriter extends FieldVisitor {
    /**
     * Constructs a new {@link FieldWriter}.
     *
     * @param cw
     * the class writer to which this field must be added.
     * @param access
     * the field's access flags (see {@link Opcodes}).
     * @param name
     * the field's name.
     * @param desc
     * the field's descriptor (see {@link Type}).
     * @param signature
     * the field's signature. May be <tt>null</tt>.
     * @param value
     * the field's constant value. May be <tt>null</tt>.
     */
    constructor(cw, access, name, desc, signature, value) {
        super(Opcodes.ASM5);
        this.access = 0;
        this.name = 0;
        this.desc = 0;
        this.signature = 0;
        this.value = 0;
        if (cw.firstField == null) {
            cw.firstField = this;
        }
        else {
            cw.lastField.fv = this;
        }
        cw.lastField = this;
        this.cw = cw;
        this.access = access;
        this.name = cw.newUTF8(name);
        this.desc = cw.newUTF8(desc);
        if (ClassReader.SIGNATURES && signature != null) {
            this.signature = cw.newUTF8(signature);
        }
        if (value != null) {
            this.value = cw.newConstItem(value).index;
        }
    }
    visitAnnotation(desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        bv.putShort(this.cw.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this.cw, true, bv, bv, 2);
        if (visible) {
            aw.next = this.anns;
            this.anns = aw;
        }
        else {
            aw.next = this.ianns;
            this.ianns = aw;
        }
        return aw;
    }
    visitTypeAnnotation(typeRef, typePath, desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        AnnotationWriter.putTarget(typeRef, typePath, bv);
        bv.putShort(this.cw.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this.cw, true, bv, bv, bv.length - 2);
        if (visible) {
            aw.next = this.tanns;
            this.tanns = aw;
        }
        else {
            aw.next = this.itanns;
            this.itanns = aw;
        }
        return aw;
    }
    visitAttribute(attr) {
        attr.next = this.attrs;
        this.attrs = attr;
    }
    visitEnd() {
    }
    /**
     * Returns the size of this field.
     *
     * @return the size of this field.
     */
    getSize() {
        let size = 8;
        if (this.value !== 0) {
            this.cw.newUTF8("ConstantValue");
            size += 8;
        }
        if ((this.access & Opcodes.ACC_SYNTHETIC) !== 0) {
            if ((this.cw.version & 65535) < Opcodes.V1_5 || (this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) !== 0) {
                this.cw.newUTF8("Synthetic");
                size += 6;
            }
        }
        if ((this.access & Opcodes.ACC_DEPRECATED) !== 0) {
            this.cw.newUTF8("Deprecated");
            size += 6;
        }
        if (ClassReader.SIGNATURES && this.signature !== 0) {
            this.cw.newUTF8("Signature");
            size += 8;
        }
        if (ClassReader.ANNOTATIONS && this.anns != null) {
            this.cw.newUTF8("RuntimeVisibleAnnotations");
            size += 8 + this.anns.getSize();
        }
        if (ClassReader.ANNOTATIONS && this.ianns != null) {
            this.cw.newUTF8("RuntimeInvisibleAnnotations");
            size += 8 + this.ianns.getSize();
        }
        if (ClassReader.ANNOTATIONS && this.tanns != null) {
            this.cw.newUTF8("RuntimeVisibleTypeAnnotations");
            size += 8 + this.tanns.getSize();
        }
        if (ClassReader.ANNOTATIONS && this.itanns != null) {
            this.cw.newUTF8("RuntimeInvisibleTypeAnnotations");
            size += 8 + this.itanns.getSize();
        }
        if (this.attrs != null) {
            size += this.attrs.getSize(this.cw, null, 0, -1, -1);
        }
        return size;
    }
    /**
     * Puts the content of this field into the given byte vector.
     *
     * @param out
     * where the content of this field must be put.
     */
    put(out) {
        let FACTOR = ClassWriter.TO_ACC_SYNTHETIC_$LI$();
        let mask = Opcodes.ACC_DEPRECATED | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE | (((this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / FACTOR | 0));
        out.putShort(this.access & ~mask).putShort(this.name).putShort(this.desc);
        let attributeCount = 0;
        if (this.value !== 0) {
            ++attributeCount;
        }
        if ((this.access & Opcodes.ACC_SYNTHETIC) !== 0) {
            if ((this.cw.version & 65535) < Opcodes.V1_5 || (this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) !== 0) {
                ++attributeCount;
            }
        }
        if ((this.access & Opcodes.ACC_DEPRECATED) !== 0) {
            ++attributeCount;
        }
        if (ClassReader.SIGNATURES && this.signature !== 0) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.anns != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.ianns != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.tanns != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.itanns != null) {
            ++attributeCount;
        }
        if (this.attrs != null) {
            attributeCount += this.attrs.getCount();
        }
        out.putShort(attributeCount);
        if (this.value !== 0) {
            out.putShort(this.cw.newUTF8("ConstantValue"));
            out.putInt(2).putShort(this.value);
        }
        if ((this.access & Opcodes.ACC_SYNTHETIC) !== 0) {
            if ((this.cw.version & 65535) < Opcodes.V1_5 || (this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) !== 0) {
                out.putShort(this.cw.newUTF8("Synthetic")).putInt(0);
            }
        }
        if ((this.access & Opcodes.ACC_DEPRECATED) !== 0) {
            out.putShort(this.cw.newUTF8("Deprecated")).putInt(0);
        }
        if (ClassReader.SIGNATURES && this.signature !== 0) {
            out.putShort(this.cw.newUTF8("Signature"));
            out.putInt(2).putShort(this.signature);
        }
        if (ClassReader.ANNOTATIONS && this.anns != null) {
            out.putShort(this.cw.newUTF8("RuntimeVisibleAnnotations"));
            this.anns.put(out);
        }
        if (ClassReader.ANNOTATIONS && this.ianns != null) {
            out.putShort(this.cw.newUTF8("RuntimeInvisibleAnnotations"));
            this.ianns.put(out);
        }
        if (ClassReader.ANNOTATIONS && this.tanns != null) {
            out.putShort(this.cw.newUTF8("RuntimeVisibleTypeAnnotations"));
            this.tanns.put(out);
        }
        if (ClassReader.ANNOTATIONS && this.itanns != null) {
            out.putShort(this.cw.newUTF8("RuntimeInvisibleTypeAnnotations"));
            this.itanns.put(out);
        }
        if (this.attrs != null) {
            this.attrs.put(this.cw, null, 0, -1, -1, out);
        }
    }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var long_1 = createCommonjsModule(function (module) {
/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
(function(global, factory) {

    /* AMD */ if (typeof commonjsRequire === 'function' && 'object' === "object" && module && module["exports"])
        module["exports"] = factory();
    /* Global */ else
        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();

})(commonjsGlobal, function() {

    /**
     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
     *  See the from* functions below for more convenient ways of constructing Longs.
     * @exports Long
     * @class A Long class for representing a 64 bit two's-complement integer value.
     * @param {number} low The low (signed) 32 bits of the long
     * @param {number} high The high (signed) 32 bits of the long
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @constructor
     */
    function Long(low, high, unsigned) {

        /**
         * The low 32 bits as a signed value.
         * @type {number}
         */
        this.low = low | 0;

        /**
         * The high 32 bits as a signed value.
         * @type {number}
         */
        this.high = high | 0;

        /**
         * Whether unsigned or not.
         * @type {boolean}
         */
        this.unsigned = !!unsigned;
    }

    // The internal representation of a long is the two given signed, 32-bit values.
    // We use 32-bit pieces because these are the size of integers on which
    // Javascript performs bit-operations.  For operations like addition and
    // multiplication, we split each number into 16 bit pieces, which can easily be
    // multiplied within Javascript's floating-point representation without overflow
    // or change in sign.
    //
    // In the algorithms below, we frequently reduce the negative case to the
    // positive case by negating the input(s) and then post-processing the result.
    // Note that we must ALWAYS check specially whether those values are MIN_VALUE
    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
    // a positive number, it overflows back into a negative).  Not handling this
    // case would often result in infinite recursion.
    //
    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
    // methods on which they depend.

    /**
     * An indicator used to reliably determine if an object is a Long or not.
     * @type {boolean}
     * @const
     * @private
     */
    Long.prototype.__isLong__;

    Object.defineProperty(Long.prototype, "__isLong__", {
        value: true,
        enumerable: false,
        configurable: false
    });

    /**
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     * @inner
     */
    function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
    }

    /**
     * Tests if the specified object is a Long.
     * @function
     * @param {*} obj Object
     * @returns {boolean}
     */
    Long.isLong = isLong;

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @inner
     */
    var INT_CACHE = {};

    /**
     * A cache of the Long representations of small unsigned integer values.
     * @type {!Object}
     * @inner
     */
    var UINT_CACHE = {};

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromInt(value, unsigned) {
        var obj, cachedObj, cache;
        if (unsigned) {
            value >>>= 0;
            if (cache = (0 <= value && value < 256)) {
                cachedObj = UINT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
            if (cache)
                UINT_CACHE[value] = obj;
            return obj;
        } else {
            value |= 0;
            if (cache = (-128 <= value && value < 128)) {
                cachedObj = INT_CACHE[value];
                if (cachedObj)
                    return cachedObj;
            }
            obj = fromBits(value, value < 0 ? -1 : 0, false);
            if (cache)
                INT_CACHE[value] = obj;
            return obj;
        }
    }

    /**
     * Returns a Long representing the given 32 bit integer value.
     * @function
     * @param {number} value The 32 bit integer in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromInt = fromInt;

    /**
     * @param {number} value
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromNumber(value, unsigned) {
        if (isNaN(value) || !isFinite(value))
            return unsigned ? UZERO : ZERO;
        if (unsigned) {
            if (value < 0)
                return UZERO;
            if (value >= TWO_PWR_64_DBL)
                return MAX_UNSIGNED_VALUE;
        } else {
            if (value <= -TWO_PWR_63_DBL)
                return MIN_VALUE;
            if (value + 1 >= TWO_PWR_63_DBL)
                return MAX_VALUE;
        }
        if (value < 0)
            return fromNumber(-value, unsigned).neg();
        return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
    }

    /**
     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
     * @function
     * @param {number} value The number in question
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromNumber = fromNumber;

    /**
     * @param {number} lowBits
     * @param {number} highBits
     * @param {boolean=} unsigned
     * @returns {!Long}
     * @inner
     */
    function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
    }

    /**
     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
     *  assumed to use 32 bits.
     * @function
     * @param {number} lowBits The low 32 bits
     * @param {number} highBits The high 32 bits
     * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @returns {!Long} The corresponding Long value
     */
    Long.fromBits = fromBits;

    /**
     * @function
     * @param {number} base
     * @param {number} exponent
     * @returns {number}
     * @inner
     */
    var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

    /**
     * @param {string} str
     * @param {(boolean|number)=} unsigned
     * @param {number=} radix
     * @returns {!Long}
     * @inner
     */
    function fromString(str, unsigned, radix) {
        if (str.length === 0)
            throw Error('empty string');
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
            return ZERO;
        if (typeof unsigned === 'number') {
            // For goog.math.long compatibility
            radix = unsigned,
            unsigned = false;
        } else {
            unsigned = !! unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');

        var p;
        if ((p = str.indexOf('-')) > 0)
            throw Error('interior hyphen');
        else if (p === 0) {
            return fromString(str.substring(1), unsigned, radix).neg();
        }

        // Do several (8) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 8));

        var result = ZERO;
        for (var i = 0; i < str.length; i += 8) {
            var size = Math.min(8, str.length - i),
                value = parseInt(str.substring(i, i + size), radix);
            if (size < 8) {
                var power = fromNumber(pow_dbl(radix, size));
                result = result.mul(power).add(fromNumber(value));
            } else {
                result = result.mul(radixToPower);
                result = result.add(fromNumber(value));
            }
        }
        result.unsigned = unsigned;
        return result;
    }

    /**
     * Returns a Long representation of the given string, written using the specified radix.
     * @function
     * @param {string} str The textual representation of the Long
     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
     * @returns {!Long} The corresponding Long value
     */
    Long.fromString = fromString;

    /**
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
     * @returns {!Long}
     * @inner
     */
    function fromValue(val) {
        if (val /* is compatible */ instanceof Long)
            return val;
        if (typeof val === 'number')
            return fromNumber(val);
        if (typeof val === 'string')
            return fromString(val);
        // Throws for non-objects, converts non-instanceof Long:
        return fromBits(val.low, val.high, val.unsigned);
    }

    /**
     * Converts the specified value to a Long.
     * @function
     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
     * @returns {!Long}
     */
    Long.fromValue = fromValue;

    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
    // no runtime penalty for these.

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_16_DBL = 1 << 16;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_24_DBL = 1 << 24;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

    /**
     * @type {number}
     * @const
     * @inner
     */
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

    /**
     * @type {!Long}
     * @const
     * @inner
     */
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

    /**
     * @type {!Long}
     * @inner
     */
    var ZERO = fromInt(0);

    /**
     * Signed zero.
     * @type {!Long}
     */
    Long.ZERO = ZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var UZERO = fromInt(0, true);

    /**
     * Unsigned zero.
     * @type {!Long}
     */
    Long.UZERO = UZERO;

    /**
     * @type {!Long}
     * @inner
     */
    var ONE = fromInt(1);

    /**
     * Signed one.
     * @type {!Long}
     */
    Long.ONE = ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var UONE = fromInt(1, true);

    /**
     * Unsigned one.
     * @type {!Long}
     */
    Long.UONE = UONE;

    /**
     * @type {!Long}
     * @inner
     */
    var NEG_ONE = fromInt(-1);

    /**
     * Signed negative one.
     * @type {!Long}
     */
    Long.NEG_ONE = NEG_ONE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

    /**
     * Maximum signed value.
     * @type {!Long}
     */
    Long.MAX_VALUE = MAX_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

    /**
     * Maximum unsigned value.
     * @type {!Long}
     */
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

    /**
     * @type {!Long}
     * @inner
     */
    var MIN_VALUE = fromBits(0, 0x80000000|0, false);

    /**
     * Minimum signed value.
     * @type {!Long}
     */
    Long.MIN_VALUE = MIN_VALUE;

    /**
     * @alias Long.prototype
     * @inner
     */
    var LongPrototype = Long.prototype;

    /**
     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
     * @returns {number}
     */
    LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
    };

    /**
     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
     * @returns {number}
     */
    LongPrototype.toNumber = function toNumber() {
        if (this.unsigned)
            return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };

    /**
     * Converts the Long to a string written in the specified radix.
     * @param {number=} radix Radix (2-36), defaults to 10
     * @returns {string}
     * @override
     * @throws {RangeError} If `radix` is out of range
     */
    LongPrototype.toString = function toString(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
            throw RangeError('radix');
        if (this.isZero())
            return '0';
        if (this.isNegative()) { // Unsigned Longs are never negative
            if (this.eq(MIN_VALUE)) {
                // We need to change the Long value before it can be negated, so we remove
                // the bottom-most digit in this base and then recurse to do the rest.
                var radixLong = fromNumber(radix),
                    div = this.div(radixLong),
                    rem1 = div.mul(radixLong).sub(this);
                return div.toString(radix) + rem1.toInt().toString(radix);
            } else
                return '-' + this.neg().toString(radix);
        }

        // Do several (6) digits each time through the loop, so as to
        // minimize the calls to the very expensive emulated div.
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
            rem = this;
        var result = '';
        while (true) {
            var remDiv = rem.div(radixToPower),
                intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
                digits = intval.toString(radix);
            rem = remDiv;
            if (rem.isZero())
                return digits + result;
            else {
                while (digits.length < 6)
                    digits = '0' + digits;
                result = '' + digits + result;
            }
        }
    };

    /**
     * Gets the high 32 bits as a signed integer.
     * @returns {number} Signed high bits
     */
    LongPrototype.getHighBits = function getHighBits() {
        return this.high;
    };

    /**
     * Gets the high 32 bits as an unsigned integer.
     * @returns {number} Unsigned high bits
     */
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
    };

    /**
     * Gets the low 32 bits as a signed integer.
     * @returns {number} Signed low bits
     */
    LongPrototype.getLowBits = function getLowBits() {
        return this.low;
    };

    /**
     * Gets the low 32 bits as an unsigned integer.
     * @returns {number} Unsigned low bits
     */
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
    };

    /**
     * Gets the number of bits needed to represent the absolute value of this Long.
     * @returns {number}
     */
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative()) // Unsigned Longs are never negative
            return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
            if ((val & (1 << bit)) != 0)
                break;
        return this.high != 0 ? bit + 33 : bit + 1;
    };

    /**
     * Tests if this Long's value equals zero.
     * @returns {boolean}
     */
    LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
    };

    /**
     * Tests if this Long's value is negative.
     * @returns {boolean}
     */
    LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
    };

    /**
     * Tests if this Long's value is positive.
     * @returns {boolean}
     */
    LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
    };

    /**
     * Tests if this Long's value is odd.
     * @returns {boolean}
     */
    LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
    };

    /**
     * Tests if this Long's value is even.
     * @returns {boolean}
     */
    LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
    };

    /**
     * Tests if this Long's value equals the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.equals = function equals(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
            return false;
        return this.high === other.high && this.low === other.low;
    };

    /**
     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.eq = LongPrototype.equals;

    /**
     * Tests if this Long's value differs from the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(/* validates */ other);
    };

    /**
     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.neq = LongPrototype.notEquals;

    /**
     * Tests if this Long's value is less than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThan = function lessThan(other) {
        return this.comp(/* validates */ other) < 0;
    };

    /**
     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lt = LongPrototype.lessThan;

    /**
     * Tests if this Long's value is less than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(/* validates */ other) <= 0;
    };

    /**
     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.lte = LongPrototype.lessThanOrEqual;

    /**
     * Tests if this Long's value is greater than the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(/* validates */ other) > 0;
    };

    /**
     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gt = LongPrototype.greaterThan;

    /**
     * Tests if this Long's value is greater than or equal the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(/* validates */ other) >= 0;
    };

    /**
     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {boolean}
     */
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;

    /**
     * Compares this Long's value with the specified's.
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.compare = function compare(other) {
        if (!isLong(other))
            other = fromValue(other);
        if (this.eq(other))
            return 0;
        var thisNeg = this.isNegative(),
            otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
            return -1;
        if (!thisNeg && otherNeg)
            return 1;
        // At this point the sign bits are the same
        if (!this.unsigned)
            return this.sub(other).isNegative() ? -1 : 1;
        // Both are positive if at least one is unsigned
        return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
    };

    /**
     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
     * @function
     * @param {!Long|number|string} other Other value
     * @returns {number} 0 if they are the same, 1 if the this is greater and -1
     *  if the given one is greater
     */
    LongPrototype.comp = LongPrototype.compare;

    /**
     * Negates this Long's value.
     * @returns {!Long} Negated Long
     */
    LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
            return MIN_VALUE;
        return this.not().add(ONE);
    };

    /**
     * Negates this Long's value. This is an alias of {@link Long#negate}.
     * @function
     * @returns {!Long} Negated Long
     */
    LongPrototype.neg = LongPrototype.negate;

    /**
     * Returns the sum of this and the specified Long.
     * @param {!Long|number|string} addend Addend
     * @returns {!Long} Sum
     */
    LongPrototype.add = function add(addend) {
        if (!isLong(addend))
            addend = fromValue(addend);

        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = addend.high >>> 16;
        var b32 = addend.high & 0xFFFF;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the difference of this and the specified Long.
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
            subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
    };

    /**
     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
     * @function
     * @param {!Long|number|string} subtrahend Subtrahend
     * @returns {!Long} Difference
     */
    LongPrototype.sub = LongPrototype.subtract;

    /**
     * Returns the product of this and the specified Long.
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
            return ZERO;
        if (!isLong(multiplier))
            multiplier = fromValue(multiplier);
        if (multiplier.isZero())
            return ZERO;
        if (this.eq(MIN_VALUE))
            return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE))
            return this.isOdd() ? MIN_VALUE : ZERO;

        if (this.isNegative()) {
            if (multiplier.isNegative())
                return this.neg().mul(multiplier.neg());
            else
                return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
            return this.mul(multiplier.neg()).neg();

        // If both longs are small, use float multiplication
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
            return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high >>> 16;
        var a32 = this.high & 0xFFFF;
        var a16 = this.low >>> 16;
        var a00 = this.low & 0xFFFF;

        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 0xFFFF;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
    };

    /**
     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
     * @function
     * @param {!Long|number|string} multiplier Multiplier
     * @returns {!Long} Product
     */
    LongPrototype.mul = LongPrototype.multiply;

    /**
     * Returns this Long divided by the specified. The result is signed if this Long is signed or
     *  unsigned if this Long is unsigned.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        if (divisor.isZero())
            throw Error('division by zero');
        if (this.isZero())
            return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
            // This section is only relevant for signed longs and is derived from the
            // closure library as a whole.
            if (this.eq(MIN_VALUE)) {
                if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                    return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
                else if (divisor.eq(MIN_VALUE))
                    return ONE;
                else {
                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                    var halfThis = this.shr(1);
                    approx = halfThis.div(divisor).shl(1);
                    if (approx.eq(ZERO)) {
                        return divisor.isNegative() ? ONE : NEG_ONE;
                    } else {
                        rem = this.sub(divisor.mul(approx));
                        res = approx.add(rem.div(divisor));
                        return res;
                    }
                }
            } else if (divisor.eq(MIN_VALUE))
                return this.unsigned ? UZERO : ZERO;
            if (this.isNegative()) {
                if (divisor.isNegative())
                    return this.neg().div(divisor.neg());
                return this.neg().div(divisor).neg();
            } else if (divisor.isNegative())
                return this.div(divisor.neg()).neg();
            res = ZERO;
        } else {
            // The algorithm below has not been made for unsigned longs. It's therefore
            // required to take special care of the MSB prior to running it.
            if (!divisor.unsigned)
                divisor = divisor.toUnsigned();
            if (divisor.gt(this))
                return UZERO;
            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true
                return UONE;
            res = UZERO;
        }

        // Repeat the following until the remainder is less than other:  find a
        // floating-point that approximates remainder / other *from below*, add this
        // into the result, and subtract it from the remainder.  It is critical that
        // the approximate value is less than or equal to the real value so that the
        // remainder never becomes negative.
        rem = this;
        while (rem.gte(divisor)) {
            // Approximate the result of division. This may be a little greater or
            // smaller than the actual value.
            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));

            // We will tweak the approximate result by changing it in the 48-th digit or
            // the smallest non-fractional digit, whichever is larger.
            var log2 = Math.ceil(Math.log(approx) / Math.LN2),
                delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),

            // Decrease the approximation until it is smaller than the remainder.  Note
            // that if it is too large, the product overflows and is negative.
                approxRes = fromNumber(approx),
                approxRem = approxRes.mul(divisor);
            while (approxRem.isNegative() || approxRem.gt(rem)) {
                approx -= delta;
                approxRes = fromNumber(approx, this.unsigned);
                approxRem = approxRes.mul(divisor);
            }

            // We know the answer can't be zero... and actually, zero would cause
            // infinite recursion since we would make no progress.
            if (approxRes.isZero())
                approxRes = ONE;

            res = res.add(approxRes);
            rem = rem.sub(approxRem);
        }
        return res;
    };

    /**
     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Quotient
     */
    LongPrototype.div = LongPrototype.divide;

    /**
     * Returns this Long modulo the specified.
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
            divisor = fromValue(divisor);
        return this.sub(this.div(divisor).mul(divisor));
    };

    /**
     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
     * @function
     * @param {!Long|number|string} divisor Divisor
     * @returns {!Long} Remainder
     */
    LongPrototype.mod = LongPrototype.modulo;

    /**
     * Returns the bitwise NOT of this Long.
     * @returns {!Long}
     */
    LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
    };

    /**
     * Returns the bitwise AND of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.and = function and(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };

    /**
     * Returns the bitwise OR of this Long and the specified.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.or = function or(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };

    /**
     * Returns the bitwise XOR of this Long and the given one.
     * @param {!Long|number|string} other Other Long
     * @returns {!Long}
     */
    LongPrototype.xor = function xor(other) {
        if (!isLong(other))
            other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);
        else
            return fromBits(0, this.low << (numBits - 32), this.unsigned);
    };

    /**
     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shl = LongPrototype.shiftLeft;

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
            return this;
        else if (numBits < 32)
            return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);
        else
            return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);
    };

    /**
     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shr = LongPrototype.shiftRight;

    /**
     * Returns this Long with bits logically shifted to the right by the given amount.
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
            numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
            return this;
        else {
            var high = this.high;
            if (numBits < 32) {
                var low = this.low;
                return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);
            } else if (numBits === 32)
                return fromBits(high, 0, this.unsigned);
            else
                return fromBits(high >>> (numBits - 32), 0, this.unsigned);
        }
    };

    /**
     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
     * @function
     * @param {number|!Long} numBits Number of bits
     * @returns {!Long} Shifted Long
     */
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;

    /**
     * Converts this Long to signed.
     * @returns {!Long} Signed long
     */
    LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
            return this;
        return fromBits(this.low, this.high, false);
    };

    /**
     * Converts this Long to unsigned.
     * @returns {!Long} Unsigned long
     */
    LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
            return this;
        return fromBits(this.low, this.high, true);
    };

    /**
     * Converts this Long to its byte representation.
     * @param {boolean=} le Whether little or big endian, defaults to big endian
     * @returns {!Array.<number>} Byte representation
     */
    LongPrototype.toBytes = function(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
    };

    /**
     * Converts this Long to its little endian byte representation.
     * @returns {!Array.<number>} Little endian byte representation
     */
    LongPrototype.toBytesLE = function() {
        var hi = this.high,
            lo = this.low;
        return [
             lo         & 0xff,
            (lo >>>  8) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>> 24) & 0xff,
             hi         & 0xff,
            (hi >>>  8) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>> 24) & 0xff
        ];
    };

    /**
     * Converts this Long to its big endian byte representation.
     * @returns {!Array.<number>} Big endian byte representation
     */
    LongPrototype.toBytesBE = function() {
        var hi = this.high,
            lo = this.low;
        return [
            (hi >>> 24) & 0xff,
            (hi >>> 16) & 0xff,
            (hi >>>  8) & 0xff,
             hi         & 0xff,
            (lo >>> 24) & 0xff,
            (lo >>> 16) & 0xff,
            (lo >>>  8) & 0xff,
             lo         & 0xff
        ];
    };

    return Long;
});
});

let int8 = new Int8Array(4);
let int32 = new Int32Array(int8.buffer, 0, 1);
let float32 = new Float32Array(int8.buffer, 0, 1);
const SHORT_MIN = -32768;
const SHORT_MAX = 32768;
function intBitsToFloat(bits) {
    int32[0] = bits;
    return float32[0];
}
function floatToIntBits(bits) {
    float32[0] = bits;
    return int32[0];
}
let int16 = new Int16Array(4);
let int64 = new Int32Array(int16.buffer, 0, 2);
let float64 = new Float64Array(int16.buffer, 0, 1);
function longBitsToDouble(bits) {
    int64[0] = bits.high;
    int64[1] = bits.low;
    return float64[0];
}
function doubleToLongBits(double) {
    float64[0] = double;
    return new long_1(int64[1], int64[0]);
}

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class Item {
    /**
     * Constructs a copy of the given item.
     *
     * @param index
     * index of the item to be constructed.
     * @param i
     * the item that must be copied into the item to be constructed.
     */
    constructor(index, i) {
        /**
         * Value of this item, for an integer item.
         */
        this.intVal = 0;
        /**
         * Value of this item, for a long item.
         */
        this.longVal = long_1.fromInt(0);
        /**
         * First part of the value of this item, for items that do not hold a
         * primitive value.
         */
        this.strVal1 = "";
        /**
         * Second part of the value of this item, for items that do not hold a
         * primitive value.
         */
        this.strVal2 = "";
        /**
         * Third part of the value of this item, for items that do not hold a
         * primitive value.
         */
        this.strVal3 = "";
        /**
         * Link to another constant pool item, used for collision lists in the
         * constant pool's hash table.
         */
        this.next = null;
        this.index = index;
        if (i) {
            this.index = index;
            this.type = i.type;
            this.intVal = i.intVal;
            this.longVal = i.longVal;
            this.strVal1 = i.strVal1;
            this.strVal2 = i.strVal2;
            this.strVal3 = i.strVal3;
            this.__hashCode = i.__hashCode;
        }
    }
    /**
     * Sets this item to an integer item.
     *
     * @param intVal
     * the value of this item.
     */
    set$int(intVal) {
        this.type = ClassWriter.INT;
        this.intVal = intVal;
        this.__hashCode = 2147483647 & (this.type + intVal);
    }
    /**
     * Sets this item to a long item.
     *
     * @param longVal
     * the value of this item.
     */
    set$long(longVal) {
        this.type = ClassWriter.LONG;
        this.longVal = longVal;
        this.__hashCode = 2147483647 & (this.type + (longVal.getLowBits()));
    }
    /**
     * Sets this item to a float item.
     *
     * @param floatVal
     * the value of this item.
     */
    set$float(floatVal) {
        this.type = ClassWriter.FLOAT;
        this.intVal = floatToIntBits(floatVal);
        this.__hashCode = 2147483647 & (this.type + (floatVal | 0));
    }
    /**
     * Sets this item to a double item.
     *
     * @param doubleVal
     * the value of this item.
     */
    set$double(doubleVal) {
        this.type = ClassWriter.DOUBLE;
        this.longVal = doubleToLongBits(doubleVal);
        this.__hashCode = 2147483647 & (this.type + (doubleVal | 0));
    }
    /**
     * Sets this item to an item that do not hold a primitive value.
     *
     * @param type
     * the type of this item.
     * @param strVal1
     * first part of the value of this item.
     * @param strVal2
     * second part of the value of this item.
     * @param strVal3
     * third part of the value of this item.
     */
    set(type, strVal1, strVal2, strVal3) {
        this.type = type;
        this.strVal1 = strVal1 !== null && strVal1 !== void 0 ? strVal1 : "";
        this.strVal2 = strVal2 !== null && strVal2 !== void 0 ? strVal2 : "";
        this.strVal3 = strVal3 !== null && strVal3 !== void 0 ? strVal3 : "";
        switch (type) {
            case ClassWriter.CLASS:
                this.intVal = 0; // intVal of a class must be zero, see visitInnerClass
            case ClassWriter.UTF8:
            case ClassWriter.STR:
            case ClassWriter.MTYPE:
            case ClassWriter.TYPE_NORMAL:
                this.__hashCode = 0x7FFFFFFF & (type + str_hash(this.strVal1));
                return;
            case ClassWriter.NAME_TYPE: {
                this.__hashCode = 0x7FFFFFFF & (type + str_hash(this.strVal1)
                    * str_hash(this.strVal2));
                return;
            }
            // ClassWriter.FIELD:
            // ClassWriter.METH:
            // ClassWriter.IMETH:
            // ClassWriter.HANDLE_BASE + 1..9
            default:
                this.__hashCode = 0x7FFFFFFF & (type + str_hash(this.strVal1)
                    * str_hash(this.strVal2) * str_hash(this.strVal3));
        }
    }
    /**
     * Sets the item to an InvokeDynamic item.
     *
     * @param name
     * invokedynamic's name.
     * @param desc
     * invokedynamic's desc.
     * @param bsmIndex
     * zero based index into the class attribute BootrapMethods.
     */
    setInvkDynItem(name, desc, bsmIndex) {
        this.type = ClassWriter.INDY;
        this.longVal = long_1.fromInt(bsmIndex);
        this.strVal1 = name;
        this.strVal2 = desc;
        this.__hashCode = 2147483647 & (ClassWriter.INDY + bsmIndex * this.strVal1.toString() * this.strVal2.toString());
    }
    /**
     * Sets the item to a BootstrapMethod item.
     *
     * @param position
     * position in byte in the class attribute BootrapMethods.
     * @param hashCode
     * hashcode of the item. This hashcode is processed from the
     * hashcode of the bootstrap method and the hashcode of all
     * bootstrap arguments.
     */
    setPosHash(position, hashCode) {
        this.type = ClassWriter.BSM;
        this.intVal = position;
        this.__hashCode = hashCode;
    }
    /**
     * Indicates if the given item is equal to this one. <i>This method assumes
     * that the two items have the same {@link #type}</i>.
     *
     * @param i
     * the item to be compared to this one. Both items must have the
     * same {@link #type}.
     * @return <tt>true</tt> if the given item if equal to this one,
     * <tt>false</tt> otherwise.
     */
    isEqualTo(i) {
        switch ((this.type)) {
            case ClassWriter.UTF8:
            case ClassWriter.STR:
            case ClassWriter.CLASS:
            case ClassWriter.MTYPE:
            case ClassWriter.TYPE_NORMAL:
                return (i.strVal1 === this.strVal1);
            case ClassWriter.TYPE_MERGED:
            case ClassWriter.LONG:
            case ClassWriter.DOUBLE:
                return i.longVal === this.longVal;
            case ClassWriter.INT:
            case ClassWriter.FLOAT:
                return i.intVal === this.intVal;
            case ClassWriter.TYPE_UNINIT:
                return i.intVal === this.intVal && (i.strVal1 === this.strVal1);
            case ClassWriter.NAME_TYPE:
                return (i.strVal1 === this.strVal1) && (i.strVal2 === this.strVal2);
            case ClassWriter.INDY:
                {
                    return i.longVal === this.longVal && (i.strVal1 === this.strVal1) && (i.strVal2 === this.strVal2);
                }
            default:
                return (i.strVal1 === this.strVal1) && (i.strVal2 === this.strVal2) && (i.strVal3 === this.strVal3);
        }
    }
}
function str_hash(str) {
    let hash = 0;
    if (str.length == 0) {
        return hash;
    }
    for (let i = 0; i < str.length; i++) {
        let char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}
// String.prototype["hashCode"] = function () {
//     let hash = 0;
//     if (this.length == 0) { return hash; }
//     for (let i = 0; i < this.length; i++) {
//         let char = this.charCodeAt(i);
//         hash = ((hash << 5) - hash) + char;
//         hash = hash & hash; // Convert to 32bit integer
//     }
//     return hash;
// }

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class MethodVisitor {
    /**
     * Constructs a new {@link MethodVisitor}.
     *
     * @param api
     * the ASM API version implemented by this visitor. Must be one
     * of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param mv
     * the method visitor to which this visitor must delegate method
     * calls. May be null.
     */
    constructor(api, mv = null) {
        this.api = 0;
        if (api !== Opcodes.ASM4 && api !== Opcodes.ASM5) {
            throw new Error();
        }
        this.api = api;
        this.mv = mv;
    }
    /**
     * Visits a parameter of this method.
     *
     * @param name
     * parameter name or null if none is provided.
     * @param access
     * the parameter's access flags, only <tt>ACC_FINAL</tt>,
     * <tt>ACC_SYNTHETIC</tt> or/and <tt>ACC_MANDATED</tt> are
     * allowed (see {@link Opcodes}).
     */
    visitParameter(name, access) {
        if (this.api < Opcodes.ASM5) {
            throw new Error();
        }
        if (this.mv != null) {
            this.mv.visitParameter(name, access);
        }
    }
    /**
     * Visits the default value of this annotation interface method.
     *
     * @return a visitor to the visit the actual default value of this
     * annotation interface method, or <tt>null</tt> if this visitor is
     * not interested in visiting this default value. The 'name'
     * parameters passed to the methods of this annotation visitor are
     * ignored. Moreover, exacly one visit method must be called on this
     * annotation visitor, followed by visitEnd.
     */
    visitAnnotationDefault() {
        if (this.mv != null) {
            return this.mv.visitAnnotationDefault();
        }
        return null;
    }
    /**
     * Visits an annotation of this method.
     *
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitAnnotation(desc, visible) {
        if (this.mv != null) {
            return this.mv.visitAnnotation(desc, visible);
        }
        return null;
    }
    /**
     * Visits an annotation on a type in the method signature.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#METHOD_TYPE_PARAMETER
     * METHOD_TYPE_PARAMETER},
     * {@link TypeReference#METHOD_TYPE_PARAMETER_BOUND
     * METHOD_TYPE_PARAMETER_BOUND},
     * {@link TypeReference#METHOD_RETURN METHOD_RETURN},
     * {@link TypeReference#METHOD_RECEIVER METHOD_RECEIVER},
     * {@link TypeReference#METHOD_FORMAL_PARAMETER
     * METHOD_FORMAL_PARAMETER} or {@link TypeReference#THROWS
     * THROWS}. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitTypeAnnotation(typeRef, typePath, desc, visible) {
        if (this.api < Opcodes.ASM5) {
            throw new Error();
        }
        if (this.mv != null) {
            return this.mv.visitTypeAnnotation(typeRef, typePath, desc, visible);
        }
        return null;
    }
    /**
     * Visits an annotation of a parameter this method.
     *
     * @param parameter
     * the parameter index.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitParameterAnnotation(parameter, desc, visible) {
        if (this.mv != null) {
            return this.mv.visitParameterAnnotation(parameter, desc, visible);
        }
        return null;
    }
    /**
     * Visits a non standard attribute of this method.
     *
     * @param attr
     * an attribute.
     */
    visitAttribute(attr) {
        if (this.mv != null) {
            this.mv.visitAttribute(attr);
        }
    }
    /**
     * Starts the visit of the method's code, if any (i.e. non abstract method).
     */
    visitCode() {
        if (this.mv != null) {
            this.mv.visitCode();
        }
    }
    /**
     * Visits the current state of the local variables and operand stack
     * elements. This method must(*) be called <i>just before</i> any
     * instruction <b>i</b> that follows an unconditional branch instruction
     * such as GOTO or THROW, that is the target of a jump instruction, or that
     * starts an exception handler block. The visited types must describe the
     * values of the local variables and of the operand stack elements <i>just
     * before</i> <b>i</b> is executed.<br>
     * <br>
     * (*) this is mandatory only for classes whose version is greater than or
     * equal to {@link Opcodes#V1_6 V1_6}. <br>
     * <br>
     * The frames of a method must be given either in expanded form, or in
     * compressed form (all frames must use the same format, i.e. you must not
     * mix expanded and compressed frames within a single method):
     * <ul>
     * <li>In expanded form, all frames must have the F_NEW type.</li>
     * <li>In compressed form, frames are basically "deltas" from the state of
     * the previous frame:
     * <ul>
     * <li>{@link Opcodes#F_SAME} representing frame with exactly the same
     * locals as the previous frame and with the empty stack.</li>
     * <li>{@link Opcodes#F_SAME1} representing frame with exactly the same
     * locals as the previous frame and with single value on the stack (
     * <code>nStack</code> is 1 and <code>stack[0]</code> contains value for the
     * type of the stack item).</li>
     * <li>{@link Opcodes#F_APPEND} representing frame with current locals are
     * the same as the locals in the previous frame, except that additional
     * locals are defined (<code>nLocal</code> is 1, 2 or 3 and
     * <code>local</code> elements contains values representing added types).</li>
     * <li>{@link Opcodes#F_CHOP} representing frame with current locals are the
     * same as the locals in the previous frame, except that the last 1-3 locals
     * are absent and with the empty stack (<code>nLocals</code> is 1, 2 or 3).</li>
     * <li>{@link Opcodes#F_FULL} representing complete frame data.</li>
     * </ul>
     * </li>
     * </ul>
     * <br>
     * In both cases the first frame, corresponding to the method's parameters
     * and access flags, is implicit and must not be visited. Also, it is
     * illegal to visit two or more frames for the same code location (i.e., at
     * least one instruction must be visited between two calls to visitFrame).
     *
     * @param type
     * the type of this stack map frame. Must be
     * {@link Opcodes#F_NEW} for expanded frames, or
     * {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},
     * {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or
     * {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for
     * compressed frames.
     * @param nLocal
     * the number of local variables in the visited frame.
     * @param local
     * the local variable types in this frame. This array must not be
     * modified. Primitive types are represented by
     * {@link Opcodes#TOP}, {@link Opcodes#INTEGER},
     * {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
     * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
     * {@link Opcodes#UNINITIALIZED_THIS} (long and double are
     * represented by a single element). Reference types are
     * represented by String objects (representing internal names),
     * and uninitialized types by Label objects (this label
     * designates the NEW instruction that created this uninitialized
     * value).
     * @param nStack
     * the number of operand stack elements in the visited frame.
     * @param stack
     * the operand stack types in this frame. This array must not be
     * modified. Its content has the same format as the "local"
     * array.
     * @throws IllegalStateException
     * if a frame is visited just after another one, without any
     * instruction between the two (unless this frame is a
     * Opcodes#F_SAME frame, in which case it is silently ignored).
     */
    visitFrame(type, nLocal, local, nStack, stack) {
        if (((typeof type === "number") || type === null) && ((typeof nLocal === "number") || nLocal === null) && ((local != null && local instanceof Array) || local === null) && ((typeof nStack === "number") || nStack === null) && ((stack != null && stack instanceof Array) || stack === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                if (this.mv != null) {
                    this.mv.visitFrame(type, nLocal, local, nStack, stack);
                }
            })();
        }
        else {
            throw new Error("invalid overload");
        }
    }
    /**
     * Visits a zero operand instruction.
     *
     * @param opcode
     * the opcode of the instruction to be visited. This opcode is
     * either NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1,
     * ICONST_2, ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1,
     * FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD,
     * LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD,
     * IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE,
     * SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1,
     * DUP2_X2, SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB,
     * IMUL, LMUL, FMUL, DMUL, IDIV, LDIV, FDIV, DDIV, IREM, LREM,
     * FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR,
     * IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D,
     * L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B, I2C, I2S,
     * LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,
     * DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER,
     * or MONITOREXIT.
     */
    visitInsn(opcode) {
        if (this.mv != null) {
            this.mv.visitInsn(opcode);
        }
    }
    /**
     * Visits an instruction with a single int operand.
     *
     * @param opcode
     * the opcode of the instruction to be visited. This opcode is
     * either BIPUSH, SIPUSH or NEWARRAY.
     * @param operand
     * the operand of the instruction to be visited.<br>
     * When opcode is BIPUSH, operand value should be between
     * Byte.MIN_VALUE and Byte.MAX_VALUE.<br>
     * When opcode is SIPUSH, operand value should be between
     * Short.MIN_VALUE and Short.MAX_VALUE.<br>
     * When opcode is NEWARRAY, operand value should be one of
     * {@link Opcodes#T_BOOLEAN}, {@link Opcodes#T_CHAR},
     * {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE},
     * {@link Opcodes#T_BYTE}, {@link Opcodes#T_SHORT},
     * {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
     */
    visitIntInsn(opcode, operand) {
        if (this.mv != null) {
            this.mv.visitIntInsn(opcode, operand);
        }
    }
    /**
     * Visits a local variable instruction. A local variable instruction is an
     * instruction that loads or stores the value of a local variable.
     *
     * @param opcode
     * the opcode of the local variable instruction to be visited.
     * This opcode is either ILOAD, LLOAD, FLOAD, DLOAD, ALOAD,
     * ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
     * @param var
     * the operand of the instruction to be visited. This operand is
     * the index of a local variable.
     */
    visitVarInsn(opcode, __var) {
        if (this.mv != null) {
            this.mv.visitVarInsn(opcode, __var);
        }
    }
    /**
     * Visits a type instruction. A type instruction is an instruction that
     * takes the internal name of a class as parameter.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.
     * @param type
     * the operand of the instruction to be visited. This operand
     * must be the internal name of an object or array class (see
     * {@link Type#getInternalName() getInternalName}).
     */
    visitTypeInsn(opcode, type) {
        if (this.mv != null) {
            this.mv.visitTypeInsn(opcode, type);
        }
    }
    /**
     * Visits a field instruction. A field instruction is an instruction that
     * loads or stores the value of a field of an object.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
     * @param owner
     * the internal name of the field's owner class (see
     * {@link Type#getInternalName() getInternalName}).
     * @param name
     * the field's name.
     * @param desc
     * the field's descriptor (see {@link Type Type}).
     */
    visitFieldInsn(opcode, owner, name, desc) {
        if (this.mv != null) {
            this.mv.visitFieldInsn(opcode, owner, name, desc);
        }
    }
    /**
     * Visits a method instruction. A method instruction is an instruction that
     * invokes a method.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or
     * INVOKEINTERFACE.
     * @param owner
     * the internal name of the method's owner class (see
     * {@link Type#getInternalName() getInternalName}).
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor (see {@link Type Type}).
     */
    visitMethodInsn$int$java_lang_String$java_lang_String$java_lang_String(opcode, owner, name, desc) {
        if (this.api >= Opcodes.ASM5) {
            let itf = opcode === Opcodes.INVOKEINTERFACE;
            this.visitMethodInsn(opcode, owner, name, desc, itf);
            return;
        }
        if (this.mv != null) {
            this.mv.visitMethodInsn(opcode, owner, name, desc);
        }
    }
    /**
     * Visits a method instruction. A method instruction is an instruction that
     * invokes a method.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or
     * INVOKEINTERFACE.
     * @param owner
     * the internal name of the method's owner class (see
     * {@link Type#getInternalName() getInternalName}).
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor (see {@link Type Type}).
     * @param itf
     * if the method's owner class is an interface.
     */
    visitMethodInsn(opcode, owner, name, desc, itf) {
        if (((typeof opcode === "number") || opcode === null) && ((typeof owner === "string") || owner === null) && ((typeof name === "string") || name === null) && ((typeof desc === "string") || desc === null) && ((typeof itf === "boolean") || itf === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                if (this.api < Opcodes.ASM5) {
                    if (itf !== (opcode === Opcodes.INVOKEINTERFACE)) {
                        throw new Error("INVOKESPECIAL/STATIC on interfaces require ASM 5");
                    }
                    this.visitMethodInsn(opcode, owner, name, desc);
                    return;
                }
                if (this.mv != null) {
                    this.mv.visitMethodInsn(opcode, owner, name, desc, itf);
                }
            })();
        }
        else if (((typeof opcode === "number") || opcode === null) && ((typeof owner === "string") || owner === null) && ((typeof name === "string") || name === null) && ((typeof desc === "string") || desc === null) && itf === undefined) {
            return this.visitMethodInsn$int$java_lang_String$java_lang_String$java_lang_String(opcode, owner, name, desc);
        }
        else {
            throw new Error("invalid overload");
        }
    }
    /**
     * Visits an invokedynamic instruction.
     *
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor (see {@link Type Type}).
     * @param bsm
     * the bootstrap method.
     * @param bsmArgs
     * the bootstrap method constant arguments. Each argument must be
     * an {@link Integer}, {@link Float}, {@link Long},
     * {@link Double}, {@link String}, {@link Type} or {@link Handle}
     * value. This method is allowed to modify the content of the
     * array so a caller should expect that this array may change.
     */
    visitInvokeDynamicInsn(name, desc, bsm, ...bsmArgs) {
        if (this.mv != null) {
            this.mv.visitInvokeDynamicInsn(name, desc, bsm, ...bsmArgs);
        }
    }
    /**
     * Visits a jump instruction. A jump instruction is an instruction that may
     * jump to another instruction.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ,
     * IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE,
     * IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
     * @param label
     * the operand of the instruction to be visited. This operand is
     * a label that designates the instruction to which the jump
     * instruction may jump.
     */
    visitJumpInsn(opcode, label) {
        if (this.mv != null) {
            this.mv.visitJumpInsn(opcode, label);
        }
    }
    /**
     * Visits a label. A label designates the instruction that will be visited
     * just after it.
     *
     * @param label
     * a {@link Label Label} object.
     */
    visitLabel(label) {
        if (this.mv != null) {
            this.mv.visitLabel(label);
        }
    }
    /**
     * Visits a LDC instruction. Note that new constant types may be added in
     * future versions of the Java Virtual Machine. To easily detect new
     * constant types, implementations of this method should check for
     * unexpected constant types, like this:
     *
     * <pre>
     * if (cst instanceof Integer) {
     * // ...
     * } else if (cst instanceof Float) {
     * // ...
     * } else if (cst instanceof Long) {
     * // ...
     * } else if (cst instanceof Double) {
     * // ...
     * } else if (cst instanceof String) {
     * // ...
     * } else if (cst instanceof Type) {
     * int sort = ((Type) cst).getSort();
     * if (sort == Type.OBJECT) {
     * // ...
     * } else if (sort == Type.ARRAY) {
     * // ...
     * } else if (sort == Type.METHOD) {
     * // ...
     * } else {
     * // throw an exception
     * }
     * } else if (cst instanceof Handle) {
     * // ...
     * } else {
     * // throw an exception
     * }
     * </pre>
     *
     * @param cst
     * the constant to be loaded on the stack. This parameter must be
     * a non null {@link Integer}, a {@link Float}, a {@link Long}, a
     * {@link Double}, a {@link String}, a {@link Type} of OBJECT or
     * ARRAY sort for <tt>.class</tt> constants, for classes whose
     * version is 49.0, a {@link Type} of METHOD sort or a
     * {@link Handle} for MethodType and MethodHandle constants, for
     * classes whose version is 51.0.
     */
    visitLdcInsn(cst) {
        if (this.mv != null) {
            this.mv.visitLdcInsn(cst);
        }
    }
    /**
     * Visits an IINC instruction.
     *
     * @param var
     * index of the local variable to be incremented.
     * @param increment
     * amount to increment the local variable by.
     */
    visitIincInsn(__var, increment) {
        if (this.mv != null) {
            this.mv.visitIincInsn(__var, increment);
        }
    }
    /**
     * Visits a TABLESWITCH instruction.
     *
     * @param min
     * the minimum key value.
     * @param max
     * the maximum key value.
     * @param dflt
     * beginning of the default handler block.
     * @param labels
     * beginnings of the handler blocks. <tt>labels[i]</tt> is the
     * beginning of the handler block for the <tt>min + i</tt> key.
     */
    visitTableSwitchInsn(min, max, dflt, ...labels) {
        if (this.mv != null) {
            this.mv.visitTableSwitchInsn(min, max, dflt, ...labels);
        }
    }
    /**
     * Visits a LOOKUPSWITCH instruction.
     *
     * @param dflt
     * beginning of the default handler block.
     * @param keys
     * the values of the keys.
     * @param labels
     * beginnings of the handler blocks. <tt>labels[i]</tt> is the
     * beginning of the handler block for the <tt>keys[i]</tt> key.
     */
    visitLookupSwitchInsn(dflt, keys, labels) {
        if (this.mv != null) {
            this.mv.visitLookupSwitchInsn(dflt, keys, labels);
        }
    }
    /**
     * Visits a MULTIANEWARRAY instruction.
     *
     * @param desc
     * an array type descriptor (see {@link Type Type}).
     * @param dims
     * number of dimensions of the array to allocate.
     */
    visitMultiANewArrayInsn(desc, dims) {
        if (this.mv != null) {
            this.mv.visitMultiANewArrayInsn(desc, dims);
        }
    }
    /**
     * Visits an annotation on an instruction. This method must be called just
     * <i>after</i> the annotated instruction. It can be called several times
     * for the same instruction.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#INSTANCEOF INSTANCEOF},
     * {@link TypeReference#NEW NEW},
     * {@link TypeReference#CONSTRUCTOR_REFERENCE
     * CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE
     * METHOD_REFERENCE}, {@link TypeReference#CAST CAST},
     * {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
     * CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT},
     * {@link TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT
     * METHOD_INVOCATION_TYPE_ARGUMENT},
     * {@link TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
     * CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or
     * {@link TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT
     * METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitInsnAnnotation(typeRef, typePath, desc, visible) {
        if (this.api < Opcodes.ASM5) {
            throw new Error();
        }
        if (this.mv != null) {
            return this.mv.visitInsnAnnotation(typeRef, typePath, desc, visible);
        }
        return null;
    }
    /**
     * Visits a try catch block.
     *
     * @param start
     * beginning of the exception handler's scope (inclusive).
     * @param end
     * end of the exception handler's scope (exclusive).
     * @param handler
     * beginning of the exception handler's code.
     * @param type
     * internal name of the type of exceptions handled by the
     * handler, or <tt>null</tt> to catch any exceptions (for
     * "finally" blocks).
     * @throws IllegalArgumentException
     * if one of the labels has already been visited by this visitor
     * (by the {@link #visitLabel visitLabel} method).
     */
    visitTryCatchBlock(start, end, handler, type) {
        if (this.mv != null) {
            this.mv.visitTryCatchBlock(start, end, handler, type);
        }
    }
    /**
     * Visits an annotation on an exception handler type. This method must be
     * called <i>after</i> the {@link #visitTryCatchBlock} for the annotated
     * exception handler. It can be called several times for the same exception
     * handler.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#EXCEPTION_PARAMETER
     * EXCEPTION_PARAMETER}. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitTryCatchAnnotation(typeRef, typePath, desc, visible) {
        if (this.api < Opcodes.ASM5) {
            throw new Error();
        }
        if (this.mv != null) {
            return this.mv.visitTryCatchAnnotation(typeRef, typePath, desc, visible);
        }
        return null;
    }
    /**
     * Visits a local variable declaration.
     *
     * @param name
     * the name of a local variable.
     * @param desc
     * the type descriptor of this local variable.
     * @param signature
     * the type signature of this local variable. May be
     * <tt>null</tt> if the local variable type does not use generic
     * types.
     * @param start
     * the first instruction corresponding to the scope of this local
     * variable (inclusive).
     * @param end
     * the last instruction corresponding to the scope of this local
     * variable (exclusive).
     * @param index
     * the local variable's index.
     * @throws IllegalArgumentException
     * if one of the labels has not already been visited by this
     * visitor (by the {@link #visitLabel visitLabel} method).
     */
    visitLocalVariable(name, desc, signature, start, end, index) {
        if (this.mv != null) {
            this.mv.visitLocalVariable(name, desc, signature, start, end, index);
        }
    }
    /**
     * Visits an annotation on a local variable type.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#LOCAL_VARIABLE
     * LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE
     * RESOURCE_VARIABLE}. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param start
     * the fist instructions corresponding to the continuous ranges
     * that make the scope of this local variable (inclusive).
     * @param end
     * the last instructions corresponding to the continuous ranges
     * that make the scope of this local variable (exclusive). This
     * array must have the same size as the 'start' array.
     * @param index
     * the local variable's index in each range. This array must have
     * the same size as the 'start' array.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible) {
        if (this.api < Opcodes.ASM5) {
            throw new Error();
        }
        if (this.mv != null) {
            return this.mv.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible);
        }
        return null;
    }
    /**
     * Visits a line number declaration.
     *
     * @param line
     * a line number. This number refers to the source file from
     * which the class was compiled.
     * @param start
     * the first instruction corresponding to this line number.
     * @throws IllegalArgumentException
     * if <tt>start</tt> has not already been visited by this
     * visitor (by the {@link #visitLabel visitLabel} method).
     */
    visitLineNumber(line, start) {
        if (this.mv != null) {
            this.mv.visitLineNumber(line, start);
        }
    }
    /**
     * Visits the maximum stack size and the maximum number of local variables
     * of the method.
     *
     * @param maxStack
     * maximum stack size of the method.
     * @param maxLocals
     * maximum number of local variables for the method.
     */
    visitMaxs(maxStack, maxLocals) {
        if (this.mv != null) {
            this.mv.visitMaxs(maxStack, maxLocals);
        }
    }
    /**
     * Visits the end of the method. This method, which is the last one to be
     * called, is used to inform the visitor that all the annotations and
     * attributes of the method have been visited.
     */
    visitEnd() {
        if (this.mv != null) {
            this.mv.visitEnd();
        }
    }
}

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class Frame {
    constructor(owner) {
        /**
         * The input stack map frame locals.
         */
        this.inputLocals = [];
        /**
         * The input stack map frame stack.
         */
        this.inputStack = [];
        /**
         * The output stack map frame locals.
         */
        this.outputLocals = [];
        /**
         * The output stack map frame stack.
         */
        this.outputStack = [];
        /**
         * The types that are initialized in the basic block. A constructor
         * invocation on an UNINITIALIZED or UNINITIALIZED_THIS type must replace
         * <i>every occurence</i> of this type in the local variables and in the
         * operand stack. This cannot be done during the first phase of the
         * algorithm since, during this phase, the local variables and the operand
         * stack are not completely computed. It is therefore necessary to store the
         * types on which constructors are invoked in the basic block, in order to
         * do this replacement during the second phase of the algorithm, where the
         * frames are fully computed. Note that this array can contain types that
         * are relative to input locals or to the input stack (see below for the
         * description of the algorithm).
         */
        this.initializations = null;
        this.outputStackTop = 0;
        this.initializationCount = 0;
        this.owner = owner;
    }
    static __static_initialize() { if (!Frame.__static_initialized) {
        Frame.__static_initialized = true;
        Frame.__static_initializer_0();
    } }
    static OBJECT_$LI$() { Frame.__static_initialize(); if (Frame.OBJECT == null) {
        Frame.OBJECT = Frame.BASE | 7340032;
    } return Frame.OBJECT; }
    ;
    static UNINITIALIZED_$LI$() { Frame.__static_initialize(); if (Frame.UNINITIALIZED == null) {
        Frame.UNINITIALIZED = Frame.BASE | 8388608;
    } return Frame.UNINITIALIZED; }
    ;
    static TOP_$LI$() { Frame.__static_initialize(); if (Frame.TOP == null) {
        Frame.TOP = Frame.BASE | 0;
    } return Frame.TOP; }
    ;
    static BOOLEAN_$LI$() { Frame.__static_initialize(); if (Frame.BOOLEAN == null) {
        Frame.BOOLEAN = Frame.BASE | 9;
    } return Frame.BOOLEAN; }
    ;
    static BYTE_$LI$() { Frame.__static_initialize(); if (Frame.BYTE == null) {
        Frame.BYTE = Frame.BASE | 10;
    } return Frame.BYTE; }
    ;
    static CHAR_$LI$() { Frame.__static_initialize(); if (Frame.CHAR == null) {
        Frame.CHAR = Frame.BASE | 11;
    } return Frame.CHAR; }
    ;
    static SHORT_$LI$() { Frame.__static_initialize(); if (Frame.SHORT == null) {
        Frame.SHORT = Frame.BASE | 12;
    } return Frame.SHORT; }
    ;
    static INTEGER_$LI$() { Frame.__static_initialize(); if (Frame.INTEGER == null) {
        Frame.INTEGER = Frame.BASE | 1;
    } return Frame.INTEGER; }
    ;
    static FLOAT_$LI$() { Frame.__static_initialize(); if (Frame.FLOAT == null) {
        Frame.FLOAT = Frame.BASE | 2;
    } return Frame.FLOAT; }
    ;
    static DOUBLE_$LI$() { Frame.__static_initialize(); if (Frame.DOUBLE == null) {
        Frame.DOUBLE = Frame.BASE | 3;
    } return Frame.DOUBLE; }
    ;
    static LONG_$LI$() { Frame.__static_initialize(); if (Frame.LONG == null) {
        Frame.LONG = Frame.BASE | 4;
    } return Frame.LONG; }
    ;
    static NULL_$LI$() { Frame.__static_initialize(); if (Frame.NULL == null) {
        Frame.NULL = Frame.BASE | 5;
    } return Frame.NULL; }
    ;
    static UNINITIALIZED_THIS_$LI$() {
        Frame.__static_initialize();
        if (Frame.UNINITIALIZED_THIS == null) {
            Frame.UNINITIALIZED_THIS = Frame.BASE | 6;
        }
        return Frame.UNINITIALIZED_THIS;
    }
    ;
    static SIZE_$LI$() {
        Frame.__static_initialize();
        return Frame.SIZE;
    }
    ;
    static __static_initializer_0() {
        let i;
        let b = new Array(202);
        let s = "EFFFFFFFFGGFFFGGFFFEEFGFGFEEEEEEEEEEEEEEEEEEEEDEDEDDDDDCDCDEEEEEEEEEEEEEEEEEEEEBABABBBBDCFFFGGGEDCDCDCDCDCDCDCDCDCDCEEEEDDDDDDDCDCDCEFEFDDEEFFDEDEEEBDDBBDDDDDDCCCCCCCCEFEDDDCDCDEEEEEEEEEEFEEEEEEDDEEDDEE";
        for (i = 0; i < b.length; ++i) {
            b[i] = (s.charAt(i)).charCodeAt(0) - ("E").charCodeAt(0);
        }
        Frame.SIZE = b;
    }
    /**
     * Sets this frame to the given value.
     *
     * @param cw
     * the ClassWriter to which this label belongs.
     * @param nLocal
     * the number of local variables.
     * @param local
     * the local variable types. Primitive types are represented by
     * {@link Opcodes#TOP}, {@link Opcodes#INTEGER},
     * {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
     * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
     * {@link Opcodes#UNINITIALIZED_THIS} (long and double are
     * represented by a single element). Reference types are
     * represented by String objects (representing internal names),
     * and uninitialized types by Label objects (this label
     * designates the NEW instruction that created this uninitialized
     * value).
     * @param nStack
     * the number of operand stack elements.
     * @param stack
     * the operand stack types (same format as the "local" array).
     */
    set(cw, nLocal, local, nStack, stack) {
        if (((cw != null && cw instanceof ClassWriter) || cw === null) && ((typeof nLocal === "number") || nLocal === null) && ((local != null && local instanceof Array) || local === null) && ((typeof nStack === "number") || nStack === null) && ((stack != null && stack instanceof Array) || stack === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                let i = Frame.convert(cw, nLocal, local, this.inputLocals);
                while ((i < local.length)) {
                    this.inputLocals[i++] = Frame.TOP_$LI$();
                }
                let nStackTop = 0;
                for (let j = 0; j < nStack; ++j) {
                    if (stack[j] === Opcodes.LONG || stack[j] === Opcodes.DOUBLE) {
                        ++nStackTop;
                    }
                }
                this.inputStack = new Array(nStack + nStackTop);
                Frame.convert(cw, nStack, stack, this.inputStack);
                this.outputStackTop = 0;
                this.initializationCount = 0;
            })();
        }
        else if (((typeof cw === "number") || cw === null) && ((typeof nLocal === "number") || nLocal === null) && local === undefined && nStack === undefined && stack === undefined) {
            return this.set$int$int(cw, nLocal);
        }
        else if (((cw != null && cw instanceof Frame) || cw === null) && nLocal === undefined && local === undefined && nStack === undefined && stack === undefined) {
            return this.set$Frame(cw);
        }
        else {
            throw new Error("invalid overload");
        }
    }
    /**
     * Converts types from the MethodWriter.visitFrame() format to the Frame
     * format.
     *
     * @param cw
     * the ClassWriter to which this label belongs.
     * @param nInput
     * the number of types to convert.
     * @param input
     * the types to convert. Primitive types are represented by
     * {@link Opcodes#TOP}, {@link Opcodes#INTEGER},
     * {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
     * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
     * {@link Opcodes#UNINITIALIZED_THIS} (long and double are
     * represented by a single element). Reference types are
     * represented by String objects (representing internal names),
     * and uninitialized types by Label objects (this label
     * designates the NEW instruction that created this uninitialized
     * value).
     * @param output
     * where to store the converted types.
     * @return the number of output elements.
     */
    static convert(cw, nInput, input, output) {
        let i = 0;
        for (let j = 0; j < nInput; ++j) {
            if (typeof input[j] === "number") {
                output[i++] = Frame.BASE | /* intValue */ (input[j] | 0);
                if (input[j] === Opcodes.LONG || input[j] === Opcodes.DOUBLE) {
                    output[i++] = Frame.TOP_$LI$();
                }
            }
            else if (typeof input[j] === "string") {
                output[i++] = Frame.type(cw, Type.getObjectType(input[j]).getDescriptor());
            }
            else {
                output[i++] = Frame.UNINITIALIZED_$LI$() | cw.addUninitializedType("", input[j].position);
            }
        }
        return i;
    }
    /**
     * Sets this frame to the value of the given frame. WARNING: after this
     * method is called the two frames share the same data structures. It is
     * recommended to discard the given frame f to avoid unexpected side
     * effects.
     *
     * @param f
     * The new frame value.
     */
    set$Frame(f) {
        this.inputLocals = f.inputLocals;
        this.inputStack = f.inputStack;
        this.outputLocals = f.outputLocals;
        this.outputStack = f.outputStack;
        this.outputStackTop = f.outputStackTop;
        this.initializationCount = f.initializationCount;
        this.initializations = f.initializations;
    }
    /**
     * Returns the output frame local variable type at the given index.
     *
     * @param local
     * the index of the local that must be returned.
     * @return the output frame local variable type at the given index.
     */
    get(local) {
        if (this.outputLocals == null || local >= this.outputLocals.length) {
            return Frame.LOCAL | local;
        }
        else {
            let type = this.outputLocals[local];
            if (type === 0) {
                type = this.outputLocals[local] = Frame.LOCAL | local;
            }
            return type;
        }
    }
    /**
     * Sets the output frame local variable type at the given index.
     *
     * @param local
     * the index of the local that must be set.
     * @param type
     * the value of the local that must be set.
     */
    set$int$int(local, type) {
        if (this.outputLocals == null) {
            this.outputLocals = new Array(10);
        }
        let n = this.outputLocals.length;
        if (local >= n) {
            let t = new Array(Math.max(local + 1, 2 * n));
            for (let i = 0; i < n; i++) {
                t[i] = this.outputLocals[i];
            }
            // java.lang.System.arraycopy(this.outputLocals, 0, t, 0, n);
            this.outputLocals = t;
        }
        this.outputLocals[local] = type;
    }
    /**
     * Pushes a new type onto the output frame stack.
     *
     * @param type
     * the type that must be pushed.
     */
    push$int(type) {
        if (this.outputStack == null) {
            this.outputStack = new Array(10);
        }
        let n = this.outputStack.length;
        if (this.outputStackTop >= n) {
            let t = new Array(Math.max(this.outputStackTop + 1, 2 * n));
            for (let i = 0; i < n; i++) {
                t[i] = this.outputStack[i];
            }
            // java.lang.System.arraycopy(this.outputStack, 0, t, 0, n);
            this.outputStack = t;
        }
        this.outputStack[this.outputStackTop++] = type;
        assert(this.owner);
        let top = this.owner.inputStackTop + this.outputStackTop;
        if (top > this.owner.outputStackMax) {
            this.owner.outputStackMax = top;
        }
    }
    /**
     * Pushes a new type onto the output frame stack.
     *
     * @param cw
     * the ClassWriter to which this label belongs.
     * @param desc
     * the descriptor of the type to be pushed. Can also be a method
     * descriptor (in this case this method pushes its return type
     * onto the output frame stack).
     */
    push(cw, desc) {
        if (((cw != null && cw instanceof ClassWriter) || cw === null) && ((typeof desc === "string") || desc === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                let type = Frame.type(cw, desc);
                if (type !== 0) {
                    this.push(type);
                    if (type === Frame.LONG_$LI$() || type === Frame.DOUBLE_$LI$()) {
                        this.push(Frame.TOP_$LI$());
                    }
                }
            })();
        }
        else if (((typeof cw === "number") || cw === null) && desc === undefined) {
            return this.push$int(cw);
        }
        else {
            throw new Error("invalid overload");
        }
    }
    /**
     * Returns the int encoding of the given type.
     *
     * @param cw
     * the ClassWriter to which this label belongs.
     * @param desc
     * a type descriptor.
     * @return the int encoding of the given type.
     */
    static type(cw, desc) {
        let t;
        let index = desc.charAt(0) === "(" ? desc.indexOf(")") + 1 : 0;
        switch ((desc.charAt(index))) {
            case "V":
                return 0;
            case "Z":
            case "C":
            case "B":
            case "S":
            case "I":
                return Frame.INTEGER_$LI$();
            case "F":
                return Frame.FLOAT_$LI$();
            case "J":
                return Frame.LONG_$LI$();
            case "D":
                return Frame.DOUBLE_$LI$();
            case "L":
                t = desc.substring(index + 1, desc.length - 1);
                return Frame.OBJECT_$LI$() | cw.addType(t);
            default:
                let data;
                let dims = index + 1;
                while ((desc.charAt(dims) === "[")) {
                    ++dims;
                }
                switch ((desc.charAt(dims))) {
                    case "Z":
                        data = Frame.BOOLEAN_$LI$();
                        break;
                    case "C":
                        data = Frame.CHAR_$LI$();
                        break;
                    case "B":
                        data = Frame.BYTE_$LI$();
                        break;
                    case "S":
                        data = Frame.SHORT_$LI$();
                        break;
                    case "I":
                        data = Frame.INTEGER_$LI$();
                        break;
                    case "F":
                        data = Frame.FLOAT_$LI$();
                        break;
                    case "J":
                        data = Frame.LONG_$LI$();
                        break;
                    case "D":
                        data = Frame.DOUBLE_$LI$();
                        break;
                    default:
                        t = desc.substring(dims + 1, desc.length - 1);
                        data = Frame.OBJECT_$LI$() | cw.addType(t);
                }
                return (dims - index) << 28 | data;
        }
    }
    /**
     * Pops a type from the output frame stack and returns its value.
     *
     * @return the type that has been popped from the output frame stack.
     */
    pop$() {
        if (this.outputStackTop > 0) {
            return this.outputStack[--this.outputStackTop];
        }
        else {
            return Frame.STACK | -(--this.owner.inputStackTop);
        }
    }
    /**
     * Pops the given number of types from the output frame stack.
     *
     * @param elements
     * the number of types that must be popped.
     */
    pop$int(elements) {
        if (this.outputStackTop >= elements) {
            this.outputStackTop -= elements;
        }
        else {
            this.owner.inputStackTop -= elements - this.outputStackTop;
            this.outputStackTop = 0;
        }
    }
    /**
     * Pops a type from the output frame stack.
     *
     * @param desc
     * the descriptor of the type to be popped. Can also be a method
     * descriptor (in this case this method pops the types
     * corresponding to the method arguments).
     */
    pop(desc) {
        if (((typeof desc === "string") || desc === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                let c = desc.charAt(0);
                if (c === "(") {
                    this.pop((Type.getArgumentsAndReturnSizes(desc) >> 2) - 1);
                }
                else if (c === "J" || c === "D") {
                    this.pop(2);
                }
                else {
                    this.pop(1);
                }
            })();
        }
        else if (((typeof desc === "number") || desc === null)) {
            return this.pop$int(desc);
        }
        else if (desc === undefined) {
            return this.pop$();
        }
        else {
            throw new Error("invalid overload");
        }
    }
    /**
     * Adds a new type to the list of types on which a constructor is invoked in
     * the basic block.
     *
     * @param var
     * a type on a which a constructor is invoked.
     */
    init$int(__var) {
        if (this.initializations == null) {
            this.initializations = new Array(2);
        }
        let n = this.initializations.length;
        if (this.initializationCount >= n) {
            let t = new Array(Math.max(this.initializationCount + 1, 2 * n));
            for (let i = 0; i < n; i++) {
                t[i] = this.initializations[i];
            }
            // java.lang.System.arraycopy(this.initializations, 0, t, 0, n);
            this.initializations = t;
        }
        this.initializations[this.initializationCount++] = __var;
    }
    /**
     * Replaces the given type with the appropriate type if it is one of the
     * types on which a constructor is invoked in the basic block.
     *
     * @param cw
     * the ClassWriter to which this label belongs.
     * @param t
     * a type
     * @return t or, if t is one of the types on which a constructor is invoked
     * in the basic block, the type corresponding to this constructor.
     */
    init(cw, t) {
        if (((cw != null && cw instanceof ClassWriter) || cw === null) && ((typeof t === "number") || t === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                let s;
                if (t === Frame.UNINITIALIZED_THIS_$LI$()) {
                    s = Frame.OBJECT_$LI$() | cw.addType(cw.thisName);
                }
                else if ((t & (Frame.DIM | Frame.BASE_KIND)) === Frame.UNINITIALIZED_$LI$()) {
                    let type = cw.typeTable[t & Frame.BASE_VALUE].strVal1;
                    s = Frame.OBJECT_$LI$() | cw.addType(type);
                }
                else {
                    return t;
                }
                for (let j = 0; j < this.initializationCount; ++j) {
                    let u = this.initializations[j];
                    let dim = u & Frame.DIM;
                    let kind = u & Frame.KIND;
                    if (kind === Frame.LOCAL) {
                        u = dim + this.inputLocals[u & Frame.VALUE];
                    }
                    else if (kind === Frame.STACK) {
                        u = dim + this.inputStack[this.inputStack.length - (u & Frame.VALUE)];
                    }
                    if (t === u) {
                        return s;
                    }
                }
                return t;
            })();
        }
        else if (((typeof cw === "number") || cw === null) && t === undefined) {
            return this.init$int(cw);
        }
        else {
            throw new Error("invalid overload");
        }
    }
    /**
     * Initializes the input frame of the first basic block from the method
     * descriptor.
     *
     * @param cw
     * the ClassWriter to which this label belongs.
     * @param access
     * the access flags of the method to which this label belongs.
     * @param args
     * the formal parameter types of this method.
     * @param maxLocals
     * the maximum number of local variables of this method.
     */
    initInputFrame(cw, access, args, maxLocals) {
        this.inputLocals = new Array(maxLocals);
        this.inputStack = new Array(0);
        let i = 0;
        if ((access & Opcodes.ACC_STATIC) === 0) {
            if ((access & MethodWriter.ACC_CONSTRUCTOR) === 0) {
                this.inputLocals[i++] = Frame.OBJECT_$LI$() | cw.addType(cw.thisName);
            }
            else {
                this.inputLocals[i++] = Frame.UNINITIALIZED_THIS_$LI$();
            }
        }
        for (let j = 0; j < args.length; ++j) {
            let t = Frame.type(cw, args[j].getDescriptor());
            this.inputLocals[i++] = t;
            if (t === Frame.LONG_$LI$() || t === Frame.DOUBLE_$LI$()) {
                this.inputLocals[i++] = Frame.TOP_$LI$();
            }
        }
        while ((i < maxLocals)) {
            this.inputLocals[i++] = Frame.TOP_$LI$();
        }
    }
    /**
     * Simulates the action of the given instruction on the output stack frame.
     *
     * @param opcode
     * the opcode of the instruction.
     * @param arg
     * the operand of the instruction, if any.
     * @param cw
     * the class writer to which this label belongs.
     * @param item
     * the operand of the instructions, if any.
     */
    execute(opcode, arg, cw, item) {
        let t1;
        let t2;
        let t3;
        let t4;
        switch ((opcode)) {
            case Opcodes.NOP:
            case Opcodes.INEG:
            case Opcodes.LNEG:
            case Opcodes.FNEG:
            case Opcodes.DNEG:
            case Opcodes.I2B:
            case Opcodes.I2C:
            case Opcodes.I2S:
            case Opcodes.GOTO:
            case Opcodes.RETURN:
                break;
            case Opcodes.ACONST_NULL:
                this.push(Frame.NULL_$LI$());
                break;
            case Opcodes.ICONST_M1:
            case Opcodes.ICONST_0:
            case Opcodes.ICONST_1:
            case Opcodes.ICONST_2:
            case Opcodes.ICONST_3:
            case Opcodes.ICONST_4:
            case Opcodes.ICONST_5:
            case Opcodes.BIPUSH:
            case Opcodes.SIPUSH:
            case Opcodes.ILOAD:
                this.push(Frame.INTEGER_$LI$());
                break;
            case Opcodes.LCONST_0:
            case Opcodes.LCONST_1:
            case Opcodes.LLOAD:
                this.push(Frame.LONG_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.FCONST_0:
            case Opcodes.FCONST_1:
            case Opcodes.FCONST_2:
            case Opcodes.FLOAD:
                this.push(Frame.FLOAT_$LI$());
                break;
            case Opcodes.DCONST_0:
            case Opcodes.DCONST_1:
            case Opcodes.DLOAD:
                this.push(Frame.DOUBLE_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.LDC:
                assert(cw);
                assert(item);
                switch ((item.type)) {
                    case ClassWriter.INT:
                        this.push(Frame.INTEGER_$LI$());
                        break;
                    case ClassWriter.LONG:
                        this.push(Frame.LONG_$LI$());
                        this.push(Frame.TOP_$LI$());
                        break;
                    case ClassWriter.FLOAT:
                        this.push(Frame.FLOAT_$LI$());
                        break;
                    case ClassWriter.DOUBLE:
                        this.push(Frame.DOUBLE_$LI$());
                        this.push(Frame.TOP_$LI$());
                        break;
                    case ClassWriter.CLASS:
                        this.push(Frame.OBJECT_$LI$() | cw.addType("java/lang/Class"));
                        break;
                    case ClassWriter.STR:
                        this.push(Frame.OBJECT_$LI$() | cw.addType("java/lang/String"));
                        break;
                    case ClassWriter.MTYPE:
                        this.push(Frame.OBJECT_$LI$() | cw.addType("java/lang/invoke/MethodType"));
                        break;
                    default:
                        this.push(Frame.OBJECT_$LI$() | cw.addType("java/lang/invoke/MethodHandle"));
                }
                break;
            case Opcodes.ALOAD:
                this.push(this.get(arg));
                break;
            case Opcodes.IALOAD:
            case Opcodes.BALOAD:
            case Opcodes.CALOAD:
            case Opcodes.SALOAD:
                this.pop(2);
                this.push(Frame.INTEGER_$LI$());
                break;
            case Opcodes.LALOAD:
            case Opcodes.D2L:
                this.pop(2);
                this.push(Frame.LONG_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.FALOAD:
                this.pop(2);
                this.push(Frame.FLOAT_$LI$());
                break;
            case Opcodes.DALOAD:
            case Opcodes.L2D:
                this.pop(2);
                this.push(Frame.DOUBLE_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.AALOAD:
                this.pop(1);
                t1 = this.pop();
                this.push(Frame.ELEMENT_OF + t1);
                break;
            case Opcodes.ISTORE:
            case Opcodes.FSTORE:
            case Opcodes.ASTORE:
                t1 = this.pop();
                this.set(arg, t1);
                if (arg > 0) {
                    t2 = this.get(arg - 1);
                    if (t2 === Frame.LONG_$LI$() || t2 === Frame.DOUBLE_$LI$()) {
                        this.set(arg - 1, Frame.TOP_$LI$());
                    }
                    else if ((t2 & Frame.KIND) !== Frame.BASE) {
                        this.set(arg - 1, t2 | Frame.TOP_IF_LONG_OR_DOUBLE);
                    }
                }
                break;
            case Opcodes.LSTORE:
            case Opcodes.DSTORE:
                this.pop(1);
                t1 = this.pop();
                this.set(arg, t1);
                this.set(arg + 1, Frame.TOP_$LI$());
                if (arg > 0) {
                    t2 = this.get(arg - 1);
                    if (t2 === Frame.LONG_$LI$() || t2 === Frame.DOUBLE_$LI$()) {
                        this.set(arg - 1, Frame.TOP_$LI$());
                    }
                    else if ((t2 & Frame.KIND) !== Frame.BASE) {
                        this.set(arg - 1, t2 | Frame.TOP_IF_LONG_OR_DOUBLE);
                    }
                }
                break;
            case Opcodes.IASTORE:
            case Opcodes.BASTORE:
            case Opcodes.CASTORE:
            case Opcodes.SASTORE:
            case Opcodes.FASTORE:
            case Opcodes.AASTORE:
                this.pop(3);
                break;
            case Opcodes.LASTORE:
            case Opcodes.DASTORE:
                this.pop(4);
                break;
            case Opcodes.POP:
            case Opcodes.IFEQ:
            case Opcodes.IFNE:
            case Opcodes.IFLT:
            case Opcodes.IFGE:
            case Opcodes.IFGT:
            case Opcodes.IFLE:
            case Opcodes.IRETURN:
            case Opcodes.FRETURN:
            case Opcodes.ARETURN:
            case Opcodes.TABLESWITCH:
            case Opcodes.LOOKUPSWITCH:
            case Opcodes.ATHROW:
            case Opcodes.MONITORENTER:
            case Opcodes.MONITOREXIT:
            case Opcodes.IFNULL:
            case Opcodes.IFNONNULL:
                this.pop(1);
                break;
            case Opcodes.POP2:
            case Opcodes.IF_ICMPEQ:
            case Opcodes.IF_ICMPNE:
            case Opcodes.IF_ICMPLT:
            case Opcodes.IF_ICMPGE:
            case Opcodes.IF_ICMPGT:
            case Opcodes.IF_ICMPLE:
            case Opcodes.IF_ACMPEQ:
            case Opcodes.IF_ACMPNE:
            case Opcodes.LRETURN:
            case Opcodes.DRETURN:
                this.pop(2);
                break;
            case Opcodes.DUP:
                t1 = this.pop();
                this.push(t1);
                this.push(t1);
                break;
            case Opcodes.DUP_X1:
                t1 = this.pop();
                t2 = this.pop();
                this.push(t1);
                this.push(t2);
                this.push(t1);
                break;
            case Opcodes.DUP_X2:
                t1 = this.pop();
                t2 = this.pop();
                t3 = this.pop();
                this.push(t1);
                this.push(t3);
                this.push(t2);
                this.push(t1);
                break;
            case Opcodes.DUP2:
                t1 = this.pop();
                t2 = this.pop();
                this.push(t2);
                this.push(t1);
                this.push(t2);
                this.push(t1);
                break;
            case Opcodes.DUP2_X1:
                t1 = this.pop();
                t2 = this.pop();
                t3 = this.pop();
                this.push(t2);
                this.push(t1);
                this.push(t3);
                this.push(t2);
                this.push(t1);
                break;
            case Opcodes.DUP2_X2:
                t1 = this.pop();
                t2 = this.pop();
                t3 = this.pop();
                t4 = this.pop();
                this.push(t2);
                this.push(t1);
                this.push(t4);
                this.push(t3);
                this.push(t2);
                this.push(t1);
                break;
            case Opcodes.SWAP:
                t1 = this.pop();
                t2 = this.pop();
                this.push(t1);
                this.push(t2);
                break;
            case Opcodes.IADD:
            case Opcodes.ISUB:
            case Opcodes.IMUL:
            case Opcodes.IDIV:
            case Opcodes.IREM:
            case Opcodes.IAND:
            case Opcodes.IOR:
            case Opcodes.IXOR:
            case Opcodes.ISHL:
            case Opcodes.ISHR:
            case Opcodes.IUSHR:
            case Opcodes.L2I:
            case Opcodes.D2I:
            case Opcodes.FCMPL:
            case Opcodes.FCMPG:
                this.pop(2);
                this.push(Frame.INTEGER_$LI$());
                break;
            case Opcodes.LADD:
            case Opcodes.LSUB:
            case Opcodes.LMUL:
            case Opcodes.LDIV:
            case Opcodes.LREM:
            case Opcodes.LAND:
            case Opcodes.LOR:
            case Opcodes.LXOR:
                this.pop(4);
                this.push(Frame.LONG_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.FADD:
            case Opcodes.FSUB:
            case Opcodes.FMUL:
            case Opcodes.FDIV:
            case Opcodes.FREM:
            case Opcodes.L2F:
            case Opcodes.D2F:
                this.pop(2);
                this.push(Frame.FLOAT_$LI$());
                break;
            case Opcodes.DADD:
            case Opcodes.DSUB:
            case Opcodes.DMUL:
            case Opcodes.DDIV:
            case Opcodes.DREM:
                this.pop(4);
                this.push(Frame.DOUBLE_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.LSHL:
            case Opcodes.LSHR:
            case Opcodes.LUSHR:
                this.pop(3);
                this.push(Frame.LONG_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.IINC:
                this.set(arg, Frame.INTEGER_$LI$());
                break;
            case Opcodes.I2L:
            case Opcodes.F2L:
                this.pop(1);
                this.push(Frame.LONG_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.I2F:
                this.pop(1);
                this.push(Frame.FLOAT_$LI$());
                break;
            case Opcodes.I2D:
            case Opcodes.F2D:
                this.pop(1);
                this.push(Frame.DOUBLE_$LI$());
                this.push(Frame.TOP_$LI$());
                break;
            case Opcodes.F2I:
            case Opcodes.ARRAYLENGTH:
            case Opcodes.INSTANCEOF:
                this.pop(1);
                this.push(Frame.INTEGER_$LI$());
                break;
            case Opcodes.LCMP:
            case Opcodes.DCMPL:
            case Opcodes.DCMPG:
                this.pop(4);
                this.push(Frame.INTEGER_$LI$());
                break;
            case Opcodes.JSR:
            case Opcodes.RET:
                throw new Error("JSR/RET are not supported with computeFrames option");
            case Opcodes.GETSTATIC:
                assert(item);
                this.push(cw, item.strVal3);
                break;
            case Opcodes.PUTSTATIC:
                assert(item);
                this.pop(item.strVal3);
                break;
            case Opcodes.GETFIELD:
                assert(item);
                this.pop(1);
                this.push(cw, item.strVal3);
                break;
            case Opcodes.PUTFIELD:
                assert(item);
                this.pop(item.strVal3);
                this.pop();
                break;
            case Opcodes.INVOKEVIRTUAL:
            case Opcodes.INVOKESPECIAL:
            case Opcodes.INVOKESTATIC:
            case Opcodes.INVOKEINTERFACE:
                assert(item);
                this.pop(item.strVal3);
                if (opcode !== Opcodes.INVOKESTATIC) {
                    t1 = this.pop();
                    if (opcode === Opcodes.INVOKESPECIAL && item.strVal2.charAt(0) === "<") {
                        this.init(t1);
                    }
                }
                this.push(cw, item.strVal3);
                break;
            case Opcodes.INVOKEDYNAMIC:
                assert(item);
                this.pop(item.strVal2);
                this.push(cw, item.strVal2);
                break;
            case Opcodes.NEW:
                assert(item);
                assert(cw);
                this.push(Frame.UNINITIALIZED_$LI$() | cw.addUninitializedType(item.strVal1, arg));
                break;
            case Opcodes.NEWARRAY:
                this.pop();
                switch ((arg)) {
                    case Opcodes.T_BOOLEAN:
                        this.push(Frame.ARRAY_OF | Frame.BOOLEAN_$LI$());
                        break;
                    case Opcodes.T_CHAR:
                        this.push(Frame.ARRAY_OF | Frame.CHAR_$LI$());
                        break;
                    case Opcodes.T_BYTE:
                        this.push(Frame.ARRAY_OF | Frame.BYTE_$LI$());
                        break;
                    case Opcodes.T_SHORT:
                        this.push(Frame.ARRAY_OF | Frame.SHORT_$LI$());
                        break;
                    case Opcodes.T_INT:
                        this.push(Frame.ARRAY_OF | Frame.INTEGER_$LI$());
                        break;
                    case Opcodes.T_FLOAT:
                        this.push(Frame.ARRAY_OF | Frame.FLOAT_$LI$());
                        break;
                    case Opcodes.T_DOUBLE:
                        this.push(Frame.ARRAY_OF | Frame.DOUBLE_$LI$());
                        break;
                    default:
                        this.push(Frame.ARRAY_OF | Frame.LONG_$LI$());
                        break;
                }
                break;
            case Opcodes.ANEWARRAY:
                assert(item);
                assert(cw);
                let s = item.strVal1;
                this.pop();
                if (s.charAt(0) === "[") {
                    this.push(cw, "[" + s);
                }
                else {
                    this.push(Frame.ARRAY_OF | Frame.OBJECT_$LI$() | cw.addType(s));
                }
                break;
            case Opcodes.CHECKCAST:
                assert(item);
                s = item.strVal1;
                this.pop();
                if (s.charAt(0) === "[") {
                    this.push(cw, s);
                }
                else {
                    assert(cw);
                    this.push(Frame.OBJECT_$LI$() | cw.addType(s));
                }
                break;
            default:
                assert(item);
                this.pop(arg);
                this.push(cw, item.strVal1);
                break;
        }
    }
    /**
     * Merges the input frame of the given basic block with the input and output
     * frames of this basic block. Returns <tt>true</tt> if the input frame of
     * the given label has been changed by this operation.
     *
     * @param cw
     * the ClassWriter to which this label belongs.
     * @param frame
     * the basic block whose input frame must be updated.
     * @param edge
     * the kind of the {@link Edge} between this label and 'label'.
     * See {@link Edge#info}.
     * @return <tt>true</tt> if the input frame of the given label has been
     * changed by this operation.
     */
    merge(cw, frame, edge) {
        let changed = false;
        let i;
        let s;
        let dim;
        let kind;
        let t;
        let nLocal = this.inputLocals.length;
        let nStack = this.inputStack.length;
        if (frame.inputLocals == null) {
            frame.inputLocals = new Array(nLocal);
            changed = true;
        }
        for (i = 0; i < nLocal; ++i) {
            if (this.outputLocals != null && i < this.outputLocals.length) {
                s = this.outputLocals[i];
                if (s === 0) {
                    t = this.inputLocals[i];
                }
                else {
                    dim = s & Frame.DIM;
                    kind = s & Frame.KIND;
                    if (kind === Frame.BASE) {
                        t = s;
                    }
                    else {
                        if (kind === Frame.LOCAL) {
                            t = dim + this.inputLocals[s & Frame.VALUE];
                        }
                        else {
                            t = dim + this.inputStack[nStack - (s & Frame.VALUE)];
                        }
                        if ((s & Frame.TOP_IF_LONG_OR_DOUBLE) !== 0 && (t === Frame.LONG_$LI$() || t === Frame.DOUBLE_$LI$())) {
                            t = Frame.TOP_$LI$();
                        }
                    }
                }
            }
            else {
                t = this.inputLocals[i];
            }
            if (this.initializations != null) {
                t = this.init(cw, t);
            }
            changed = changed || Frame.merge(cw, t, frame.inputLocals, i);
        }
        if (edge > 0) {
            for (i = 0; i < nLocal; ++i) {
                t = this.inputLocals[i];
                changed = changed || Frame.merge(cw, t, frame.inputLocals, i);
            }
            if (frame.inputStack == null) {
                frame.inputStack = new Array(1);
                changed = true;
            }
            changed = changed || Frame.merge(cw, edge, frame.inputStack, 0);
            return changed;
        }
        let nInputStack = this.inputStack.length + this.owner.inputStackTop;
        if (frame.inputStack == null) {
            frame.inputStack = new Array(nInputStack + this.outputStackTop);
            changed = true;
        }
        for (i = 0; i < nInputStack; ++i) {
            t = this.inputStack[i];
            if (this.initializations != null) {
                t = this.init(cw, t);
            }
            changed = changed || Frame.merge(cw, t, frame.inputStack, i);
        }
        for (i = 0; i < this.outputStackTop; ++i) {
            s = this.outputStack[i];
            dim = s & Frame.DIM;
            kind = s & Frame.KIND;
            if (kind === Frame.BASE) {
                t = s;
            }
            else {
                if (kind === Frame.LOCAL) {
                    t = dim + this.inputLocals[s & Frame.VALUE];
                }
                else {
                    t = dim + this.inputStack[nStack - (s & Frame.VALUE)];
                }
                if ((s & Frame.TOP_IF_LONG_OR_DOUBLE) !== 0 && (t === Frame.LONG_$LI$() || t === Frame.DOUBLE_$LI$())) {
                    t = Frame.TOP_$LI$();
                }
            }
            if (this.initializations != null) {
                t = this.init(cw, t);
            }
            changed = changed || Frame.merge(cw, t, frame.inputStack, nInputStack + i);
        }
        return changed;
    }
    /**
     * Merges the type at the given index in the given type array with the given
     * type. Returns <tt>true</tt> if the type array has been modified by this
     * operation.
     *
     * @param cw
     * the ClassWriter to which this label belongs.
     * @param t
     * the type with which the type array element must be merged.
     * @param types
     * an array of types.
     * @param index
     * the index of the type that must be merged in 'types'.
     * @return <tt>true</tt> if the type array has been modified by this
     * operation.
     */
    static merge(cw, t, types, index) {
        let u = types[index];
        if (u === t) {
            return false;
        }
        if ((t & ~Frame.DIM) === Frame.NULL_$LI$()) {
            if (u === Frame.NULL_$LI$()) {
                return false;
            }
            t = Frame.NULL_$LI$();
        }
        if (u === 0) {
            types[index] = t;
            return true;
        }
        let v;
        if ((u & Frame.BASE_KIND) === Frame.OBJECT_$LI$() || (u & Frame.DIM) !== 0) {
            if (t === Frame.NULL_$LI$()) {
                return false;
            }
            else if ((t & (Frame.DIM | Frame.BASE_KIND)) === (u & (Frame.DIM | Frame.BASE_KIND))) {
                if ((u & Frame.BASE_KIND) === Frame.OBJECT_$LI$()) {
                    v = (t & Frame.DIM) | Frame.OBJECT_$LI$() | cw.getMergedType(t & Frame.BASE_VALUE, u & Frame.BASE_VALUE);
                }
                else {
                    let vdim = Frame.ELEMENT_OF + (u & Frame.DIM);
                    v = vdim | Frame.OBJECT_$LI$() | cw.addType("java/lang/Object");
                }
            }
            else if ((t & Frame.BASE_KIND) === Frame.OBJECT_$LI$() || (t & Frame.DIM) !== 0) {
                let tdim = (((t & Frame.DIM) === 0 || (t & Frame.BASE_KIND) === Frame.OBJECT_$LI$()) ? 0 : Frame.ELEMENT_OF) + (t & Frame.DIM);
                let udim = (((u & Frame.DIM) === 0 || (u & Frame.BASE_KIND) === Frame.OBJECT_$LI$()) ? 0 : Frame.ELEMENT_OF) + (u & Frame.DIM);
                v = Math.min(tdim, udim) | Frame.OBJECT_$LI$() | cw.addType("java/lang/Object");
            }
            else {
                v = Frame.TOP_$LI$();
            }
        }
        else if (u === Frame.NULL_$LI$()) {
            v = (t & Frame.BASE_KIND) === Frame.OBJECT_$LI$() || (t & Frame.DIM) !== 0 ? t : Frame.TOP_$LI$();
        }
        else {
            v = Frame.TOP_$LI$();
        }
        if (u !== v) {
            types[index] = v;
            return true;
        }
        return false;
    }
}
Frame.__static_initialized = false;
/**
 * Mask to get the dimension of a frame type. This dimension is a signed
 * integer between -8 and 7.
 */
Frame.DIM = -268435456;
/**
 * Constant to be added to a type to get a type with one more dimension.
 */
Frame.ARRAY_OF = 268435456;
/**
 * Constant to be added to a type to get a type with one less dimension.
 */
Frame.ELEMENT_OF = -268435456;
/**
 * Mask to get the kind of a frame type.
 *
 * @see #BASE
 * @see #LOCAL
 * @see #STACK
 */
Frame.KIND = 251658240;
/**
 * Flag used for LOCAL and STACK types. Indicates that if this type happens
 * to be a long or double type (during the computations of input frames),
 * then it must be set to TOP because the second word of this value has been
 * reused to store other data in the basic block. Hence the first word no
 * longer stores a valid long or double value.
 */
Frame.TOP_IF_LONG_OR_DOUBLE = 8388608;
/**
 * Mask to get the value of a frame type.
 */
Frame.VALUE = 8388607;
/**
 * Mask to get the kind of base types.
 */
Frame.BASE_KIND = 267386880;
/**
 * Mask to get the value of base types.
 */
Frame.BASE_VALUE = 1048575;
/**
 * Kind of the types that are not relative to an input stack map frame.
 */
Frame.BASE = 16777216;
/**
 * Kind of the types that are relative to the local variable types of an
 * input stack map frame. The value of such types is a local variable index.
 */
Frame.LOCAL = 33554432;
/**
 * Kind of the the types that are relative to the stack of an input stack
 * map frame. The value of such types is a position relatively to the top of
 * this stack.
 */
Frame.STACK = 50331648;
Frame.SIZE_$LI$();
Frame.UNINITIALIZED_THIS_$LI$();
Frame.NULL_$LI$();
Frame.LONG_$LI$();
Frame.DOUBLE_$LI$();
Frame.FLOAT_$LI$();
Frame.INTEGER_$LI$();
Frame.SHORT_$LI$();
Frame.CHAR_$LI$();
Frame.BYTE_$LI$();
Frame.BOOLEAN_$LI$();
Frame.TOP_$LI$();
Frame.UNINITIALIZED_$LI$();
Frame.OBJECT_$LI$();
Frame.__static_initialize();

class Edge {
    constructor() {
        /**
         * Information about this control flow graph edge. If
         * {@link ClassWriter#COMPUTE_MAXS} is used this field is the (relative)
         * stack size in the basic block from which this edge originates. This size
         * is equal to the stack size at the "jump" instruction to which this edge
         * corresponds, relatively to the stack size at the beginning of the
         * originating basic block. If {@link ClassWriter#COMPUTE_FRAMES} is used,
         * this field is the kind of this control flow graph edge (i.e. NORMAL or
         * EXCEPTION).
         */
        this.info = 0;
        /**
         * The next edge in the list of successors of the originating basic block.
         * See {@link Label#successors successors}.
         */
        this.next = null;
        this.info = 0;
    }
}
/**
 * Denotes a normal control flow graph edge.
 */
Edge.NORMAL = 0;
/**
 * Denotes a control flow graph edge corresponding to an exception handler.
 * More precisely any {@link Edge} whose {@link #info} is strictly positive
 * corresponds to an exception handler. The actual value of {@link #info} is
 * the index, in the {@link ClassWriter} type table, of the exception that
 * is catched.
 */
Edge.EXCEPTION = 2147483647;

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class Label {
    /**
     * Constructs a new label.
     */
    constructor() {
        /**
         * Informations about forward references. Each forward reference is
         * described by two consecutive integers in this array: the first one is the
         * position of the first byte of the bytecode instruction that contains the
         * forward reference, while the second is the position of the first byte of
         * the forward reference itself. In fact the sign of the first integer
         * indicates if this reference uses 2 or 4 bytes, and its absolute value
         * gives the position of the bytecode instruction. This array is also used
         * as a bitset to store the subroutines to which a basic block belongs. This
         * information is needed in {@linked MethodWriter#visitMaxs}, after all
         * forward references have been resolved. Hence the same array can be used
         * for both purposes without problems.
         */
        this.srcAndRefPositions = null;
        /**
         * Information about the input and output stack map frames of this basic
         * block. This field is only used when {@link ClassWriter#COMPUTE_FRAMES}
         * option is used.
         */
        this.frame = null;
        /**
         * The next basic block in the basic block stack. This stack is used in the
         * main loop of the fix point algorithm used in the second step of the
         * control flow analysis algorithms. It is also used in
         * {@link #visitSubroutine} to avoid using a recursive method, and in
         * ClassReader to temporarily store multiple source lines for a label.
         *
         * @see MethodWriter#visitMaxs
         */
        this.next = null;
        this.status = 0;
        this.line = 0;
        this.position = 0;
        this.referenceCount = 0;
        this.inputStackTop = 0;
        this.outputStackMax = 0;
    }
    /**
     * Returns the offset corresponding to this label. This offset is computed
     * from the start of the method's bytecode. <i>This method is intended for
     * {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.</i>
     *
     * @return the offset corresponding to this label.
     * @throws IllegalStateException
     * if this label is not resolved yet.
     */
    getOffset() {
        if ((this.status & Label.RESOLVED) === 0) {
            throw new Error("Label offset position has not been resolved yet");
        }
        return this.position;
    }
    /**
     * Puts a reference to this label in the bytecode of a method. If the
     * position of the label is known, the offset is computed and written
     * directly. Otherwise, a null offset is written and a new forward reference
     * is declared for this label.
     *
     * @param owner
     * the code writer that calls this method.
     * @param out
     * the bytecode of the method.
     * @param source
     * the position of first byte of the bytecode instruction that
     * contains this label.
     * @param wideOffset
     * <tt>true</tt> if the reference must be stored in 4 bytes, or
     * <tt>false</tt> if it must be stored with 2 bytes.
     * @throws IllegalArgumentException
     * if this label has not been created by the given code writer.
     */
    put(owner, out, source, wideOffset) {
        if ((this.status & Label.RESOLVED) === 0) {
            if (wideOffset) {
                this.addReference(-1 - source, out.length);
                out.putInt(-1);
            }
            else {
                this.addReference(source, out.length);
                out.putShort(-1);
            }
        }
        else {
            if (wideOffset) {
                out.putInt(this.position - source);
            }
            else {
                out.putShort(this.position - source);
            }
        }
    }
    /**
     * Adds a forward reference to this label. This method must be called only
     * for a true forward reference, i.e. only if this label is not resolved
     * yet. For backward references, the offset of the reference can be, and
     * must be, computed and stored directly.
     *
     * @param sourcePosition
     * the position of the referencing instruction. This position
     * will be used to compute the offset of this forward reference.
     * @param referencePosition
     * the position where the offset for this forward reference must
     * be stored.
     */
    addReference(sourcePosition, referencePosition) {
        if (this.srcAndRefPositions == null) {
            this.srcAndRefPositions = new Array(6);
        }
        if (this.referenceCount >= this.srcAndRefPositions.length) {
            let a = new Array(this.srcAndRefPositions.length + 6);
            a.concat(this.srcAndRefPositions);
            // java.lang.System.arraycopy(this.srcAndRefPositions, 0, a, 0, this.srcAndRefPositions.length);
            this.srcAndRefPositions = a;
        }
        this.srcAndRefPositions[this.referenceCount++] = sourcePosition;
        this.srcAndRefPositions[this.referenceCount++] = referencePosition;
    }
    /**
     * Resolves all forward references to this label. This method must be called
     * when this label is added to the bytecode of the method, i.e. when its
     * position becomes known. This method fills in the blanks that where left
     * in the bytecode by each forward reference previously added to this label.
     *
     * @param owner
     * the code writer that calls this method.
     * @param position
     * the position of this label in the bytecode.
     * @param data
     * the bytecode of the method.
     * @return <tt>true</tt> if a blank that was left for this label was to
     * small to store the offset. In such a case the corresponding jump
     * instruction is replaced with a pseudo instruction (using unused
     * opcodes) using an unsigned two bytes offset. These pseudo
     * instructions will be replaced with standard bytecode instructions
     * with wider offsets (4 bytes instead of 2), in ClassReader.
     * @throws IllegalArgumentException
     * if this label has already been resolved, or if it has not
     * been created by the given code writer.
     */
    resolve(owner, position, data) {
        assert(this.srcAndRefPositions);
        let needUpdate = false;
        this.status |= Label.RESOLVED;
        this.position = position;
        let i = 0;
        while ((i < this.referenceCount)) {
            let source = this.srcAndRefPositions[i++];
            let reference = this.srcAndRefPositions[i++];
            let offset;
            if (source >= 0) {
                offset = position - source;
                if (offset < SHORT_MIN || offset > SHORT_MAX) {
                    let opcode = data[reference - 1] & 255;
                    if (opcode <= Opcodes.JSR) {
                        data[reference - 1] = ((opcode + 49) | 0);
                    }
                    else {
                        data[reference - 1] = ((opcode + 20) | 0);
                    }
                    needUpdate = true;
                }
                data[reference++] = ((offset >>> 8) | 0);
                data[reference] = (offset | 0);
            }
            else {
                offset = position + source + 1;
                data[reference++] = ((offset >>> 24) | 0);
                data[reference++] = ((offset >>> 16) | 0);
                data[reference++] = ((offset >>> 8) | 0);
                data[reference] = (offset | 0);
            }
        }
        return needUpdate;
    }
    /**
     * Returns the first label of the series to which this label belongs. For an
     * isolated label or for the first label in a series of successive labels,
     * this method returns the label itself. For other labels it returns the
     * first label of the series.
     *
     * @return the first label of the series to which this label belongs.
     */
    getFirst() {
        return !ClassReader.FRAMES || this.frame == null ? this : this.frame.owner;
    }
    /**
     * Returns true is this basic block belongs to the given subroutine.
     *
     * @param id
     * a subroutine id.
     * @return true is this basic block belongs to the given subroutine.
     */
    inSubroutine(id) {
        assert(this.srcAndRefPositions);
        if ((this.status & Label.VISITED) !== 0) {
            return (this.srcAndRefPositions[((id >>> 32) | 0)] & (id | 0)) !== 0;
        }
        return false;
    }
    /**
     * Returns true if this basic block and the given one belong to a common
     * subroutine.
     *
     * @param block
     * another basic block.
     * @return true if this basic block and the given one belong to a common
     * subroutine.
     */
    inSameSubroutine(block) {
        if ((this.status & Label.VISITED) === 0 || (block.status & Label.VISITED) === 0) {
            return false;
        }
        assert(this.srcAndRefPositions);
        assert(block.srcAndRefPositions);
        for (let i = 0; i < this.srcAndRefPositions.length; ++i) {
            if ((this.srcAndRefPositions[i] & block.srcAndRefPositions[i]) !== 0) {
                return true;
            }
        }
        return false;
    }
    /**
     * Marks this basic block as belonging to the given subroutine.
     *
     * @param id
     * a subroutine id.
     * @param nbSubroutines
     * the total number of subroutines in the method.
     */
    addToSubroutine(id, nbSubroutines) {
        assert(this.srcAndRefPositions);
        if ((this.status & Label.VISITED) === 0) {
            this.status |= Label.VISITED;
            this.srcAndRefPositions = new Array((nbSubroutines / 32 | 0) + 1);
        }
        this.srcAndRefPositions[((id >>> 32) | 0)] |= (id | 0);
    }
    /**
     * Finds the basic blocks that belong to a given subroutine, and marks these
     * blocks as belonging to this subroutine. This method follows the control
     * flow graph to find all the blocks that are reachable from the current
     * block WITHOUT following any JSR target.
     *
     * @param JSR
     * a JSR block that jumps to this subroutine. If this JSR is not
     * null it is added to the successor of the RET blocks found in
     * the subroutine.
     * @param id
     * the id of this subroutine.
     * @param nbSubroutines
     * the total number of subroutines in the method.
     */
    visitSubroutine(JSR, id, nbSubroutines) {
        let stack = this;
        while ((stack != null)) {
            let l = stack;
            stack = l.next;
            l.next = null;
            if (JSR != null) {
                if ((l.status & Label.VISITED2) !== 0) {
                    continue;
                }
                l.status |= Label.VISITED2;
                if ((l.status & Label.RET) !== 0) {
                    if (!l.inSameSubroutine(JSR)) {
                        let e = new Edge();
                        e.info = l.inputStackTop;
                        e.successor = JSR.successors.successor;
                        e.next = l.successors;
                        l.successors = e;
                    }
                }
            }
            else {
                if (l.inSubroutine(id)) {
                    continue;
                }
                l.addToSubroutine(id, nbSubroutines);
            }
            let e = l.successors;
            while ((e != null)) {
                if ((l.status & Label.JSR) === 0 || (l.successors && e !== l.successors.next)) {
                    if (e.successor && e.successor.next == null) {
                        e.successor.next = stack;
                        stack = e.successor;
                    }
                }
                e = e.next;
            }
        }
    }
    /**
     * Returns a string representation of this label.
     *
     * @return a string representation of this label.
     */
    toString() {
        return "Lable";
        // return "L" + java.lang.System.identityHashCode(this);
    }
}
/**
 * Indicates if this label is only used for debug attributes. Such a label
 * is not the start of a basic block, the target of a jump instruction, or
 * an exception handler. It can be safely ignored in control flow graph
 * analysis algorithms (for optimization purposes).
 */
Label.DEBUG = 1;
/**
 * Indicates if the position of this label is known.
 */
Label.RESOLVED = 2;
/**
 * Indicates if this label has been updated, after instruction resizing.
 */
Label.RESIZED = 4;
/**
 * Indicates if this basic block has been pushed in the basic block stack.
 * See {@link MethodWriter#visitMaxs visitMaxs}.
 */
Label.PUSHED = 8;
/**
 * Indicates if this label is the target of a jump instruction, or the start
 * of an exception handler.
 */
Label.TARGET = 16;
/**
 * Indicates if a stack map frame must be stored for this label.
 */
Label.STORE = 32;
/**
 * Indicates if this label corresponds to a reachable basic block.
 */
Label.REACHABLE = 64;
/**
 * Indicates if this basic block ends with a JSR instruction.
 */
Label.JSR = 128;
/**
 * Indicates if this basic block ends with a RET instruction.
 */
Label.RET = 256;
/**
 * Indicates if this basic block is the start of a subroutine.
 */
Label.SUBROUTINE = 512;
/**
 * Indicates if this subroutine basic block has been visited by a
 * visitSubroutine(null, ...) call.
 */
Label.VISITED = 1024;
/**
 * Indicates if this subroutine basic block has been visited by a
 * visitSubroutine(!null, ...) call.
 */
Label.VISITED2 = 2048;

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class CurrentFrame extends Frame {
    /**
     * Sets this CurrentFrame to the input stack map frame of the next "current"
     * instruction, i.e. the instruction just after the given one. It is assumed
     * that the value of this object when this method is called is the stack map
     * frame status just before the given instruction is executed.
     */
    execute(opcode, arg, cw, item) {
        super.execute(opcode, arg, cw, item);
        let successor = new Frame(null);
        this.merge(cw, successor, 0);
        this.set$Frame(successor);
        this.owner.inputStackTop = 0;
    }
}

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class MethodWriter extends MethodVisitor {
    /**
     * Constructs a new {@link MethodWriter}.
     *
     * @param cw
     * the class writer in which the method must be added.
     * @param access
     * the method's access flags (see {@link Opcodes}).
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor (see {@link Type}).
     * @param signature
     * the method's signature. May be <tt>null</tt>.
     * @param exceptions
     * the internal names of the method's exceptions. May be
     * <tt>null</tt>.
     * @param compute
     * Indicates what must be automatically computed (see #compute).
     */
    constructor(cw, access, name, desc, signature, exceptions, compute) {
        super(Opcodes.ASM5);
        /**
         * The signature of this method.
         */
        this.signature = null;
        /**
         * The exceptions that can be thrown by this method. More precisely, this
         * array contains the indexes of the constant pool items that contain the
         * internal names of these exception classes.
         */
        this.exceptions = null;
        /**
         * The annotation default attribute of this method. May be <tt>null</tt>.
         */
        this.annd = null;
        /**
         * The runtime visible annotations of this method. May be <tt>null</tt>.
         */
        this.anns = null;
        /**
         * The runtime invisible annotations of this method. May be <tt>null</tt>.
         */
        this.ianns = null;
        /**
         * The runtime visible type annotations of this method. May be <tt>null</tt>
         * .
         */
        this.tanns = null;
        /**
         * The runtime invisible type annotations of this method. May be
         * <tt>null</tt>.
         */
        this.itanns = null;
        /**
         * The runtime visible parameter annotations of this method. May be
         * <tt>null</tt>.
         */
        this.panns = null;
        /**
         * The runtime invisible parameter annotations of this method. May be
         * <tt>null</tt>.
         */
        this.ipanns = null;
        /**
         * The non standard attributes of the method.
         */
        this.attrs = null;
        /**
         * The bytecode of this method.
         */
        this.code = new ByteVector();
        /**
         * The StackMapTable attribute.
         */
        this.stackMap = null;
        /**
         * The last frame that was written in the StackMapTable attribute.
         *
         * @see #frame
         */
        this.previousFrame = null;
        /**
         * The current stack map frame. The first element contains the offset of the
         * instruction to which the frame corresponds, the second element is the
         * number of locals and the third one is the number of stack elements. The
         * local variables start at index 3 and are followed by the operand stack
         * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =
         * nStack, frame[3] = nLocal. All types are encoded as integers, with the
         * same format as the one used in {@link Label}, but limited to BASE types.
         */
        this.frame = null;
        /**
         * The first element in the exception handler list.
         */
        this.firstHandler = null;
        /**
         * The last element in the exception handler list.
         */
        this.lastHandler = null;
        /**
         * The MethodParameters attribute.
         */
        this.methodParameters = null;
        /**
         * The LocalVariableTable attribute.
         */
        this.localVar = null;
        /**
         * The LocalVariableTypeTable attribute.
         */
        this.localVarType = null;
        /**
         * The LineNumberTable attribute.
         */
        this.lineNumber = null;
        /**
         * The runtime visible type annotations of the code. May be <tt>null</tt>.
         */
        this.ctanns = null;
        /**
         * The runtime invisible type annotations of the code. May be <tt>null</tt>.
         */
        this.ictanns = null;
        /**
         * The non standard attributes of the method's code.
         */
        this.cattrs = null;
        /**
         * A list of labels. This list is the list of basic blocks in the method,
         * i.e. a list of Label objects linked to each other by their
         * {@link Label#successor} field, in the order they are visited by
         * {@link MethodVisitor#visitLabel}, and starting with the first basic
         * block.
         */
        this.labels = null;
        /**
         * The previous basic block.
         */
        this.previousBlock = null;
        /**
         * The current basic block.
         */
        this.currentBlock = null;
        this.access = 0;
        this.name = 0;
        this.desc = 0;
        this.classReaderOffset = 0;
        this.classReaderLength = 0;
        this.exceptionCount = 0;
        this.synthetics = 0;
        this.maxStack = 0;
        this.maxLocals = 0;
        this.currentLocals = 0;
        this.frameCount = 0;
        this.previousFrameOffset = 0;
        this.handlerCount = 0;
        this.methodParametersCount = 0;
        this.localVarCount = 0;
        this.localVarTypeCount = 0;
        this.lineNumberCount = 0;
        this.lastCodeOffset = 0;
        this.subroutines = 0;
        this.compute = 0;
        this.stackSize = 0;
        this.maxStackSize = 0;
        if (cw.firstMethod == null) {
            cw.firstMethod = this;
        }
        else {
            cw.lastMethod.mv = this;
        }
        cw.lastMethod = this;
        this.cw = cw;
        this.access = access;
        if (("<init>" === name)) {
            this.access |= MethodWriter.ACC_CONSTRUCTOR;
        }
        this.name = cw.newUTF8(name);
        this.desc = cw.newUTF8(desc);
        this.descriptor = desc;
        if (ClassReader.SIGNATURES) {
            this.signature = signature;
        }
        if (exceptions != null && exceptions.length > 0) {
            this.exceptionCount = exceptions.length;
            this.exceptions = new Array(this.exceptionCount);
            for (let i = 0; i < this.exceptionCount; ++i) {
                this.exceptions[i] = cw.newClass(exceptions[i]);
            }
        }
        this.compute = compute;
        if (compute !== MethodWriter.NOTHING) {
            let size = Type.getArgumentsAndReturnSizes(this.descriptor) >> 2;
            if ((access & Opcodes.ACC_STATIC) !== 0) {
                --size;
            }
            this.maxLocals = size;
            this.currentLocals = size;
            this.labels = new Label();
            this.labels.status |= Label.PUSHED;
            this.visitLabel(this.labels);
        }
    }
    visitParameter(name, access) {
        if (this.methodParameters == null) {
            this.methodParameters = new ByteVector();
        }
        ++this.methodParametersCount;
        this.methodParameters.putShort((name == null) ? 0 : this.cw.newUTF8(name)).putShort(access);
    }
    visitAnnotationDefault() {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        this.annd = new ByteVector();
        return new AnnotationWriter(this.cw, false, this.annd, null, 0);
    }
    visitAnnotation(desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        bv.putShort(this.cw.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this.cw, true, bv, bv, 2);
        if (visible) {
            aw.next = this.anns;
            this.anns = aw;
        }
        else {
            aw.next = this.ianns;
            this.ianns = aw;
        }
        return aw;
    }
    visitTypeAnnotation(typeRef, typePath, desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        AnnotationWriter.putTarget(typeRef, typePath, bv);
        bv.putShort(this.cw.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this.cw, true, bv, bv, bv.length - 2);
        if (visible) {
            aw.next = this.tanns;
            this.tanns = aw;
        }
        else {
            aw.next = this.itanns;
            this.itanns = aw;
        }
        return aw;
    }
    visitParameterAnnotation(parameter, desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        if (("Ljava/lang/Synthetic;" === desc)) {
            this.synthetics = Math.max(this.synthetics, parameter + 1);
            return new AnnotationWriter(this.cw, false, bv, null, 0);
        }
        bv.putShort(this.cw.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this.cw, true, bv, bv, 2);
        if (visible) {
            if (this.panns == null) {
                this.panns = new Array(Type.getArgumentTypes(this.descriptor).length);
            }
            aw.next = this.panns[parameter];
            this.panns[parameter] = aw;
        }
        else {
            if (this.ipanns == null) {
                this.ipanns = new Array(Type.getArgumentTypes(this.descriptor).length);
            }
            aw.next = this.ipanns[parameter];
            this.ipanns[parameter] = aw;
        }
        return aw;
    }
    visitAttribute(attr) {
        if (attr.isCodeAttribute()) {
            attr.next = this.cattrs;
            this.cattrs = attr;
        }
        else {
            attr.next = this.attrs;
            this.attrs = attr;
        }
    }
    visitCode() {
    }
    visitFrame(type, nLocal, local, nStack, stack) {
        assert(this.frame);
        if (((typeof type === "number") || type === null) && ((typeof nLocal === "number") || nLocal === null) && ((local != null && local instanceof Array) || local === null) && ((typeof nStack === "number") || nStack === null) && ((stack != null && stack instanceof Array) || stack === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                if (!ClassReader.FRAMES || this.compute === MethodWriter.FRAMES) {
                    return;
                }
                if (this.compute === MethodWriter.INSERTED_FRAMES) {
                    if (this.currentBlock && this.currentBlock.frame == null) {
                        this.currentBlock.frame = new CurrentFrame(this.currentBlock);
                        this.currentBlock.frame.initInputFrame(this.cw, this.access, Type.getArgumentTypes(this.descriptor), nLocal);
                        this.visitImplicitFirstFrame();
                    }
                    else {
                        assert(this.currentBlock);
                        if (type === Opcodes.F_NEW) {
                            assert(this.currentBlock.frame);
                            this.currentBlock.frame.set(this.cw, nLocal, local, nStack, stack);
                        }
                        this.visitFrame(this.currentBlock.frame);
                    }
                }
                else if (type === Opcodes.F_NEW) {
                    if (this.previousFrame == null) {
                        this.visitImplicitFirstFrame();
                    }
                    this.currentLocals = nLocal;
                    let frameIndex = this.startFrame(this.code.length, nLocal, nStack);
                    for (let i = 0; i < nLocal; ++i) {
                        if (typeof local[i] === "string") {
                            this.frame[frameIndex++] = Frame.OBJECT_$LI$() | this.cw.addType(local[i]);
                        }
                        else if (typeof local[i] === "number") {
                            this.frame[frameIndex++] = /* intValue */ (local[i] | 0);
                        }
                        else {
                            this.frame[frameIndex++] = Frame.UNINITIALIZED_$LI$() | this.cw.addUninitializedType("", local[i].position);
                        }
                    }
                    for (let i = 0; i < nStack; ++i) {
                        if (typeof stack[i] === "string") {
                            this.frame[frameIndex++] = Frame.OBJECT_$LI$() | this.cw.addType(stack[i]);
                        }
                        else if (typeof stack[i] === "number") {
                            this.frame[frameIndex++] = /* intValue */ (stack[i] | 0);
                        }
                        else {
                            this.frame[frameIndex++] = Frame.UNINITIALIZED_$LI$() | this.cw.addUninitializedType("", stack[i].position);
                        }
                    }
                    this.endFrame();
                }
                else {
                    let delta;
                    if (this.stackMap == null) {
                        this.stackMap = new ByteVector();
                        delta = this.code.length;
                    }
                    else {
                        delta = this.code.length - this.previousFrameOffset - 1;
                        if (delta < 0) {
                            if (type === Opcodes.F_SAME) {
                                return;
                            }
                            else {
                                throw new Error();
                            }
                        }
                    }
                    switch ((type)) {
                        case Opcodes.F_FULL:
                            this.currentLocals = nLocal;
                            this.stackMap.putByte(MethodWriter.FULL_FRAME).putShort(delta).putShort(nLocal);
                            for (let i = 0; i < nLocal; ++i) {
                                this.writeFrameType(local[i]);
                            }
                            this.stackMap.putShort(nStack);
                            for (let i = 0; i < nStack; ++i) {
                                this.writeFrameType(stack[i]);
                            }
                            break;
                        case Opcodes.F_APPEND:
                            this.currentLocals += nLocal;
                            this.stackMap.putByte(MethodWriter.SAME_FRAME_EXTENDED + nLocal).putShort(delta);
                            for (let i = 0; i < nLocal; ++i) {
                                this.writeFrameType(local[i]);
                            }
                            break;
                        case Opcodes.F_CHOP:
                            this.currentLocals -= nLocal;
                            this.stackMap.putByte(MethodWriter.SAME_FRAME_EXTENDED - nLocal).putShort(delta);
                            break;
                        case Opcodes.F_SAME:
                            if (delta < 64) {
                                this.stackMap.putByte(delta);
                            }
                            else {
                                this.stackMap.putByte(MethodWriter.SAME_FRAME_EXTENDED).putShort(delta);
                            }
                            break;
                        case Opcodes.F_SAME1:
                            if (delta < 64) {
                                this.stackMap.putByte(MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME + delta);
                            }
                            else {
                                this.stackMap.putByte(MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(delta);
                            }
                            this.writeFrameType(stack[0]);
                            break;
                    }
                    this.previousFrameOffset = this.code.length;
                    ++this.frameCount;
                }
                this.maxStack = Math.max(this.maxStack, nStack);
                this.maxLocals = Math.max(this.maxLocals, this.currentLocals);
            })();
        }
        else if (((type != null && type instanceof Frame) || type === null) && nLocal === undefined && local === undefined && nStack === undefined && stack === undefined) {
            return this.visitFrame$Frame(type);
        }
        else {
            throw new Error("invalid overload");
        }
    }
    visitInsn(opcode) {
        this.lastCodeOffset = this.code.length;
        this.code.putByte(opcode);
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(opcode, 0, null, null);
            }
            else {
                let size = this.stackSize + Frame.SIZE_$LI$()[opcode];
                if (size > this.maxStackSize) {
                    this.maxStackSize = size;
                }
                this.stackSize = size;
            }
            if ((opcode >= Opcodes.IRETURN && opcode <= Opcodes.RETURN) || opcode === Opcodes.ATHROW) {
                this.noSuccessor();
            }
        }
    }
    visitIntInsn(opcode, operand) {
        this.lastCodeOffset = this.code.length;
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(opcode, operand, null, null);
            }
            else if (opcode !== Opcodes.NEWARRAY) {
                let size = this.stackSize + 1;
                if (size > this.maxStackSize) {
                    this.maxStackSize = size;
                }
                this.stackSize = size;
            }
        }
        if (opcode === Opcodes.SIPUSH) {
            this.code.put12(opcode, operand);
        }
        else {
            this.code.put11(opcode, operand);
        }
    }
    visitVarInsn(opcode, __var) {
        this.lastCodeOffset = this.code.length;
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(opcode, __var, null, null);
            }
            else {
                if (opcode === Opcodes.RET) {
                    this.currentBlock.status |= Label.RET;
                    this.currentBlock.inputStackTop = this.stackSize;
                    this.noSuccessor();
                }
                else {
                    let size = this.stackSize + Frame.SIZE_$LI$()[opcode];
                    if (size > this.maxStackSize) {
                        this.maxStackSize = size;
                    }
                    this.stackSize = size;
                }
            }
        }
        if (this.compute !== MethodWriter.NOTHING) {
            let n;
            if (opcode === Opcodes.LLOAD || opcode === Opcodes.DLOAD || opcode === Opcodes.LSTORE || opcode === Opcodes.DSTORE) {
                n = __var + 2;
            }
            else {
                n = __var + 1;
            }
            if (n > this.maxLocals) {
                this.maxLocals = n;
            }
        }
        if (__var < 4 && opcode !== Opcodes.RET) {
            let opt;
            if (opcode < Opcodes.ISTORE) {
                opt = 26 + ((opcode - Opcodes.ILOAD) << 2) + __var;
            }
            else {
                opt = 59 + ((opcode - Opcodes.ISTORE) << 2) + __var;
            }
            this.code.putByte(opt);
        }
        else if (__var >= 256) {
            this.code.putByte(196).put12(opcode, __var);
        }
        else {
            this.code.put11(opcode, __var);
        }
        if (opcode >= Opcodes.ISTORE && this.compute === MethodWriter.FRAMES && this.handlerCount > 0) {
            this.visitLabel(new Label());
        }
    }
    visitTypeInsn(opcode, type) {
        this.lastCodeOffset = this.code.length;
        let i = this.cw.newClassItem(type);
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(opcode, this.code.length, this.cw, i);
            }
            else if (opcode === Opcodes.NEW) {
                let size = this.stackSize + 1;
                if (size > this.maxStackSize) {
                    this.maxStackSize = size;
                }
                this.stackSize = size;
            }
        }
        this.code.put12(opcode, i.index);
    }
    visitFieldInsn(opcode, owner, name, desc) {
        this.lastCodeOffset = this.code.length;
        let i = this.cw.newFieldItem(owner, name, desc);
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(opcode, 0, this.cw, i);
            }
            else {
                let size;
                let c = desc.charAt(0);
                switch ((opcode)) {
                    case Opcodes.GETSTATIC:
                        size = this.stackSize + (c === "D" || c === "J" ? 2 : 1);
                        break;
                    case Opcodes.PUTSTATIC:
                        size = this.stackSize + (c === "D" || c === "J" ? -2 : -1);
                        break;
                    case Opcodes.GETFIELD:
                        size = this.stackSize + (c === "D" || c === "J" ? 1 : 0);
                        break;
                    default:
                        size = this.stackSize + (c === "D" || c === "J" ? -3 : -2);
                        break;
                }
                if (size > this.maxStackSize) {
                    this.maxStackSize = size;
                }
                this.stackSize = size;
            }
        }
        this.code.put12(opcode, i.index);
    }
    visitMethodInsn(opcode, owner, name, desc, itf) {
        if (((typeof opcode === "number") || opcode === null) && ((typeof owner === "string") || owner === null) && ((typeof name === "string") || name === null) && ((typeof desc === "string") || desc === null) && ((typeof itf === "boolean") || itf === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                this.lastCodeOffset = this.code.length;
                let i = this.cw.newMethodItem(owner, name, desc, itf);
                let argSize = i.intVal;
                if (this.currentBlock != null) {
                    if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                        assert(this.currentBlock.frame);
                        this.currentBlock.frame.execute(opcode, 0, this.cw, i);
                    }
                    else {
                        if (argSize === 0) {
                            argSize = Type.getArgumentsAndReturnSizes(desc);
                            i.intVal = argSize;
                        }
                        let size;
                        if (opcode === Opcodes.INVOKESTATIC) {
                            size = this.stackSize - (argSize >> 2) + (argSize & 3) + 1;
                        }
                        else {
                            size = this.stackSize - (argSize >> 2) + (argSize & 3);
                        }
                        if (size > this.maxStackSize) {
                            this.maxStackSize = size;
                        }
                        this.stackSize = size;
                    }
                }
                if (opcode === Opcodes.INVOKEINTERFACE) {
                    if (argSize === 0) {
                        argSize = Type.getArgumentsAndReturnSizes(desc);
                        i.intVal = argSize;
                    }
                    this.code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize >> 2, 0);
                }
                else {
                    this.code.put12(opcode, i.index);
                }
            })();
        }
        else if (((typeof opcode === "number") || opcode === null) && ((typeof owner === "string") || owner === null) && ((typeof name === "string") || name === null) && ((typeof desc === "string") || desc === null) && itf === undefined) {
            return this.visitMethodInsn$int$java_lang_String$java_lang_String$java_lang_String(opcode, owner, name, desc);
        }
        else {
            throw new Error("invalid overload");
        }
    }
    visitInvokeDynamicInsn(name, desc, bsm, ...bsmArgs) {
        this.lastCodeOffset = this.code.length;
        let i = this.cw.newInvokeDynamicItem(name, desc, bsm, ...bsmArgs);
        let argSize = i.intVal;
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, this.cw, i);
            }
            else {
                if (argSize === 0) {
                    argSize = Type.getArgumentsAndReturnSizes(desc);
                    i.intVal = argSize;
                }
                let size = this.stackSize - (argSize >> 2) + (argSize & 3) + 1;
                if (size > this.maxStackSize) {
                    this.maxStackSize = size;
                }
                this.stackSize = size;
            }
        }
        this.code.put12(Opcodes.INVOKEDYNAMIC, i.index);
        this.code.putShort(0);
    }
    visitJumpInsn(opcode, label) {
        let isWide = opcode >= 200;
        opcode = isWide ? opcode - 33 : opcode;
        this.lastCodeOffset = this.code.length;
        let nextInsn = null;
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(opcode, 0, null, null);
                label.getFirst().status |= Label.TARGET;
                this.addSuccessor(Edge.NORMAL, label);
                if (opcode !== Opcodes.GOTO) {
                    nextInsn = new Label();
                }
            }
            else if (this.compute === MethodWriter.INSERTED_FRAMES) {
                this.currentBlock.frame.execute(opcode, 0, null, null);
            }
            else {
                if (opcode === Opcodes.JSR) {
                    if ((label.status & Label.SUBROUTINE) === 0) {
                        label.status |= Label.SUBROUTINE;
                        ++this.subroutines;
                    }
                    this.currentBlock.status |= Label.JSR;
                    this.addSuccessor(this.stackSize + 1, label);
                    nextInsn = new Label();
                }
                else {
                    this.stackSize += Frame.SIZE_$LI$()[opcode];
                    this.addSuccessor(this.stackSize, label);
                }
            }
        }
        if ((label.status & Label.RESOLVED) !== 0 && label.position - this.code.length < SHORT_MIN) {
            if (opcode === Opcodes.GOTO) {
                this.code.putByte(200);
            }
            else if (opcode === Opcodes.JSR) {
                this.code.putByte(201);
            }
            else {
                if (nextInsn != null) {
                    nextInsn.status |= Label.TARGET;
                }
                this.code.putByte(opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1);
                this.code.putShort(8);
                this.code.putByte(200);
            }
            label.put(this, this.code, this.code.length - 1, true);
        }
        else if (isWide) {
            this.code.putByte(opcode + 33);
            label.put(this, this.code, this.code.length - 1, true);
        }
        else {
            this.code.putByte(opcode);
            label.put(this, this.code, this.code.length - 1, false);
        }
        if (this.currentBlock != null) {
            if (nextInsn != null) {
                this.visitLabel(nextInsn);
            }
            if (opcode === Opcodes.GOTO) {
                this.noSuccessor();
            }
        }
    }
    visitLabel(label) {
        this.cw.hasAsmInsns = this.cw.hasAsmInsns || label.resolve(this, this.code.length, this.code.data);
        if ((label.status & Label.DEBUG) !== 0) {
            return;
        }
        if (this.compute === MethodWriter.FRAMES) {
            if (this.currentBlock != null) {
                if (label.position === this.currentBlock.position) {
                    this.currentBlock.status |= (label.status & Label.TARGET);
                    label.frame = this.currentBlock.frame;
                    return;
                }
                this.addSuccessor(Edge.NORMAL, label);
            }
            this.currentBlock = label;
            if (label.frame == null) {
                label.frame = new Frame(label);
            }
            if (this.previousBlock != null) {
                if (label.position === this.previousBlock.position) {
                    this.previousBlock.status |= (label.status & Label.TARGET);
                    label.frame = this.previousBlock.frame;
                    this.currentBlock = this.previousBlock;
                    return;
                }
                this.previousBlock.successor = label;
            }
            this.previousBlock = label;
        }
        else if (this.compute === MethodWriter.INSERTED_FRAMES) {
            if (this.currentBlock == null) {
                this.currentBlock = label;
            }
            else {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.owner = label;
            }
        }
        else if (this.compute === MethodWriter.MAXS) {
            if (this.currentBlock != null) {
                this.currentBlock.outputStackMax = this.maxStackSize;
                this.addSuccessor(this.stackSize, label);
            }
            this.currentBlock = label;
            this.stackSize = 0;
            this.maxStackSize = 0;
            if (this.previousBlock != null) {
                this.previousBlock.successor = label;
            }
            this.previousBlock = label;
        }
    }
    visitLdcInsn(cst) {
        this.lastCodeOffset = this.code.length;
        let i = this.cw.newConstItem(cst);
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                this.currentBlock.frame.execute(Opcodes.LDC, 0, this.cw, i);
            }
            else {
                let size;
                if (i.type === ClassWriter.LONG || i.type === ClassWriter.DOUBLE) {
                    size = this.stackSize + 2;
                }
                else {
                    size = this.stackSize + 1;
                }
                if (size > this.maxStackSize) {
                    this.maxStackSize = size;
                }
                this.stackSize = size;
            }
        }
        let index = i.index;
        if (i.type === ClassWriter.LONG || i.type === ClassWriter.DOUBLE) {
            this.code.put12(20, index);
        }
        else if (index >= 256) {
            this.code.put12(19, index);
        }
        else {
            this.code.put11(Opcodes.LDC, index);
        }
    }
    visitIincInsn(__var, increment) {
        this.lastCodeOffset = this.code.length;
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                this.currentBlock.frame.execute(Opcodes.IINC, __var, null, null);
            }
        }
        if (this.compute !== MethodWriter.NOTHING) {
            let n = __var + 1;
            if (n > this.maxLocals) {
                this.maxLocals = n;
            }
        }
        if ((__var > 255) || (increment > 127) || (increment < -128)) {
            this.code.putByte(196).put12(Opcodes.IINC, __var).putShort(increment);
        }
        else {
            this.code.putByte(Opcodes.IINC).put11(__var, increment);
        }
    }
    visitTableSwitchInsn(min, max, dflt, ...labels) {
        this.lastCodeOffset = this.code.length;
        let source = this.code.length;
        this.code.putByte(Opcodes.TABLESWITCH);
        this.code.putByteArray(null, 0, (4 - this.code.length % 4) % 4);
        dflt.put(this, this.code, source, true);
        this.code.putInt(min).putInt(max);
        for (let i = 0; i < labels.length; ++i) {
            labels[i].put(this, this.code, source, true);
        }
        this.visitSwitchInsn(dflt, labels);
    }
    visitLookupSwitchInsn(dflt, keys, labels) {
        this.lastCodeOffset = this.code.length;
        let source = this.code.length;
        this.code.putByte(Opcodes.LOOKUPSWITCH);
        this.code.putByteArray(null, 0, (4 - this.code.length % 4) % 4);
        dflt.put(this, this.code, source, true);
        this.code.putInt(labels.length);
        for (let i = 0; i < labels.length; ++i) {
            this.code.putInt(keys[i]);
            labels[i].put(this, this.code, source, true);
        }
        this.visitSwitchInsn(dflt, labels);
    }
    visitSwitchInsn(dflt, labels) {
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);
                this.addSuccessor(Edge.NORMAL, dflt);
                dflt.getFirst().status |= Label.TARGET;
                for (let i = 0; i < labels.length; ++i) {
                    this.addSuccessor(Edge.NORMAL, labels[i]);
                    labels[i].getFirst().status |= Label.TARGET;
                }
            }
            else {
                --this.stackSize;
                this.addSuccessor(this.stackSize, dflt);
                for (let i = 0; i < labels.length; ++i) {
                    this.addSuccessor(this.stackSize, labels[i]);
                }
            }
            this.noSuccessor();
        }
    }
    visitMultiANewArrayInsn(desc, dims) {
        this.lastCodeOffset = this.code.length;
        let i = this.cw.newClassItem(desc);
        if (this.currentBlock != null) {
            if (this.compute === MethodWriter.FRAMES || this.compute === MethodWriter.INSERTED_FRAMES) {
                assert(this.currentBlock.frame);
                this.currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, this.cw, i);
            }
            else {
                this.stackSize += 1 - dims;
            }
        }
        this.code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);
    }
    visitInsnAnnotation(typeRef, typePath, desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        typeRef = (typeRef & -16776961) | (this.lastCodeOffset << 8);
        AnnotationWriter.putTarget(typeRef, typePath, bv);
        bv.putShort(this.cw.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this.cw, true, bv, bv, bv.length - 2);
        if (visible) {
            aw.next = this.ctanns;
            this.ctanns = aw;
        }
        else {
            aw.next = this.ictanns;
            this.ictanns = aw;
        }
        return aw;
    }
    visitTryCatchBlock(start, end, handler, type) {
        ++this.handlerCount;
        let h = new Handler();
        h.start = start;
        h.end = end;
        h.handler = handler;
        h.desc = type;
        h.type = type != null ? this.cw.newClass(type) : 0;
        if (this.lastHandler == null) {
            this.firstHandler = h;
        }
        else {
            this.lastHandler.next = h;
        }
        this.lastHandler = h;
    }
    visitTryCatchAnnotation(typeRef, typePath, desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        AnnotationWriter.putTarget(typeRef, typePath, bv);
        bv.putShort(this.cw.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this.cw, true, bv, bv, bv.length - 2);
        if (visible) {
            aw.next = this.ctanns;
            this.ctanns = aw;
        }
        else {
            aw.next = this.ictanns;
            this.ictanns = aw;
        }
        return aw;
    }
    visitLocalVariable(name, desc, signature, start, end, index) {
        if (signature != null) {
            if (this.localVarType == null) {
                this.localVarType = new ByteVector();
            }
            ++this.localVarTypeCount;
            this.localVarType.putShort(start.position).putShort(end.position - start.position).putShort(this.cw.newUTF8(name)).putShort(this.cw.newUTF8(signature)).putShort(index);
        }
        if (this.localVar == null) {
            this.localVar = new ByteVector();
        }
        ++this.localVarCount;
        this.localVar.putShort(start.position).putShort(end.position - start.position).putShort(this.cw.newUTF8(name)).putShort(this.cw.newUTF8(desc)).putShort(index);
        if (this.compute !== MethodWriter.NOTHING) {
            let c = desc.charAt(0);
            let n = index + (c === "J" || c === "D" ? 2 : 1);
            if (n > this.maxLocals) {
                this.maxLocals = n;
            }
        }
    }
    visitLocalVariableAnnotation(typeRef, typePath, start, end, index, desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        bv.putByte(typeRef >>> 24).putShort(start.length);
        for (let i = 0; i < start.length; ++i) {
            bv.putShort(start[i].position).putShort(end[i].position - start[i].position).putShort(index[i]);
        }
        if (typePath == null) {
            bv.putByte(0);
        }
        else {
            let length = typePath.buf[typePath.offset] * 2 + 1;
            bv.putByteArray(typePath.buf, typePath.offset, length);
        }
        bv.putShort(this.cw.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this.cw, true, bv, bv, bv.length - 2);
        if (visible) {
            aw.next = this.ctanns;
            this.ctanns = aw;
        }
        else {
            aw.next = this.ictanns;
            this.ictanns = aw;
        }
        return aw;
    }
    visitLineNumber(line, start) {
        if (this.lineNumber == null) {
            this.lineNumber = new ByteVector();
        }
        ++this.lineNumberCount;
        this.lineNumber.putShort(start.position);
        this.lineNumber.putShort(line);
    }
    visitMaxs(maxStack, maxLocals) {
        if (ClassReader.FRAMES && this.compute === MethodWriter.FRAMES) {
            let handler = this.firstHandler;
            while ((handler != null)) {
                assert(handler.start);
                assert(handler.handler);
                assert(handler.end);
                let l = handler.start.getFirst();
                let h = handler.handler.getFirst();
                let e = handler.end.getFirst();
                let t = handler.desc == null ? "java/lang/Throwable" : handler.desc;
                let kind = Frame.OBJECT_$LI$() | this.cw.addType(t);
                h.status |= Label.TARGET;
                while ((l !== e)) {
                    let b = new Edge();
                    b.info = kind;
                    b.successor = h;
                    b.next = l.successors;
                    l.successors = b;
                    l = l.successor;
                }
                handler = handler.next;
            }
            assert(this.labels);
            assert(this.labels.frame);
            let f = this.labels.frame;
            f.initInputFrame(this.cw, this.access, Type.getArgumentTypes(this.descriptor), this.maxLocals);
            this.visitFrame(f);
            let max = 0;
            let changed = this.labels;
            while ((changed != null)) {
                let l = changed;
                changed = changed.next;
                l.next = null;
                f = l.frame;
                if ((l.status & Label.TARGET) !== 0) {
                    l.status |= Label.STORE;
                }
                assert(f);
                l.status |= Label.REACHABLE;
                let blockMax = f.inputStack.length + l.outputStackMax;
                if (blockMax > max) {
                    max = blockMax;
                }
                let e = l.successors;
                while ((e != null)) {
                    let n = e.successor.getFirst();
                    let change = f.merge(this.cw, n.frame, e.info);
                    if (change && n.next == null) {
                        n.next = changed;
                        changed = n;
                    }
                    e = e.next;
                }
            }
            let l = this.labels;
            while ((l != null)) {
                f = l.frame;
                if ((l.status & Label.STORE) !== 0) {
                    this.visitFrame(f);
                }
                if ((l.status & Label.REACHABLE) === 0) {
                    let k = l.successor;
                    let start = l.position;
                    let end = (k == null ? this.code.length : k.position) - 1;
                    if (end >= start) {
                        max = Math.max(max, 1);
                        for (let i = start; i < end; ++i) {
                            this.code.data[i] = Opcodes.NOP;
                        }
                        this.code.data[end] = (Opcodes.ATHROW | 0);
                        let frameIndex = this.startFrame(start, 0, 1);
                        assert(this.frame);
                        this.frame[frameIndex] = Frame.OBJECT_$LI$() | this.cw.addType("java/lang/Throwable");
                        this.endFrame();
                        this.firstHandler = Handler.remove(this.firstHandler, l, k);
                    }
                }
                l = l.successor;
            }
            handler = this.firstHandler;
            this.handlerCount = 0;
            while ((handler != null)) {
                this.handlerCount += 1;
                handler = handler.next;
            }
            this.maxStack = max;
        }
        else if (this.compute === MethodWriter.MAXS) {
            let handler = this.firstHandler;
            while ((handler != null)) {
                let l = handler.start;
                let h = handler.handler;
                let e = handler.end;
                while ((l !== e)) {
                    let b = new Edge();
                    b.info = Edge.EXCEPTION;
                    b.successor = h;
                    if ((l.status & Label.JSR) === 0) {
                        b.next = l.successors;
                        l.successors = b;
                    }
                    else {
                        b.next = l.successors.next.next;
                        l.successors.next.next = b;
                    }
                    l = l.successor;
                }
                handler = handler.next;
            }
            if (this.subroutines > 0) {
                let id = 0;
                assert(this.labels);
                this.labels.visitSubroutine(null, 1, this.subroutines);
                let l = this.labels;
                while ((l != null)) {
                    if ((l.status & Label.JSR) !== 0) {
                        let subroutine = l.successors.next.successor;
                        assert(subroutine);
                        if ((subroutine.status & Label.VISITED) === 0) {
                            id += 1;
                            subroutine.visitSubroutine(null, (Math.round(id / 32)) << 32 | (1 << (id % 32)), this.subroutines);
                        }
                    }
                    l = l.successor;
                }
                l = this.labels;
                while ((l != null)) {
                    if ((l.status & Label.JSR) !== 0) {
                        let L = this.labels;
                        while ((L != null)) {
                            L.status &= ~Label.VISITED2;
                            L = L.successor;
                        }
                        let subroutine = l.successors.next.successor;
                        subroutine.visitSubroutine(l, 0, this.subroutines);
                    }
                    l = l.successor;
                }
            }
            let max = 0;
            let stack = this.labels;
            while ((stack != null)) {
                let l = stack;
                stack = stack.next;
                let start = l.inputStackTop;
                let blockMax = start + l.outputStackMax;
                if (blockMax > max) {
                    max = blockMax;
                }
                let b = l.successors;
                if ((l.status & Label.JSR) !== 0) {
                    b = b.next;
                }
                while ((b != null)) {
                    l = b.successor;
                    if (l && (l.status & Label.PUSHED) === 0) {
                        l.inputStackTop = b.info === Edge.EXCEPTION ? 1 : start + b.info;
                        l.status |= Label.PUSHED;
                        l.next = stack;
                        stack = l;
                    }
                    b = b.next;
                }
            }
            this.maxStack = Math.max(maxStack, max);
        }
        else {
            this.maxStack = maxStack;
            this.maxLocals = maxLocals;
        }
    }
    visitEnd() {
    }
    /**
     * Adds a successor to the {@link #currentBlock currentBlock} block.
     *
     * @param info
     * information about the control flow edge to be added.
     * @param successor
     * the successor block to be added to the current block.
     */
    addSuccessor(info, successor) {
        let b = new Edge();
        b.info = info;
        b.successor = successor;
        assert(this.currentBlock);
        b.next = this.currentBlock.successors;
        this.currentBlock.successors = b;
    }
    /**
     * Ends the current basic block. This method must be used in the case where
     * the current basic block does not have any successor.
     */
    noSuccessor() {
        if (this.compute === MethodWriter.FRAMES) {
            let l = new Label();
            l.frame = new Frame(l);
            l.resolve(this, this.code.length, this.code.data);
            this.previousBlock.successor = l;
            this.previousBlock = l;
        }
        else {
            assert(this.currentBlock);
            this.currentBlock.outputStackMax = this.maxStackSize;
        }
        if (this.compute !== MethodWriter.INSERTED_FRAMES) {
            this.currentBlock = null;
        }
    }
    /**
     * Visits a frame that has been computed from scratch.
     *
     * @param f
     * the frame that must be visited.
     */
    visitFrame$Frame(f) {
        let i;
        let t;
        let nTop = 0;
        let nLocal = 0;
        let nStack = 0;
        let locals = f.inputLocals;
        let stacks = f.inputStack;
        for (i = 0; i < locals.length; ++i) {
            t = locals[i];
            if (t === Frame.TOP_$LI$()) {
                ++nTop;
            }
            else {
                nLocal += nTop + 1;
                nTop = 0;
            }
            if (t === Frame.LONG_$LI$() || t === Frame.DOUBLE_$LI$()) {
                ++i;
            }
        }
        for (i = 0; i < stacks.length; ++i) {
            t = stacks[i];
            ++nStack;
            if (t === Frame.LONG_$LI$() || t === Frame.DOUBLE_$LI$()) {
                ++i;
            }
        }
        let frameIndex = this.startFrame(f.owner.position, nLocal, nStack);
        assert(this.frame);
        for (i = 0; nLocal > 0; ++i, --nLocal) {
            t = locals[i];
            this.frame[frameIndex++] = t;
            if (t === Frame.LONG_$LI$() || t === Frame.DOUBLE_$LI$()) {
                ++i;
            }
        }
        for (i = 0; i < stacks.length; ++i) {
            t = stacks[i];
            this.frame[frameIndex++] = t;
            if (t === Frame.LONG_$LI$() || t === Frame.DOUBLE_$LI$()) {
                ++i;
            }
        }
        this.endFrame();
    }
    /**
     * Visit the implicit first frame of this method.
     */
    visitImplicitFirstFrame() {
        assert(this.frame);
        let frameIndex = this.startFrame(0, this.descriptor.length + 1, 0);
        if ((this.access & Opcodes.ACC_STATIC) === 0) {
            if ((this.access & MethodWriter.ACC_CONSTRUCTOR) === 0) {
                this.frame[frameIndex++] = Frame.OBJECT_$LI$() | this.cw.addType(this.cw.thisName);
            }
            else {
                this.frame[frameIndex++] = 6;
            }
        }
        let i = 1;
        loop: while ((true)) {
            let j = i;
            switch ((this.descriptor.charAt(i++))) {
                case "Z":
                case "C":
                case "B":
                case "S":
                case "I":
                    this.frame[frameIndex++] = 1;
                    break;
                case "F":
                    this.frame[frameIndex++] = 2;
                    break;
                case "J":
                    this.frame[frameIndex++] = 4;
                    break;
                case "D":
                    this.frame[frameIndex++] = 3;
                    break;
                case "[":
                    while ((this.descriptor.charAt(i) === "[")) {
                        ++i;
                    }
                    if (this.descriptor.charAt(i) === "L") {
                        ++i;
                        while ((this.descriptor.charAt(i) !== ";")) {
                            ++i;
                        }
                    }
                    this.frame[frameIndex++] = Frame.OBJECT_$LI$() | this.cw.addType(this.descriptor.substring(j, ++i));
                    break;
                case "L":
                    while ((this.descriptor.charAt(i) !== ";")) {
                        ++i;
                    }
                    this.frame[frameIndex++] = Frame.OBJECT_$LI$() | this.cw.addType(this.descriptor.substring(j + 1, i++));
                    break;
                default:
                    break loop;
            }
        }
        this.frame[1] = frameIndex - 3;
        this.endFrame();
    }
    /**
     * Starts the visit of a stack map frame.
     *
     * @param offset
     * the offset of the instruction to which the frame corresponds.
     * @param nLocal
     * the number of local variables in the frame.
     * @param nStack
     * the number of stack elements in the frame.
     * @return the index of the next element to be written in this frame.
     */
    startFrame(offset, nLocal, nStack) {
        let n = 3 + nLocal + nStack;
        if (this.frame == null || this.frame.length < n) {
            this.frame = new Array(n);
        }
        this.frame[0] = offset;
        this.frame[1] = nLocal;
        this.frame[2] = nStack;
        return 3;
    }
    /**
     * Checks if the visit of the current frame {@link #frame} is finished, and
     * if yes, write it in the StackMapTable attribute.
     */
    endFrame() {
        if (this.previousFrame != null) {
            if (this.stackMap == null) {
                this.stackMap = new ByteVector();
            }
            this.writeFrame();
            ++this.frameCount;
        }
        this.previousFrame = this.frame;
        this.frame = null;
    }
    /**
     * Compress and writes the current frame {@link #frame} in the StackMapTable
     * attribute.
     */
    writeFrame() {
        assert(this.frame);
        assert(this.previousFrame);
        assert(this.stackMap);
        let clocalsSize = this.frame[1];
        let cstackSize = this.frame[2];
        if ((this.cw.version & 65535) < Opcodes.V1_6) {
            this.stackMap.putShort(this.frame[0]).putShort(clocalsSize);
            this.writeFrameTypes(3, 3 + clocalsSize);
            this.stackMap.putShort(cstackSize);
            this.writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);
            return;
        }
        let localsSize = this.previousFrame[1];
        let type = MethodWriter.FULL_FRAME;
        let k = 0;
        let delta;
        if (this.frameCount === 0) {
            delta = this.frame[0];
        }
        else {
            delta = this.frame[0] - this.previousFrame[0] - 1;
        }
        if (cstackSize === 0) {
            k = clocalsSize - localsSize;
            switch ((k)) {
                case -3:
                case -2:
                case -1:
                    type = MethodWriter.CHOP_FRAME;
                    localsSize = clocalsSize;
                    break;
                case 0:
                    type = delta < 64 ? MethodWriter.SAME_FRAME : MethodWriter.SAME_FRAME_EXTENDED;
                    break;
                case 1:
                case 2:
                case 3:
                    type = MethodWriter.APPEND_FRAME;
                    break;
            }
        }
        else if (clocalsSize === localsSize && cstackSize === 1) {
            type = delta < 63 ? MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME : MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
        }
        if (type !== MethodWriter.FULL_FRAME) {
            let l = 3;
            for (let j = 0; j < localsSize; j++) {
                if (this.frame[l] !== this.previousFrame[l]) {
                    type = MethodWriter.FULL_FRAME;
                    break;
                }
                l++;
            }
        }
        switch ((type)) {
            case MethodWriter.SAME_FRAME:
                this.stackMap.putByte(delta);
                break;
            case MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME:
                this.stackMap.putByte(MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME + delta);
                this.writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);
                break;
            case MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
                this.stackMap.putByte(MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(delta);
                this.writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);
                break;
            case MethodWriter.SAME_FRAME_EXTENDED:
                this.stackMap.putByte(MethodWriter.SAME_FRAME_EXTENDED).putShort(delta);
                break;
            case MethodWriter.CHOP_FRAME:
                this.stackMap.putByte(MethodWriter.SAME_FRAME_EXTENDED + k).putShort(delta);
                break;
            case MethodWriter.APPEND_FRAME:
                this.stackMap.putByte(MethodWriter.SAME_FRAME_EXTENDED + k).putShort(delta);
                this.writeFrameTypes(3 + localsSize, 3 + clocalsSize);
                break;
            default:
                this.stackMap.putByte(MethodWriter.FULL_FRAME).putShort(delta).putShort(clocalsSize);
                this.writeFrameTypes(3, 3 + clocalsSize);
                this.stackMap.putShort(cstackSize);
                this.writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);
        }
    }
    /**
     * Writes some types of the current frame {@link #frame} into the
     * StackMapTableAttribute. This method converts types from the format used
     * in {@link Label} to the format used in StackMapTable attributes. In
     * particular, it converts type table indexes to constant pool indexes.
     *
     * @param start
     * index of the first type in {@link #frame} to write.
     * @param end
     * index of last type in {@link #frame} to write (exclusive).
     */
    writeFrameTypes(start, end) {
        assert(this.frame);
        assert(this.stackMap);
        for (let i = start; i < end; ++i) {
            let t = this.frame[i];
            let d = t & Frame.DIM;
            if (d === 0) {
                let v = t & Frame.BASE_VALUE;
                switch ((t & Frame.BASE_KIND)) {
                    case Frame.OBJECT_$LI$():
                        this.stackMap.putByte(7).putShort(this.cw.newClass(this.cw.typeTable[v].strVal1));
                        break;
                    case Frame.UNINITIALIZED_$LI$():
                        this.stackMap.putByte(8).putShort(this.cw.typeTable[v].intVal);
                        break;
                    default:
                        this.stackMap.putByte(v);
                }
            }
            else {
                let sb = "";
                d >>= 28;
                while ((d-- > 0)) {
                    sb += "[";
                }
                if ((t & Frame.BASE_KIND) === Frame.OBJECT_$LI$()) {
                    sb += "L";
                    sb += this.cw.typeTable[t & Frame.BASE_VALUE].strVal1;
                    sb += ";";
                }
                else {
                    switch ((t & 15)) {
                        case 1:
                            sb += "I";
                            break;
                        case 2:
                            sb += "F";
                            break;
                        case 3:
                            sb += "D";
                            break;
                        case 9:
                            sb += "Z";
                            break;
                        case 10:
                            sb += "B";
                            break;
                        case 11:
                            sb += "C";
                            break;
                        case 12:
                            sb += "S";
                            break;
                        default:
                            sb += "J";
                    }
                }
                this.stackMap.putByte(7).putShort(this.cw.newClass(sb.toString()));
            }
        }
    }
    writeFrameType(type) {
        assert(this.stackMap);
        if (typeof type === "string") {
            this.stackMap.putByte(7).putShort(this.cw.newClass(type));
        }
        else if (typeof type === "number") {
            this.stackMap.putByte(/* intValue */ ((type) | 0));
        }
        else {
            this.stackMap.putByte(8).putShort(type.position);
        }
    }
    /**
     * Returns the size of the bytecode of this method.
     *
     * @return the size of the bytecode of this method.
     */
    getSize() {
        if (this.classReaderOffset !== 0) {
            return 6 + this.classReaderLength;
        }
        let size = 8;
        if (this.code.length > 0) {
            if (this.code.length > 65535) {
                throw new Error("Method code too large!");
            }
            this.cw.newUTF8("Code");
            size += 18 + this.code.length + 8 * this.handlerCount;
            if (this.localVar != null) {
                this.cw.newUTF8("LocalVariableTable");
                size += 8 + this.localVar.length;
            }
            if (this.localVarType != null) {
                this.cw.newUTF8("LocalVariableTypeTable");
                size += 8 + this.localVarType.length;
            }
            if (this.lineNumber != null) {
                this.cw.newUTF8("LineNumberTable");
                size += 8 + this.lineNumber.length;
            }
            if (this.stackMap != null) {
                let zip = (this.cw.version & 65535) >= Opcodes.V1_6;
                this.cw.newUTF8(zip ? "StackMapTable" : "StackMap");
                size += 8 + this.stackMap.length;
            }
            if (ClassReader.ANNOTATIONS && this.ctanns != null) {
                this.cw.newUTF8("RuntimeVisibleTypeAnnotations");
                size += 8 + this.ctanns.getSize();
            }
            if (ClassReader.ANNOTATIONS && this.ictanns != null) {
                this.cw.newUTF8("RuntimeInvisibleTypeAnnotations");
                size += 8 + this.ictanns.getSize();
            }
            if (this.cattrs != null) {
                size += this.cattrs.getSize(this.cw, this.code.data, this.code.length, this.maxStack, this.maxLocals);
            }
        }
        if (this.exceptionCount > 0) {
            this.cw.newUTF8("Exceptions");
            size += 8 + 2 * this.exceptionCount;
        }
        if ((this.access & Opcodes.ACC_SYNTHETIC) !== 0) {
            if ((this.cw.version & 65535) < Opcodes.V1_5 || (this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) !== 0) {
                this.cw.newUTF8("Synthetic");
                size += 6;
            }
        }
        if ((this.access & Opcodes.ACC_DEPRECATED) !== 0) {
            this.cw.newUTF8("Deprecated");
            size += 6;
        }
        if (ClassReader.SIGNATURES && this.signature != null) {
            this.cw.newUTF8("Signature");
            this.cw.newUTF8(this.signature);
            size += 8;
        }
        if (this.methodParameters != null) {
            this.cw.newUTF8("MethodParameters");
            size += 7 + this.methodParameters.length;
        }
        if (ClassReader.ANNOTATIONS && this.annd != null) {
            this.cw.newUTF8("AnnotationDefault");
            size += 6 + this.annd.length;
        }
        if (ClassReader.ANNOTATIONS && this.anns != null) {
            this.cw.newUTF8("RuntimeVisibleAnnotations");
            size += 8 + this.anns.getSize();
        }
        if (ClassReader.ANNOTATIONS && this.ianns != null) {
            this.cw.newUTF8("RuntimeInvisibleAnnotations");
            size += 8 + this.ianns.getSize();
        }
        if (ClassReader.ANNOTATIONS && this.tanns != null) {
            this.cw.newUTF8("RuntimeVisibleTypeAnnotations");
            size += 8 + this.tanns.getSize();
        }
        if (ClassReader.ANNOTATIONS && this.itanns != null) {
            this.cw.newUTF8("RuntimeInvisibleTypeAnnotations");
            size += 8 + this.itanns.getSize();
        }
        if (ClassReader.ANNOTATIONS && this.panns != null) {
            this.cw.newUTF8("RuntimeVisibleParameterAnnotations");
            size += 7 + 2 * (this.panns.length - this.synthetics);
            for (let i = this.panns.length - 1; i >= this.synthetics; --i) {
                size += this.panns[i] == null ? 0 : this.panns[i].getSize();
            }
        }
        if (ClassReader.ANNOTATIONS && this.ipanns != null) {
            this.cw.newUTF8("RuntimeInvisibleParameterAnnotations");
            size += 7 + 2 * (this.ipanns.length - this.synthetics);
            for (let i = this.ipanns.length - 1; i >= this.synthetics; --i) {
                size += this.ipanns[i] == null ? 0 : this.ipanns[i].getSize();
            }
        }
        if (this.attrs != null) {
            size += this.attrs.getSize(this.cw, null, 0, -1, -1);
        }
        return size;
    }
    /**
     * Puts the bytecode of this method in the given byte vector.
     *
     * @param out
     * the byte vector into which the bytecode of this method must be
     * copied.
     */
    put(out) {
        let FACTOR = ClassWriter.TO_ACC_SYNTHETIC_$LI$();
        let mask = MethodWriter.ACC_CONSTRUCTOR | Opcodes.ACC_DEPRECATED | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE | (((this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / FACTOR | 0));
        out.putShort(this.access & ~mask).putShort(this.name).putShort(this.desc);
        if (this.classReaderOffset !== 0) {
            out.putByteArray(this.cw.cr.buf, this.classReaderOffset, this.classReaderLength);
            return;
        }
        let attributeCount = 0;
        if (this.code.length > 0) {
            ++attributeCount;
        }
        if (this.exceptionCount > 0) {
            ++attributeCount;
        }
        if ((this.access & Opcodes.ACC_SYNTHETIC) !== 0) {
            if ((this.cw.version & 65535) < Opcodes.V1_5 || (this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) !== 0) {
                ++attributeCount;
            }
        }
        if ((this.access & Opcodes.ACC_DEPRECATED) !== 0) {
            ++attributeCount;
        }
        if (ClassReader.SIGNATURES && this.signature != null) {
            ++attributeCount;
        }
        if (this.methodParameters != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.annd != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.anns != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.ianns != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.tanns != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.itanns != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.panns != null) {
            ++attributeCount;
        }
        if (ClassReader.ANNOTATIONS && this.ipanns != null) {
            ++attributeCount;
        }
        if (this.attrs != null) {
            attributeCount += this.attrs.getCount();
        }
        out.putShort(attributeCount);
        if (this.code.length > 0) {
            let size = 12 + this.code.length + 8 * this.handlerCount;
            if (this.localVar != null) {
                size += 8 + this.localVar.length;
            }
            if (this.localVarType != null) {
                size += 8 + this.localVarType.length;
            }
            if (this.lineNumber != null) {
                size += 8 + this.lineNumber.length;
            }
            if (this.stackMap != null) {
                size += 8 + this.stackMap.length;
            }
            if (ClassReader.ANNOTATIONS && this.ctanns != null) {
                size += 8 + this.ctanns.getSize();
            }
            if (ClassReader.ANNOTATIONS && this.ictanns != null) {
                size += 8 + this.ictanns.getSize();
            }
            if (this.cattrs != null) {
                size += this.cattrs.getSize(this.cw, this.code.data, this.code.length, this.maxStack, this.maxLocals);
            }
            out.putShort(this.cw.newUTF8("Code")).putInt(size);
            out.putShort(this.maxStack).putShort(this.maxLocals);
            out.putInt(this.code.length).putByteArray(this.code.data, 0, this.code.length);
            out.putShort(this.handlerCount);
            if (this.handlerCount > 0) {
                let h = this.firstHandler;
                while ((h != null)) {
                    out.putShort(h.start.position).putShort(h.end.position).putShort(h.handler.position).putShort(h.type);
                    h = h.next;
                }
            }
            attributeCount = 0;
            if (this.localVar != null) {
                ++attributeCount;
            }
            if (this.localVarType != null) {
                ++attributeCount;
            }
            if (this.lineNumber != null) {
                ++attributeCount;
            }
            if (this.stackMap != null) {
                ++attributeCount;
            }
            if (ClassReader.ANNOTATIONS && this.ctanns != null) {
                ++attributeCount;
            }
            if (ClassReader.ANNOTATIONS && this.ictanns != null) {
                ++attributeCount;
            }
            if (this.cattrs != null) {
                attributeCount += this.cattrs.getCount();
            }
            out.putShort(attributeCount);
            if (this.localVar != null) {
                out.putShort(this.cw.newUTF8("LocalVariableTable"));
                out.putInt(this.localVar.length + 2).putShort(this.localVarCount);
                out.putByteArray(this.localVar.data, 0, this.localVar.length);
            }
            if (this.localVarType != null) {
                out.putShort(this.cw.newUTF8("LocalVariableTypeTable"));
                out.putInt(this.localVarType.length + 2).putShort(this.localVarTypeCount);
                out.putByteArray(this.localVarType.data, 0, this.localVarType.length);
            }
            if (this.lineNumber != null) {
                out.putShort(this.cw.newUTF8("LineNumberTable"));
                out.putInt(this.lineNumber.length + 2).putShort(this.lineNumberCount);
                out.putByteArray(this.lineNumber.data, 0, this.lineNumber.length);
            }
            if (this.stackMap != null) {
                let zip = (this.cw.version & 65535) >= Opcodes.V1_6;
                out.putShort(this.cw.newUTF8(zip ? "StackMapTable" : "StackMap"));
                out.putInt(this.stackMap.length + 2).putShort(this.frameCount);
                out.putByteArray(this.stackMap.data, 0, this.stackMap.length);
            }
            if (ClassReader.ANNOTATIONS && this.ctanns != null) {
                out.putShort(this.cw.newUTF8("RuntimeVisibleTypeAnnotations"));
                this.ctanns.put(out);
            }
            if (ClassReader.ANNOTATIONS && this.ictanns != null) {
                out.putShort(this.cw.newUTF8("RuntimeInvisibleTypeAnnotations"));
                this.ictanns.put(out);
            }
            if (this.cattrs != null) {
                this.cattrs.put(this.cw, this.code.data, this.code.length, this.maxLocals, this.maxStack, out);
            }
        }
        if (this.exceptionCount > 0) {
            assert(this.exceptions);
            out.putShort(this.cw.newUTF8("Exceptions")).putInt(2 * this.exceptionCount + 2);
            out.putShort(this.exceptionCount);
            for (let i = 0; i < this.exceptionCount; ++i) {
                out.putShort(this.exceptions[i]);
            }
        }
        if ((this.access & Opcodes.ACC_SYNTHETIC) !== 0) {
            if ((this.cw.version & 65535) < Opcodes.V1_5 || (this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) !== 0) {
                out.putShort(this.cw.newUTF8("Synthetic")).putInt(0);
            }
        }
        if ((this.access & Opcodes.ACC_DEPRECATED) !== 0) {
            out.putShort(this.cw.newUTF8("Deprecated")).putInt(0);
        }
        if (ClassReader.SIGNATURES && this.signature != null) {
            out.putShort(this.cw.newUTF8("Signature")).putInt(2).putShort(this.cw.newUTF8(this.signature));
        }
        if (this.methodParameters != null) {
            out.putShort(this.cw.newUTF8("MethodParameters"));
            out.putInt(this.methodParameters.length + 1).putByte(this.methodParametersCount);
            out.putByteArray(this.methodParameters.data, 0, this.methodParameters.length);
        }
        if (ClassReader.ANNOTATIONS && this.annd != null) {
            out.putShort(this.cw.newUTF8("AnnotationDefault"));
            out.putInt(this.annd.length);
            out.putByteArray(this.annd.data, 0, this.annd.length);
        }
        if (ClassReader.ANNOTATIONS && this.anns != null) {
            out.putShort(this.cw.newUTF8("RuntimeVisibleAnnotations"));
            this.anns.put(out);
        }
        if (ClassReader.ANNOTATIONS && this.ianns != null) {
            out.putShort(this.cw.newUTF8("RuntimeInvisibleAnnotations"));
            this.ianns.put(out);
        }
        if (ClassReader.ANNOTATIONS && this.tanns != null) {
            out.putShort(this.cw.newUTF8("RuntimeVisibleTypeAnnotations"));
            this.tanns.put(out);
        }
        if (ClassReader.ANNOTATIONS && this.itanns != null) {
            out.putShort(this.cw.newUTF8("RuntimeInvisibleTypeAnnotations"));
            this.itanns.put(out);
        }
        if (ClassReader.ANNOTATIONS && this.panns != null) {
            out.putShort(this.cw.newUTF8("RuntimeVisibleParameterAnnotations"));
            AnnotationWriter.put(this.panns, this.synthetics, out);
        }
        if (ClassReader.ANNOTATIONS && this.ipanns != null) {
            out.putShort(this.cw.newUTF8("RuntimeInvisibleParameterAnnotations"));
            AnnotationWriter.put(this.ipanns, this.synthetics, out);
        }
        if (this.attrs != null) {
            this.attrs.put(this.cw, null, 0, -1, -1, out);
        }
    }
}
/**
 * Pseudo access flag used to denote constructors.
 */
MethodWriter.ACC_CONSTRUCTOR = 524288;
/**
 * Frame has exactly the same locals as the previous stack map frame and
 * number of stack items is zero.
 */
MethodWriter.SAME_FRAME = 0;
/**
 * Frame has exactly the same locals as the previous stack map frame and
 * number of stack items is 1
 */
MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME = 64;
/**
 * Reserved for future use
 */
MethodWriter.RESERVED = 128;
/**
 * Frame has exactly the same locals as the previous stack map frame and
 * number of stack items is 1. Offset is bigger then 63;
 */
MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;
/**
 * Frame where current locals are the same as the locals in the previous
 * frame, except that the k last locals are absent. The value of k is given
 * by the formula 251-frame_type.
 */
MethodWriter.CHOP_FRAME = 248;
/**
 * Frame has exactly the same locals as the previous stack map frame and
 * number of stack items is zero. Offset is bigger then 63;
 */
MethodWriter.SAME_FRAME_EXTENDED = 251;
/**
 * Frame where current locals are the same as the locals in the previous
 * frame, except that k additional locals are defined. The value of k is
 * given by the formula frame_type-251.
 */
MethodWriter.APPEND_FRAME = 252;
/**
 * Full frame
 */
MethodWriter.FULL_FRAME = 255;
/**
 * Indicates that the stack map frames must be recomputed from scratch. In
 * this case the maximum stack size and number of local variables is also
 * recomputed from scratch.
 *
 * @see #compute
 */
MethodWriter.FRAMES = 0;
/**
 * Indicates that the stack map frames of type F_INSERT must be computed.
 * The other frames are not (re)computed. They should all be of type F_NEW
 * and should be sufficient to compute the content of the F_INSERT frames,
 * together with the bytecode instructions between a F_NEW and a F_INSERT
 * frame - and without any knowledge of the type hierarchy (by definition of
 * F_INSERT).
 *
 * @see #compute
 */
MethodWriter.INSERTED_FRAMES = 1;
/**
 * Indicates that the maximum stack size and number of local variables must
 * be automatically computed.
 *
 * @see #compute
 */
MethodWriter.MAXS = 2;
/**
 * Indicates that nothing must be automatically computed.
 *
 * @see #compute
 */
MethodWriter.NOTHING = 3;
class Handler {
    constructor() {
        /**
         * Beginning of the exception handler's scope (inclusive).
         */
        this.start = null;
        /**
         * End of the exception handler's scope (exclusive).
         */
        this.end = null;
        /**
         * Beginning of the exception handler's code.
         */
        this.handler = null;
        /**
         * Internal name of the type of exceptions handled by this handler, or
         * <tt>null</tt> to catch any exceptions.
         */
        this.desc = "";
        /**
         * Next exception handler block info.
         */
        this.next = null;
        this.type = 0;
    }
    /**
     * Removes the range between start and end from the given exception
     * handlers.
     *
     * @param h
     * an exception handler list.
     * @param start
     * the start of the range to be removed.
     * @param end
     * the end of the range to be removed. Maybe null.
     * @return the exception handler list with the start-end range removed.
     */
    static remove(h, start, end) {
        if (h == null) {
            return null;
        }
        else {
            h.next = Handler.remove(h.next, start, end);
        }
        assert(h.start);
        assert(h.end);
        let hstart = h.start.position;
        let hend = h.end.position;
        let s = start.position;
        // let e : number = end == null?javaemul.internal.IntegerHelper.MAX_VALUE:end.position;
        let e = end == null ? Number.MAX_VALUE : end.position;
        if (s < hend && e > hstart) {
            if (s <= hstart) {
                if (e >= hend) {
                    h = h.next;
                }
                else {
                    h.start = end;
                }
            }
            else if (e >= hend) {
                h.end = start;
            }
            else {
                let g = new Handler();
                g.start = end;
                g.end = h.end;
                g.handler = h.handler;
                g.desc = h.desc;
                g.type = h.type;
                g.next = h.next;
                h.end = start;
                h.next = g;
            }
        }
        return h;
    }
}

// @ts-nocheck
class ClassWriter extends ClassVisitor {
    /**
     * Constructs a new {@link ClassWriter} object and enables optimizations for
     * "mostly add" bytecode transformations. These optimizations are the
     * following:
     *
     * <ul>
     * <li>The constant pool from the original class is copied as is in the new
     * class, which saves time. New constant pool entries will be added at the
     * end if necessary, but unused constant pool entries <i>won't be
     * removed</i>.</li>
     * <li>Methods that are not transformed are copied as is in the new class,
     * directly from the original class bytecode (i.e. without emitting visit
     * events for all the method instructions), which saves a <i>lot</i> of
     * time. Untransformed methods are detected by the fact that the
     * {@link ClassReader} receives {@link MethodVisitor} objects that come from
     * a {@link ClassWriter} (and not from any other {@link ClassVisitor}
     * instance).</li>
     * </ul>
     *
     * @param classReader
     * the {@link ClassReader} used to read the original class. It
     * will be used to copy the entire constant pool from the
     * original class and also to copy other fragments of original
     * bytecode where applicable.
     * @param flags
     * option flags that can be used to modify the default behavior
     * of this class. <i>These option flags do not affect methods
     * that are copied as is in the new class. This means that
     * neither the maximum stack size nor the stack frames will be
     * computed for these methods</i>. See {@link #COMPUTE_MAXS},
     * {@link #COMPUTE_FRAMES}.
     */
    constructor(classReader, flags) {
        if (((classReader != null && classReader instanceof ClassReader) || classReader === null) && ((typeof flags === "number") || flags === null)) {
            let __args = Array.prototype.slice.call(arguments);
            {
                throw new Error("not supported");
                // let __args = Array.prototype.slice.call(arguments);
                // super(Opcodes.ASM5);
                // this.version = 0;
                // this.index = 0;
                // this.threshold = 0;
                // this.typeCount = 0;
                // this.access = 0;
                // this.name = 0;
                // this.signature = 0;
                // this.superName = 0;
                // this.interfaceCount = 0;
                // this.sourceFile = 0;
                // this.enclosingMethodOwner = 0;
                // this.enclosingMethod = 0;
                // this.innerClassesCount = 0;
                // this.bootstrapMethodsCount = 0;
                // this.compute = 0;
                // this.hasAsmInsns = false;
                // (() => {
                //     this.index = 1;
                //     this.pool = new ByteVector();
                //     this.items = new Array(256);
                //     this.threshold = (<number>(0.75 * this.items.length) | 0);
                //     // this.key = new Item();
                //     // this.key2 = new Item();
                //     // this.key3 = new Item();
                //     // this.key4 = new Item();
                //     this.compute = (flags & ClassWriter.COMPUTE_FRAMES) !== 0 ? MethodWriter.FRAMES : ((flags & ClassWriter.COMPUTE_MAXS) !== 0 ? MethodWriter.MAXS : MethodWriter.NOTHING);
                // })();
            }
            // (() => {
            //     classReader.copyPool(this);
            //     this.cr = classReader;
            // })();
        }
        else if (((typeof classReader === "number") || classReader === null) && flags === undefined) {
            let __args = Array.prototype.slice.call(arguments);
            let flags = __args[0];
            super(Opcodes.ASM5);
            this.version = 0;
            this.index = 0;
            this.threshold = 0;
            this.typeCount = 0;
            this.access = 0;
            this.name = 0;
            this.signature = 0;
            this.superName = 0;
            this.interfaceCount = 0;
            this.sourceFile = 0;
            this.enclosingMethodOwner = 0;
            this.enclosingMethod = 0;
            this.innerClassesCount = 0;
            this.bootstrapMethodsCount = 0;
            this.compute = 0;
            this.hasAsmInsns = false;
            (() => {
                this.index = 1;
                this.pool = new ByteVector();
                this.items = new Array(256);
                this.threshold = ((0.75 * this.items.length) | 0);
                // this.key = new Item();
                // this.key2 = new Item();
                // this.key3 = new Item();
                // this.key4 = new Item();
                this.compute = (flags & ClassWriter.COMPUTE_FRAMES) !== 0 ? MethodWriter.FRAMES : ((flags & ClassWriter.COMPUTE_MAXS) !== 0 ? MethodWriter.MAXS : MethodWriter.NOTHING);
            })();
        }
        else {
            throw new Error("invalid overload");
        }
    }
    static __static_initialize() { if (!ClassWriter.__static_initialized) {
        ClassWriter.__static_initialized = true;
        ClassWriter.__static_initializer_0();
    } }
    static TO_ACC_SYNTHETIC_$LI$() { ClassWriter.__static_initialize(); if (ClassWriter.TO_ACC_SYNTHETIC == null) {
        ClassWriter.TO_ACC_SYNTHETIC = (ClassWriter.ACC_SYNTHETIC_ATTRIBUTE / Opcodes.ACC_SYNTHETIC | 0);
    } return ClassWriter.TO_ACC_SYNTHETIC; }
    ;
    static TYPE_$LI$() { ClassWriter.__static_initialize(); return ClassWriter.TYPE; }
    ;
    static __static_initializer_0() {
        let i;
        let b = new Array(220);
        let s = "AAAAAAAAAAAAAAAABCLMMDDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAADDDDDEEEEEEEEEEEEEEEEEEEEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAJJJJJJJJJJJJJJJJDOPAAAAAAGGGGGGGHIFBFAAFFAARQJJKKSSSSSSSSSSSSSSSSSS";
        for (i = 0; i < b.length; ++i) {
            b[i] = (((s.charAt(i)).charCodeAt(0) - ("A").charCodeAt(0)) | 0);
        }
        ClassWriter.TYPE = b;
    }
    visit(version, access, name, signature, superName, interfaces) {
        this.version = version;
        this.access = access;
        this.name = this.newClass(name);
        this.thisName = name;
        if (ClassReader.SIGNATURES && signature != null) {
            this.signature = this.newUTF8(signature);
        }
        this.superName = superName == null ? 0 : this.newClass(superName);
        if (interfaces != null && interfaces.length > 0) {
            this.interfaceCount = interfaces.length;
            this.interfaces = new Array(this.interfaceCount);
            for (let i = 0; i < this.interfaceCount; ++i) {
                this.interfaces[i] = this.newClass(interfaces[i]);
            }
        }
    }
    visitSource(file, debug) {
        throw new Error("not supported");
        // if (file != null) {
        //     this.sourceFile = this.newUTF8(file);
        // }
        // if (debug != null) {
        //     this.sourceDebug = new ByteVector().encodeUTF8(debug, 0, javaemul.internal.IntegerHelper.MAX_VALUE);
        // }
    }
    visitOuterClass(owner, name, desc) {
        this.enclosingMethodOwner = this.newClass(owner);
        if (name != null && desc != null) {
            this.enclosingMethod = this.newNameType(name, desc);
        }
    }
    visitAnnotation(desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        bv.putShort(this.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this, true, bv, bv, 2);
        if (visible) {
            aw.next = this.anns;
            this.anns = aw;
        }
        else {
            aw.next = this.ianns;
            this.ianns = aw;
        }
        return aw;
    }
    visitTypeAnnotation(typeRef, typePath, desc, visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
        let bv = new ByteVector();
        AnnotationWriter.putTarget(typeRef, typePath, bv);
        bv.putShort(this.newUTF8(desc)).putShort(0);
        let aw = new AnnotationWriter(this, true, bv, bv, bv.length - 2);
        if (visible) {
            aw.next = this.tanns;
            this.tanns = aw;
        }
        else {
            aw.next = this.itanns;
            this.itanns = aw;
        }
        return aw;
    }
    visitAttribute(attr) {
        attr.next = this.attrs;
        this.attrs = attr;
    }
    visitInnerClass(name, outerName, innerName, access) {
        if (this.innerClasses == null) {
            this.innerClasses = new ByteVector();
        }
        let nameItem = this.newClassItem(name);
        if (nameItem.intVal === 0) {
            ++this.innerClassesCount;
            this.innerClasses.putShort(nameItem.index);
            this.innerClasses.putShort(outerName == null ? 0 : this.newClass(outerName));
            this.innerClasses.putShort(innerName == null ? 0 : this.newUTF8(innerName));
            this.innerClasses.putShort(access);
            nameItem.intVal = this.innerClassesCount;
        }
    }
    visitField(access, name, desc, signature, value) {
        return new FieldWriter(this, access, name, desc, signature, value);
    }
    visitMethod(access, name, desc, signature, exceptions) {
        return new MethodWriter(this, access, name, desc, signature, exceptions, this.compute);
    }
    visitEnd() {
    }
    /**
     * Returns the bytecode of the class that was build with this class writer.
     *
     * @return the bytecode of the class that was build with this class writer.
     */
    toByteArray() {
        // if (this.index > 65535) {
        //     throw new Error("Class file too large!");
        // }
        // let size: number = 24 + 2 * this.interfaceCount;
        // let nbFields: number = 0;
        // let fb: FieldWriter = this.firstField;
        // while ((fb != null)) {
        //     ++nbFields;
        //     size += fb.getSize();
        //     fb = <FieldWriter>fb.fv;
        // };
        // let nbMethods: number = 0;
        // let mb: MethodWriter = this.firstMethod;
        // while ((mb != null)) {
        //     ++nbMethods;
        //     size += mb.getSize();
        //     mb = <MethodWriter>mb.mv;
        // };
        // let attributeCount: number = 0;
        // if (this.bootstrapMethods != null) {
        //     ++attributeCount;
        //     size += 8 + this.bootstrapMethods.length;
        //     this.newUTF8("BootstrapMethods");
        // }
        // if (ClassReader.SIGNATURES && this.signature !== 0) {
        //     ++attributeCount;
        //     size += 8;
        //     this.newUTF8("Signature");
        // }
        // if (this.sourceFile !== 0) {
        //     ++attributeCount;
        //     size += 8;
        //     this.newUTF8("SourceFile");
        // }
        // if (this.sourceDebug != null) {
        //     ++attributeCount;
        //     size += this.sourceDebug.length + 6;
        //     this.newUTF8("SourceDebugExtension");
        // }
        // if (this.enclosingMethodOwner !== 0) {
        //     ++attributeCount;
        //     size += 10;
        //     this.newUTF8("EnclosingMethod");
        // }
        // if ((this.access & Opcodes.ACC_DEPRECATED) !== 0) {
        //     ++attributeCount;
        //     size += 6;
        //     this.newUTF8("Deprecated");
        // }
        // if ((this.access & Opcodes.ACC_SYNTHETIC) !== 0) {
        //     if ((this.version & 65535) < Opcodes.V1_5 || (this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) !== 0) {
        //         ++attributeCount;
        //         size += 6;
        //         this.newUTF8("Synthetic");
        //     }
        // }
        // if (this.innerClasses != null) {
        //     ++attributeCount;
        //     size += 8 + this.innerClasses.length;
        //     this.newUTF8("InnerClasses");
        // }
        // if (ClassReader.ANNOTATIONS && this.anns != null) {
        //     ++attributeCount;
        //     size += 8 + this.anns.getSize();
        //     this.newUTF8("RuntimeVisibleAnnotations");
        // }
        // if (ClassReader.ANNOTATIONS && this.ianns != null) {
        //     ++attributeCount;
        //     size += 8 + this.ianns.getSize();
        //     this.newUTF8("RuntimeInvisibleAnnotations");
        // }
        // if (ClassReader.ANNOTATIONS && this.tanns != null) {
        //     ++attributeCount;
        //     size += 8 + this.tanns.getSize();
        //     this.newUTF8("RuntimeVisibleTypeAnnotations");
        // }
        // if (ClassReader.ANNOTATIONS && this.itanns != null) {
        //     ++attributeCount;
        //     size += 8 + this.itanns.getSize();
        //     this.newUTF8("RuntimeInvisibleTypeAnnotations");
        // }
        // if (this.attrs != null) {
        //     attributeCount += this.attrs.getCount();
        //     size += this.attrs.getSize(this, null, 0, -1, -1);
        // }
        // size += this.pool.length;
        // let out: ByteVector = new ByteVector(size);
        // out.putInt(-889275714).putInt(this.version);
        // out.putShort(this.index).putByteArray(this.pool.data, 0, this.pool.length);
        // let mask: number = Opcodes.ACC_DEPRECATED | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE | (((this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / ClassWriter.TO_ACC_SYNTHETIC_$LI$() | 0));
        // out.putShort(this.access & ~mask).putShort(this.name).putShort(this.superName);
        // out.putShort(this.interfaceCount);
        // for (let i: number = 0; i < this.interfaceCount; ++i) {
        //     out.putShort(this.interfaces[i]);
        // }
        // out.putShort(nbFields);
        // fb = this.firstField;
        // while ((fb != null)) {
        //     fb.put(out);
        //     fb = <FieldWriter>fb.fv;
        // };
        // out.putShort(nbMethods);
        // mb = this.firstMethod;
        // while ((mb != null)) {
        //     mb.put(out);
        //     mb = <MethodWriter>mb.mv;
        // };
        // out.putShort(attributeCount);
        // if (this.bootstrapMethods != null) {
        //     out.putShort(this.newUTF8("BootstrapMethods"));
        //     out.putInt(this.bootstrapMethods.length + 2).putShort(this.bootstrapMethodsCount);
        //     out.putByteArray(this.bootstrapMethods.data, 0, this.bootstrapMethods.length);
        // }
        // if (ClassReader.SIGNATURES && this.signature !== 0) {
        //     out.putShort(this.newUTF8("Signature")).putInt(2).putShort(this.signature);
        // }
        // if (this.sourceFile !== 0) {
        //     out.putShort(this.newUTF8("SourceFile")).putInt(2).putShort(this.sourceFile);
        // }
        // if (this.sourceDebug != null) {
        //     let len: number = this.sourceDebug.length;
        //     out.putShort(this.newUTF8("SourceDebugExtension")).putInt(len);
        //     out.putByteArray(this.sourceDebug.data, 0, len);
        // }
        // if (this.enclosingMethodOwner !== 0) {
        //     out.putShort(this.newUTF8("EnclosingMethod")).putInt(4);
        //     out.putShort(this.enclosingMethodOwner).putShort(this.enclosingMethod);
        // }
        // if ((this.access & Opcodes.ACC_DEPRECATED) !== 0) {
        //     out.putShort(this.newUTF8("Deprecated")).putInt(0);
        // }
        // if ((this.access & Opcodes.ACC_SYNTHETIC) !== 0) {
        //     if ((this.version & 65535) < Opcodes.V1_5 || (this.access & ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) !== 0) {
        //         out.putShort(this.newUTF8("Synthetic")).putInt(0);
        //     }
        // }
        // if (this.innerClasses != null) {
        //     out.putShort(this.newUTF8("InnerClasses"));
        //     out.putInt(this.innerClasses.length + 2).putShort(this.innerClassesCount);
        //     out.putByteArray(this.innerClasses.data, 0, this.innerClasses.length);
        // }
        // if (ClassReader.ANNOTATIONS && this.anns != null) {
        //     out.putShort(this.newUTF8("RuntimeVisibleAnnotations"));
        //     this.anns.put(out);
        // }
        // if (ClassReader.ANNOTATIONS && this.ianns != null) {
        //     out.putShort(this.newUTF8("RuntimeInvisibleAnnotations"));
        //     this.ianns.put(out);
        // }
        // if (ClassReader.ANNOTATIONS && this.tanns != null) {
        //     out.putShort(this.newUTF8("RuntimeVisibleTypeAnnotations"));
        //     this.tanns.put(out);
        // }
        // if (ClassReader.ANNOTATIONS && this.itanns != null) {
        //     out.putShort(this.newUTF8("RuntimeInvisibleTypeAnnotations"));
        //     this.itanns.put(out);
        // }
        // if (this.attrs != null) {
        //     this.attrs.put(this, null, 0, -1, -1, out);
        // }
        // if (this.hasAsmInsns) {
        //     this.anns = null;
        //     this.ianns = null;
        //     this.attrs = null;
        //     this.innerClassesCount = 0;
        //     this.innerClasses = null;
        //     this.firstField = null;
        //     this.lastField = null;
        //     this.firstMethod = null;
        //     this.lastMethod = null;
        //     this.compute = MethodWriter.INSERTED_FRAMES;
        //     this.hasAsmInsns = false;
        //     new ClassReader(out.data).accept(this, ClassReader.EXPAND_FRAMES | ClassReader.EXPAND_ASM_INSNS);
        //     return this.toByteArray();
        // }
        // return out.data;
        throw new Error("not supported");
    }
    /**
     * Adds a number or string constant to the constant pool of the class being
     * build. Does nothing if the constant pool already contains a similar item.
     *
     * @param cst
     * the value of the constant to be added to the constant pool.
     * This parameter must be an {@link Integer}, a {@link Float}, a
     * {@link Long}, a {@link Double}, a {@link String} or a
     * {@link Type}.
     * @return a new or already existing constant item with the given value.
     */
    newConstItem(cst) {
        throw new Error("unsupported");
        // if (typeof cst === 'number') {
        //     let val: number = /* intValue */((<number>cst) | 0);
        //     return this.newInteger(val);
        // } else if (typeof cst === 'number') {
        //     let val: number = /* intValue */((<number>cst) | 0);
        //     return this.newInteger(val);
        // } else if (typeof cst === 'string') {
        //     let val: number = ((<string>cst).charValue()).charCodeAt(0);
        //     return this.newInteger(val);
        // } else if (typeof cst === 'number') {
        //     let val: number = /* intValue */((<number>cst) | 0);
        //     return this.newInteger(val);
        // } else if (typeof cst === 'boolean') {
        //     let val: number = (<boolean>cst).booleanValue() ? 1 : 0;
        //     return this.newInteger(val);
        // } else if (typeof cst === 'number') {
        //     let val: number = (<number>cst).floatValue();
        //     return this.newFloat(val);
        // } else if (typeof cst === 'number') {
        //     let val: number = (<number>cst).longValue();
        //     return this.newLong(val);
        // } else if (typeof cst === 'number') {
        //     let val: number = (<number>cst).doubleValue();
        //     return this.newDouble(val);
        // } else if (typeof cst === 'string') {
        //     return this.newString(<string>cst);
        // } else if (cst != null && cst instanceof Type) {
        //     let t: Type = <Type>cst;
        //     let s: number = t.getSort();
        //     if (s === Type.OBJECT) {
        //         return this.newClassItem(t.getInternalName());
        //     } else if (s === Type.METHOD) {
        //         return this.newMethodTypeItem(t.getDescriptor());
        //     } else {
        //         return this.newClassItem(t.getDescriptor());
        //     }
        // } else if (cst != null && cst instanceof Handle) {
        //     let h: Handle = <Handle>cst;
        //     return this.newHandleItem(h.tag, h.owner, h.name, h.desc, h.itf);
        // } else {
        //     throw new Error("value " + cst);
        // }
    }
    /**
     * Adds a number or string constant to the constant pool of the class being
     * build. Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param cst
     * the value of the constant to be added to the constant pool.
     * This parameter must be an {@link Integer}, a {@link Float}, a
     * {@link Long}, a {@link Double} or a {@link String}.
     * @return the index of a new or already existing constant item with the
     * given value.
     */
    newConst(cst) {
        return this.newConstItem(cst).index;
    }
    /**
     * Adds an UTF8 string to the constant pool of the class being build. Does
     * nothing if the constant pool already contains a similar item. <i>This
     * method is intended for {@link Attribute} sub classes, and is normally not
     * needed by class generators or adapters.</i>
     *
     * @param value
     * the String value.
     * @return the index of a new or already existing UTF8 item.
     */
    newUTF8(value) {
        this.key.set(ClassWriter.UTF8, value, null, null);
        let result = this.get(this.key);
        if (result == null) {
            this.pool.putByte(ClassWriter.UTF8).putUTF8(value);
            result = new Item(this.index++, this.key);
            this.put(result);
        }
        return result.index;
    }
    /**
     * Adds a class reference to the constant pool of the class being build.
     * Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param value
     * the internal name of the class.
     * @return a new or already existing class reference item.
     */
    newClassItem(value) {
        this.key2.set(ClassWriter.CLASS, value, null, null);
        let result = this.get(this.key2);
        if (result == null) {
            this.pool.put12(ClassWriter.CLASS, this.newUTF8(value));
            result = new Item(this.index++, this.key2);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a class reference to the constant pool of the class being build.
     * Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param value
     * the internal name of the class.
     * @return the index of a new or already existing class reference item.
     */
    newClass(value) {
        return this.newClassItem(value).index;
    }
    /**
     * Adds a method type reference to the constant pool of the class being
     * build. Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param methodDesc
     * method descriptor of the method type.
     * @return a new or already existing method type reference item.
     */
    newMethodTypeItem(methodDesc) {
        this.key2.set(ClassWriter.MTYPE, methodDesc, null, null);
        let result = this.get(this.key2);
        if (result == null) {
            this.pool.put12(ClassWriter.MTYPE, this.newUTF8(methodDesc));
            result = new Item(this.index++, this.key2);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a method type reference to the constant pool of the class being
     * build. Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param methodDesc
     * method descriptor of the method type.
     * @return the index of a new or already existing method type reference
     * item.
     */
    newMethodType(methodDesc) {
        return this.newMethodTypeItem(methodDesc).index;
    }
    /**
     * Adds a handle to the constant pool of the class being build. Does nothing
     * if the constant pool already contains a similar item. <i>This method is
     * intended for {@link Attribute} sub classes, and is normally not needed by
     * class generators or adapters.</i>
     *
     * @param tag
     * the kind of this handle. Must be {@link Opcodes#H_GETFIELD},
     * {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD},
     * {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL},
     * {@link Opcodes#H_INVOKESTATIC},
     * {@link Opcodes#H_INVOKESPECIAL},
     * {@link Opcodes#H_NEWINVOKESPECIAL} or
     * {@link Opcodes#H_INVOKEINTERFACE}.
     * @param owner
     * the internal name of the field or method owner class.
     * @param name
     * the name of the field or method.
     * @param desc
     * the descriptor of the field or method.
     * @param itf
     * true if the owner is an interface.
     * @return a new or an already existing method type reference item.
     */
    newHandleItem(tag, owner, name, desc, itf) {
        this.key4.set(ClassWriter.HANDLE_BASE + tag, owner, name, desc);
        let result = this.get(this.key4);
        if (result == null) {
            if (tag <= Opcodes.H_PUTSTATIC) {
                this.put112(ClassWriter.HANDLE, tag, this.newField(owner, name, desc));
            }
            else {
                this.put112(ClassWriter.HANDLE, tag, this.newMethod(owner, name, desc, itf));
            }
            result = new Item(this.index++, this.key4);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a handle to the constant pool of the class being build. Does nothing
     * if the constant pool already contains a similar item. <i>This method is
     * intended for {@link Attribute} sub classes, and is normally not needed by
     * class generators or adapters.</i>
     *
     * @param tag
     * the kind of this handle. Must be {@link Opcodes#H_GETFIELD},
     * {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD},
     * {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL},
     * {@link Opcodes#H_INVOKESTATIC},
     * {@link Opcodes#H_INVOKESPECIAL},
     * {@link Opcodes#H_NEWINVOKESPECIAL} or
     * {@link Opcodes#H_INVOKEINTERFACE}.
     * @param owner
     * the internal name of the field or method owner class.
     * @param name
     * the name of the field or method.
     * @param desc
     * the descriptor of the field or method.
     * @return the index of a new or already existing method type reference
     * item.
     *
     * @deprecated this method is superseded by
     * {@link #newHandle(int, String, String, String, boolean)}.
     */
    newHandle$int$java_lang_String$java_lang_String$java_lang_String(tag, owner, name, desc) {
        return this.newHandle(tag, owner, name, desc, tag === Opcodes.H_INVOKEINTERFACE);
    }
    /**
     * Adds a handle to the constant pool of the class being build. Does nothing
     * if the constant pool already contains a similar item. <i>This method is
     * intended for {@link Attribute} sub classes, and is normally not needed by
     * class generators or adapters.</i>
     *
     * @param tag
     * the kind of this handle. Must be {@link Opcodes#H_GETFIELD},
     * {@link Opcodes#H_GETSTATIC}, {@link Opcodes#H_PUTFIELD},
     * {@link Opcodes#H_PUTSTATIC}, {@link Opcodes#H_INVOKEVIRTUAL},
     * {@link Opcodes#H_INVOKESTATIC},
     * {@link Opcodes#H_INVOKESPECIAL},
     * {@link Opcodes#H_NEWINVOKESPECIAL} or
     * {@link Opcodes#H_INVOKEINTERFACE}.
     * @param owner
     * the internal name of the field or method owner class.
     * @param name
     * the name of the field or method.
     * @param desc
     * the descriptor of the field or method.
     * @param itf
     * true if the owner is an interface.
     * @return the index of a new or already existing method type reference
     * item.
     */
    newHandle(tag, owner, name, desc, itf) {
        if (((typeof tag === "number") || tag === null) && ((typeof owner === "string") || owner === null) && ((typeof name === "string") || name === null) && ((typeof desc === "string") || desc === null) && ((typeof itf === "boolean") || itf === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                return this.newHandleItem(tag, owner, name, desc, itf).index;
            })();
        }
        else if (((typeof tag === "number") || tag === null) && ((typeof owner === "string") || owner === null) && ((typeof name === "string") || name === null) && ((typeof desc === "string") || desc === null) && itf === undefined) {
            return this.newHandle$int$java_lang_String$java_lang_String$java_lang_String(tag, owner, name, desc);
        }
        else {
            throw new Error("invalid overload");
        }
    }
    /**
     * Adds an invokedynamic reference to the constant pool of the class being
     * build. Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param name
     * name of the invoked method.
     * @param desc
     * descriptor of the invoke method.
     * @param bsm
     * the bootstrap method.
     * @param bsmArgs
     * the bootstrap method constant arguments.
     *
     * @return a new or an already existing invokedynamic type reference item.
     */
    newInvokeDynamicItem(name, desc, bsm, ...bsmArgs) {
        let bootstrapMethods = this.bootstrapMethods;
        if (bootstrapMethods == null) {
            bootstrapMethods = this.bootstrapMethods = new ByteVector();
        }
        let position = bootstrapMethods.length;
        let hashCode = bsm.hashCode();
        bootstrapMethods.putShort(this.newHandle(bsm.tag, bsm.owner, bsm.name, bsm.descriptor, bsm.isInterface));
        let argsLength = bsmArgs.length;
        bootstrapMethods.putShort(argsLength);
        for (let i = 0; i < argsLength; i++) {
            let bsmArg = bsmArgs[i];
            hashCode ^= (bsmArg.toString());
            bootstrapMethods.putShort(this.newConst(bsmArg));
        }
        let data = bootstrapMethods.data;
        let length = (1 + 1 + argsLength) << 1;
        hashCode &= 2147483647;
        let result = this.items[hashCode % this.items.length];
        loop: while ((result != null)) {
            if (result.type !== ClassWriter.BSM || result.__hashCode !== hashCode) {
                result = result.next;
                continue;
            }
            let resultPosition = result.intVal;
            for (let p = 0; p < length; p++) {
                if (data[position + p] !== data[resultPosition + p]) {
                    result = result.next;
                    continue loop;
                }
            }
            break;
        }
        let bootstrapMethodIndex;
        if (result != null) {
            bootstrapMethodIndex = result.index;
            bootstrapMethods.length = position;
        }
        else {
            bootstrapMethodIndex = this.bootstrapMethodsCount++;
            result = new Item(bootstrapMethodIndex);
            result.setPosHash(position, hashCode);
            this.put(result);
        }
        this.key3.setInvkDynItem(name, desc, bootstrapMethodIndex);
        result = this.get(this.key3);
        if (result == null) {
            this.put122(ClassWriter.INDY, bootstrapMethodIndex, this.newNameType(name, desc));
            result = new Item(this.index++, this.key3);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds an invokedynamic reference to the constant pool of the class being
     * build. Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param name
     * name of the invoked method.
     * @param desc
     * descriptor of the invoke method.
     * @param bsm
     * the bootstrap method.
     * @param bsmArgs
     * the bootstrap method constant arguments.
     *
     * @return the index of a new or already existing invokedynamic reference
     * item.
     */
    newInvokeDynamic(name, desc, bsm, ...bsmArgs) {
        return this.newInvokeDynamicItem.apply(this, [name, desc, bsm].concat(bsmArgs)).index;
    }
    /**
     * Adds a field reference to the constant pool of the class being build.
     * Does nothing if the constant pool already contains a similar item.
     *
     * @param owner
     * the internal name of the field's owner class.
     * @param name
     * the field's name.
     * @param desc
     * the field's descriptor.
     * @return a new or already existing field reference item.
     */
    newFieldItem(owner, name, desc) {
        this.key3.set(ClassWriter.FIELD, owner, name, desc);
        let result = this.get(this.key3);
        if (result == null) {
            this.put122(ClassWriter.FIELD, this.newClass(owner), this.newNameType(name, desc));
            result = new Item(this.index++, this.key3);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a field reference to the constant pool of the class being build.
     * Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param owner
     * the internal name of the field's owner class.
     * @param name
     * the field's name.
     * @param desc
     * the field's descriptor.
     * @return the index of a new or already existing field reference item.
     */
    newField(owner, name, desc) {
        return this.newFieldItem(owner, name, desc).index;
    }
    /**
     * Adds a method reference to the constant pool of the class being build.
     * Does nothing if the constant pool already contains a similar item.
     *
     * @param owner
     * the internal name of the method's owner class.
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor.
     * @param itf
     * <tt>true</tt> if <tt>owner</tt> is an interface.
     * @return a new or already existing method reference item.
     */
    newMethodItem(owner, name, desc, itf) {
        let type = itf ? ClassWriter.IMETH : ClassWriter.METH;
        this.key3.set(type, owner, name, desc);
        let result = this.get(this.key3);
        if (result == null) {
            this.put122(type, this.newClass(owner), this.newNameType(name, desc));
            result = new Item(this.index++, this.key3);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a method reference to the constant pool of the class being build.
     * Does nothing if the constant pool already contains a similar item.
     * <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param owner
     * the internal name of the method's owner class.
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor.
     * @param itf
     * <tt>true</tt> if <tt>owner</tt> is an interface.
     * @return the index of a new or already existing method reference item.
     */
    newMethod(owner, name, desc, itf) {
        return this.newMethodItem(owner, name, desc, itf).index;
    }
    /**
     * Adds an integer to the constant pool of the class being build. Does
     * nothing if the constant pool already contains a similar item.
     *
     * @param value
     * the int value.
     * @return a new or already existing int item.
     */
    newInteger(value) {
        this.key.set$int(value);
        let result = this.get(this.key);
        if (result == null) {
            this.pool.putByte(ClassWriter.INT).putInt(value);
            result = new Item(this.index++, this.key);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a float to the constant pool of the class being build. Does nothing
     * if the constant pool already contains a similar item.
     *
     * @param value
     * the float value.
     * @return a new or already existing float item.
     */
    newFloat(value) {
        this.key.set$float(value);
        let result = this.get(this.key);
        if (result == null) {
            this.pool.putByte(ClassWriter.FLOAT).putInt(this.key.intVal);
            result = new Item(this.index++, this.key);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a long to the constant pool of the class being build. Does nothing
     * if the constant pool already contains a similar item.
     *
     * @param value
     * the long value.
     * @return a new or already existing long item.
     */
    newLong(value) {
        this.key.set$long(value);
        let result = this.get(this.key);
        if (result == null) {
            this.pool.putByte(ClassWriter.LONG).putLong(value);
            result = new Item(this.index, this.key);
            this.index += 2;
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a double to the constant pool of the class being build. Does nothing
     * if the constant pool already contains a similar item.
     *
     * @param value
     * the double value.
     * @return a new or already existing double item.
     */
    newDouble(value) {
        this.key.set$double(value);
        let result = this.get(this.key);
        if (result == null) {
            this.pool.putByte(ClassWriter.DOUBLE).putLong(this.key.longVal);
            result = new Item(this.index, this.key);
            this.index += 2;
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a string to the constant pool of the class being build. Does nothing
     * if the constant pool already contains a similar item.
     *
     * @param value
     * the String value.
     * @return a new or already existing string item.
     */
    newString(value) {
        this.key2.set(ClassWriter.STR, value, null, null);
        let result = this.get(this.key2);
        if (result == null) {
            this.pool.put12(ClassWriter.STR, this.newUTF8(value));
            result = new Item(this.index++, this.key2);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds a name and type to the constant pool of the class being build. Does
     * nothing if the constant pool already contains a similar item. <i>This
     * method is intended for {@link Attribute} sub classes, and is normally not
     * needed by class generators or adapters.</i>
     *
     * @param name
     * a name.
     * @param desc
     * a type descriptor.
     * @return the index of a new or already existing name and type item.
     */
    newNameType(name, desc) {
        return this.newNameTypeItem(name, desc).index;
    }
    /**
     * Adds a name and type to the constant pool of the class being build. Does
     * nothing if the constant pool already contains a similar item.
     *
     * @param name
     * a name.
     * @param desc
     * a type descriptor.
     * @return a new or already existing name and type item.
     */
    newNameTypeItem(name, desc) {
        this.key2.set(ClassWriter.NAME_TYPE, name, desc, null);
        let result = this.get(this.key2);
        if (result == null) {
            this.put122(ClassWriter.NAME_TYPE, this.newUTF8(name), this.newUTF8(desc));
            result = new Item(this.index++, this.key2);
            this.put(result);
        }
        return result;
    }
    /**
     * Adds the given internal name to {@link #typeTable} and returns its index.
     * Does nothing if the type table already contains this internal name.
     *
     * @param type
     * the internal name to be added to the type table.
     * @return the index of this internal name in the type table.
     */
    addType(type) {
        if (((typeof type === "string") || type === null)) {
            let __args = Array.prototype.slice.call(arguments);
            return (() => {
                this.key.set(ClassWriter.TYPE_NORMAL, type, null, null);
                let result = this.get(this.key);
                if (result == null) {
                    result = this.addType(this.key);
                }
                return result.index;
            })();
        }
        else if (((type != null && type instanceof Item) || type === null)) {
            return this.addType$Item(type);
        }
        else {
            throw new Error("invalid overload");
        }
    }
    /**
     * Adds the given "uninitialized" type to {@link #typeTable} and returns its
     * index. This method is used for UNINITIALIZED types, made of an internal
     * name and a bytecode offset.
     *
     * @param type
     * the internal name to be added to the type table.
     * @param offset
     * the bytecode offset of the NEW instruction that created this
     * UNINITIALIZED type value.
     * @return the index of this internal name in the type table.
     */
    addUninitializedType(type, offset) {
        this.key.type = ClassWriter.TYPE_UNINIT;
        this.key.intVal = offset;
        this.key.strVal1 = type;
        this.key.__hashCode = 2147483647 & (ClassWriter.TYPE_UNINIT + type.toString() + offset);
        let result = this.get(this.key);
        if (result == null) {
            result = this.addType(this.key);
        }
        return result.index;
    }
    /**
     * Adds the given Item to {@link #typeTable}.
     *
     * @param item
     * the value to be added to the type table.
     * @return the added Item, which a new Item instance with the same value as
     * the given Item.
     */
    addType$Item(item) {
        throw new Error("not supported");
        // ++this.typeCount;
        // let result: Item = new Item(this.typeCount, this.key);
        // this.put(result);
        // if (this.typeTable == null) {
        //     this.typeTable = new Array(16);
        // }
        // if (this.typeCount === this.typeTable.length) {
        //     let newTable: Item[] = new Array(2 * this.typeTable.length);
        //     java.lang.System.arraycopy(this.typeTable, 0, newTable, 0, this.typeTable.length);
        //     this.typeTable = newTable;
        // }
        // this.typeTable[this.typeCount] = result;
        // return result;
    }
    /**
     * Returns the index of the common super type of the two given types. This
     * method calls {@link #getCommonSuperClass} and caches the result in the
     * {@link #items} hash table to speedup future calls with the same
     * parameters.
     *
     * @param type1
     * index of an internal name in {@link #typeTable}.
     * @param type2
     * index of an internal name in {@link #typeTable}.
     * @return the index of the common super type of the two given types.
     */
    getMergedType(type1, type2) {
        throw new Error("not supported");
        // this.key2.type = ClassWriter.TYPE_MERGED;
        // this.key2.longVal = type1 | ((Math.round(<number>type2)) << 32);
        // this.key2.__hashCode = 2147483647 & (ClassWriter.TYPE_MERGED + type1 + type2);
        // let result: Item = this.get(this.key2);
        // if (result == null) {
        //     let t: string = this.typeTable[type1].strVal1;
        //     let u: string = this.typeTable[type2].strVal1;
        //     this.key2.intVal = this.addType(this.getCommonSuperClass(t, u));
        //     result = new Item((<number>0 | 0), this.key2);
        //     this.put(result);
        // }
        // return result.intVal;
    }
    /**
     * Returns the common super type of the two given types. The default
     * implementation of this method <i>loads</i> the two given classes and uses
     * the java.lang.Class methods to find the common super class. It can be
     * overridden to compute this common super type in other ways, in particular
     * without actually loading any class, or to take into account the class
     * that is currently being generated by this ClassWriter, which can of
     * course not be loaded since it is under construction.
     *
     * @param type1
     * the internal name of a class.
     * @param type2
     * the internal name of another class.
     * @return the internal name of the common super class of the two given
     * classes.
     */
    getCommonSuperClass(type1, type2) {
        return "java/lang/Object";
        // break....
        // let c: any;
        // let d: any;
        // let classLoader: java.lang.ClassLoader = (<any>this.constructor).getClassLoader();
        // try {
        //     c = java.lang.Class.forName(/* replace */type1.split('/').join('.'), false, classLoader);
        //     d = java.lang.Class.forName(/* replace */type2.split('/').join('.'), false, classLoader);
        // } catch (e) {
        //     throw new Error(e.toString());
        // };
        // if (c.isAssignableFrom(d)) {
        //     return type1;
        // }
        // if (d.isAssignableFrom(c)) {
        //     return type2;
        // }
        // if (c.isInterface() || d.isInterface()) {
        //     return "java/lang/Object";
        // } else {
        //     do {
        //         c = c.getSuperclass();
        //     } while ((!c.isAssignableFrom(d)));
        //     return /* replace *//* getName */(c => c["__class"] ? c["__class"] : c.name)(c).split('.').join('/');
        // }
    }
    /**
     * Returns the constant pool's hash table item which is equal to the given
     * item.
     *
     * @param key
     * a constant pool item.
     * @return the constant pool's hash table item which is equal to the given
     * item, or <tt>null</tt> if there is no such item.
     */
    get(key) {
        let i = this.items[key.__hashCode % this.items.length];
        while ((i != null && (i.type !== key.type || !key.isEqualTo(i)))) {
            i = i.next;
        }
        return i;
    }
    /**
     * Puts the given item in the constant pool's hash table. The hash table
     * <i>must</i> not already contains this item.
     *
     * @param i
     * the item to be added to the constant pool's hash table.
     */
    put(i) {
        if (this.index + this.typeCount > this.threshold) {
            let ll = this.items.length;
            let nl = ll * 2 + 1;
            let newItems = new Array(nl);
            for (let l = ll - 1; l >= 0; --l) {
                let j = this.items[l];
                while ((j != null)) {
                    let index = j.__hashCode % newItems.length;
                    let k = j.next;
                    j.next = newItems[index];
                    newItems[index] = j;
                    j = k;
                }
            }
            this.items = newItems;
            this.threshold = ((nl * 0.75) | 0);
        }
        let index = i.__hashCode % this.items.length;
        i.next = this.items[index];
        this.items[index] = i;
    }
    /**
     * Puts one byte and two shorts into the constant pool.
     *
     * @param b
     * a byte.
     * @param s1
     * a short.
     * @param s2
     * another short.
     */
    put122(b, s1, s2) {
        this.pool.put12(b, s1).putShort(s2);
    }
    /**
     * Puts two bytes and one short into the constant pool.
     *
     * @param b1
     * a byte.
     * @param b2
     * another byte.
     * @param s
     * a short.
     */
    put112(b1, b2, s) {
        this.pool.put11(b1, b2).putShort(s);
    }
}
ClassWriter.__static_initialized = false;
/**
 * Flag to automatically compute the maximum stack size and the maximum
 * number of local variables of methods. If this flag is set, then the
 * arguments of the {@link MethodVisitor#visitMaxs visitMaxs} method of the
 * {@link MethodVisitor} returned by the {@link #visitMethod visitMethod}
 * method will be ignored, and computed automatically from the signature and
 * the bytecode of each method.
 *
 * @see #ClassWriter(int)
 */
ClassWriter.COMPUTE_MAXS = 1;
/**
 * Flag to automatically compute the stack map frames of methods from
 * scratch. If this flag is set, then the calls to the
 * {@link MethodVisitor#visitFrame} method are ignored, and the stack map
 * frames are recomputed from the methods bytecode. The arguments of the
 * {@link MethodVisitor#visitMaxs visitMaxs} method are also ignored and
 * recomputed from the bytecode. In other words, COMPUTE_FRAMES implies
 * COMPUTE_MAXS.
 *
 * @see #ClassWriter(int)
 */
ClassWriter.COMPUTE_FRAMES = 2;
/**
 * Pseudo access flag to distinguish between the synthetic attribute and the
 * synthetic access flag.
 */
ClassWriter.ACC_SYNTHETIC_ATTRIBUTE = 262144;
/**
 * The type of instructions without any argument.
 */
ClassWriter.NOARG_INSN = 0;
/**
 * The type of instructions with an signed byte argument.
 */
ClassWriter.SBYTE_INSN = 1;
/**
 * The type of instructions with an signed short argument.
 */
ClassWriter.SHORT_INSN = 2;
/**
 * The type of instructions with a local variable index argument.
 */
ClassWriter.VAR_INSN = 3;
/**
 * The type of instructions with an implicit local variable index argument.
 */
ClassWriter.IMPLVAR_INSN = 4;
/**
 * The type of instructions with a type descriptor argument.
 */
ClassWriter.TYPE_INSN = 5;
/**
 * The type of field and method invocations instructions.
 */
ClassWriter.FIELDORMETH_INSN = 6;
/**
 * The type of the INVOKEINTERFACE/INVOKEDYNAMIC instruction.
 */
ClassWriter.ITFMETH_INSN = 7;
/**
 * The type of the INVOKEDYNAMIC instruction.
 */
ClassWriter.INDYMETH_INSN = 8;
/**
 * The type of instructions with a 2 bytes bytecode offset label.
 */
ClassWriter.LABEL_INSN = 9;
/**
 * The type of instructions with a 4 bytes bytecode offset label.
 */
ClassWriter.LABELW_INSN = 10;
/**
 * The type of the LDC instruction.
 */
ClassWriter.LDC_INSN = 11;
/**
 * The type of the LDC_W and LDC2_W instructions.
 */
ClassWriter.LDCW_INSN = 12;
/**
 * The type of the IINC instruction.
 */
ClassWriter.IINC_INSN = 13;
/**
 * The type of the TABLESWITCH instruction.
 */
ClassWriter.TABL_INSN = 14;
/**
 * The type of the LOOKUPSWITCH instruction.
 */
ClassWriter.LOOK_INSN = 15;
/**
 * The type of the MULTIANEWARRAY instruction.
 */
ClassWriter.MANA_INSN = 16;
/**
 * The type of the WIDE instruction.
 */
ClassWriter.WIDE_INSN = 17;
/**
 * The type of the ASM pseudo instructions with an unsigned 2 bytes offset
 * label (see Label#resolve).
 */
ClassWriter.ASM_LABEL_INSN = 18;
/**
 * Represents a frame inserted between already existing frames. This kind of
 * frame can only be used if the frame content can be computed from the
 * previous existing frame and from the instructions between this existing
 * frame and the inserted one, without any knowledge of the type hierarchy.
 * This kind of frame is only used when an unconditional jump is inserted in
 * a method while expanding an ASM pseudo instruction (see ClassReader).
 */
ClassWriter.F_INSERT = 256;
/**
 * The type of CONSTANT_Class constant pool items.
 */
ClassWriter.CLASS = 7;
/**
 * The type of CONSTANT_Fieldref constant pool items.
 */
ClassWriter.FIELD = 9;
/**
 * The type of CONSTANT_Methodref constant pool items.
 */
ClassWriter.METH = 10;
/**
 * The type of CONSTANT_InterfaceMethodref constant pool items.
 */
ClassWriter.IMETH = 11;
/**
 * The type of CONSTANT_String constant pool items.
 */
ClassWriter.STR = 8;
/**
 * The type of CONSTANT_Integer constant pool items.
 */
ClassWriter.INT = 3;
/**
 * The type of CONSTANT_Float constant pool items.
 */
ClassWriter.FLOAT = 4;
/**
 * The type of CONSTANT_Long constant pool items.
 */
ClassWriter.LONG = 5;
/**
 * The type of CONSTANT_Double constant pool items.
 */
ClassWriter.DOUBLE = 6;
/**
 * The type of CONSTANT_NameAndType constant pool items.
 */
ClassWriter.NAME_TYPE = 12;
/**
 * The type of CONSTANT_Utf8 constant pool items.
 */
ClassWriter.UTF8 = 1;
/**
 * The type of CONSTANT_MethodType constant pool items.
 */
ClassWriter.MTYPE = 16;
/**
 * The type of CONSTANT_MethodHandle constant pool items.
 */
ClassWriter.HANDLE = 15;
/**
 * The type of CONSTANT_InvokeDynamic constant pool items.
 */
ClassWriter.INDY = 18;
/**
 * The base value for all CONSTANT_MethodHandle constant pool items.
 * Internally, ASM store the 9 variations of CONSTANT_MethodHandle into 9
 * different items.
 */
ClassWriter.HANDLE_BASE = 20;
/**
 * Normal type Item stored in the ClassWriter {@link ClassWriter#typeTable},
 * instead of the constant pool, in order to avoid clashes with normal
 * constant pool items in the ClassWriter constant pool's hash table.
 */
ClassWriter.TYPE_NORMAL = 30;
/**
 * Uninitialized type Item stored in the ClassWriter
 * {@link ClassWriter#typeTable}, instead of the constant pool, in order to
 * avoid clashes with normal constant pool items in the ClassWriter constant
 * pool's hash table.
 */
ClassWriter.TYPE_UNINIT = 31;
/**
 * Merged type Item stored in the ClassWriter {@link ClassWriter#typeTable},
 * instead of the constant pool, in order to avoid clashes with normal
 * constant pool items in the ClassWriter constant pool's hash table.
 */
ClassWriter.TYPE_MERGED = 32;
/**
 * The type of BootstrapMethods items. These items are stored in a special
 * class attribute named BootstrapMethods and not in the constant pool.
 */
ClassWriter.BSM = 33;
ClassWriter.TYPE_$LI$();
ClassWriter.TO_ACC_SYNTHETIC_$LI$();
ClassWriter.__static_initialize();

class Context {
    constructor(attrs, flags, buffer) {
        /**
         * The start index of each bootstrap method.
         */
        this.bootstrapMethods = [];
        /**
         * The name of the method currently being parsed.
         */
        this.name = "";
        /**
         * The descriptor of the method currently being parsed.
         */
        this.desc = "";
        /**
         * The label objects, indexed by bytecode offset, of the method currently
         * being parsed (only bytecode offsets for which a label is needed have a
         * non null associated Label object).
         */
        this.labels = [];
        /**
         * The path of the type annotation currently being parsed.
         */
        this.typePath = null;
        /**
         * The labels corresponding to the start of the local variable ranges in the
         * local variable type annotation currently being parsed.
         */
        this.start = [];
        /**
         * The labels corresponding to the end of the local variable ranges in the
         * local variable type annotation currently being parsed.
         */
        this.end = [];
        /**
         * The local variable indices for each local variable range in the local
         * variable type annotation currently being parsed.
         */
        this.index = [];
        /**
         * The local values of the latest stack map frame that has been parsed.
         */
        this.local = [];
        /**
         * The stack values of the latest stack map frame that has been parsed.
         */
        this.stack = [];
        this.access = 0;
        this.typeRef = 0;
        this.offset = 0;
        this.mode = 0;
        this.localCount = 0;
        this.localDiff = 0;
        this.stackCount = 0;
        this.attrs = attrs;
        this.flags = flags;
        this.buffer = buffer;
    }
}

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class Handle {
    /**
     * Constructs a new field or method handle.
     *
     * @param tag
     * the kind of field or method designated by this Handle. Must be
     * {@link Opcodes#H_GETFIELD}, {@link Opcodes#H_GETSTATIC},
     * {@link Opcodes#H_PUTFIELD}, {@link Opcodes#H_PUTSTATIC},
     * {@link Opcodes#H_INVOKEVIRTUAL},
     * {@link Opcodes#H_INVOKESTATIC},
     * {@link Opcodes#H_INVOKESPECIAL},
     * {@link Opcodes#H_NEWINVOKESPECIAL} or
     * {@link Opcodes#H_INVOKEINTERFACE}.
     * @param owner
     * the internal name of the class that owns the field or method
     * designated by this handle.
     * @param name
     * the name of the field or method designated by this handle.
     * @param desc
     * the descriptor of the field or method designated by this
     * handle.
     * @param itf
     * true if the owner is an interface.
     */
    constructor(tag, owner, name, desc, itf = tag == Opcodes.H_INVOKEINTERFACE) {
        this.tag = tag;
        this.owner = owner;
        this.name = name;
        this.descriptor = desc;
        this.isInterface = itf;
    }
    equals(obj) {
        if (obj === this) {
            return true;
        }
        if (!(obj != null && obj instanceof Handle)) {
            return false;
        }
        let h = obj;
        return this.tag === h.tag && this.isInterface === h.isInterface && (this.owner === h.owner) && (this.name === h.name) && (this.descriptor === h.descriptor);
    }
    hashCode() {
        return this.tag + (this.isInterface ? 64 : 0) + this.owner.toString() * this.name.toString() * this.descriptor.toString();
    }
    /**
     * Returns the textual representation of this handle. The textual
     * representation is:
     *
     * <pre>
     * for a reference to a class:
     * owner '.' name desc ' ' '(' tag ')'
     * for a reference to an interface:
     * owner '.' name desc ' ' '(' tag ' ' itf ')'
     * </pre>
     *
     * . As this format is unambiguous, it can be parsed if necessary.
     */
    toString() {
        return this.owner + "." + this.name + this.descriptor + " (" + this.tag + (this.isInterface ? " itf" : "") + ")";
    }
}

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class TypePath {
    /**
     * Creates a new type path.
     *
     * @param b
     * the byte array containing the type path in Java class file
     * format.
     * @param offset
     * the offset of the first byte of the type path in 'b'.
     */
    constructor(b, offset) {
        this.offset = 0;
        this.buf = b;
        this.offset = offset;
    }
    /**
        * Returns the length of this path.
        *
        * @return the length of this path.
        */
    get length() {
        return this.buf[this.offset];
    }
    /**
     * Returns the value of the given step of this path.
     *
     * @param index
     * an index between 0 and {@link #getLength()}, exclusive.
     * @return {@link #ARRAY_ELEMENT ARRAY_ELEMENT}, {@link #INNER_TYPE
     * INNER_TYPE}, {@link #WILDCARD_BOUND WILDCARD_BOUND}, or
     * {@link #TYPE_ARGUMENT TYPE_ARGUMENT}.
     */
    getStep(index) {
        return this.buf[this.offset + 2 * index + 1];
    }
    /**
     * Returns the index of the type argument that the given step is stepping
     * into. This method should only be used for steps whose value is
     * {@link #TYPE_ARGUMENT TYPE_ARGUMENT}.
     *
     * @param index
     * an index between 0 and {@link #getLength()}, exclusive.
     * @return the index of the type argument that the given step is stepping
     * into.
     */
    getStepArgument(index) {
        return this.buf[this.offset + 2 * index + 2];
    }
    /**
     * Converts a type path in string form, in the format used by
     * {@link #toString()}, into a TypePath object.
     *
     * @param typePath
     * a type path in string form, in the format used by
     * {@link #toString()}. May be null or empty.
     * @return the corresponding TypePath object, or null if the path is empty.
     */
    static fromString(typePath) {
        if (typePath == null || typePath.length === 0) {
            return null;
        }
        let n = typePath.length;
        let out = new ByteVector(n);
        out.putByte(0);
        for (let i = 0; i < n;) {
            let c = typePath.charAt(i++);
            if (c === "[") {
                out.put11(TypePath.ARRAY_ELEMENT, 0);
            }
            else if (c === ".") {
                out.put11(TypePath.INNER_TYPE, 0);
            }
            else if (c === "*") {
                out.put11(TypePath.WILDCARD_BOUND, 0);
            }
            else if ((c).charCodeAt(0) >= ("0").charCodeAt(0) && (c).charCodeAt(0) <= ("9").charCodeAt(0)) {
                let typeArg = (c).charCodeAt(0) - ("0").charCodeAt(0);
                while ((i < n && ((c = typePath.charAt(i))).charCodeAt(0) >= ("0").charCodeAt(0) && (c).charCodeAt(0) <= ("9").charCodeAt(0))) {
                    typeArg = typeArg * 10 + (c).charCodeAt(0) - ("0").charCodeAt(0);
                    i += 1;
                }
                if (i < n && typePath.charAt(i) === ";") {
                    i += 1;
                }
                out.put11(TypePath.TYPE_ARGUMENT, typeArg);
            }
        }
        out.data[0] = (((out.length / 2 | 0)) | 0);
        return new TypePath(out.data, 0);
    }
    /**
     * Returns a string representation of this type path. {@link #ARRAY_ELEMENT
     * ARRAY_ELEMENT} steps are represented with '[', {@link #INNER_TYPE
     * INNER_TYPE} steps with '.', {@link #WILDCARD_BOUND WILDCARD_BOUND} steps
     * with '*' and {@link #TYPE_ARGUMENT TYPE_ARGUMENT} steps with their type
     * argument index in decimal form followed by ';'.
     */
    toString() {
        let length = this.length;
        let result = "";
        for (let i = 0; i < length; ++i) {
            switch ((this.getStep(i))) {
                case TypePath.ARRAY_ELEMENT:
                    result += "[";
                    break;
                case TypePath.INNER_TYPE:
                    result += ".";
                    break;
                case TypePath.WILDCARD_BOUND:
                    result += "*";
                    break;
                case TypePath.TYPE_ARGUMENT:
                    result += this.getStepArgument(i) + (";");
                    break;
                default:
                    result += ("_");
            }
        }
        return result.toString();
    }
}
/**
 * A type path step that steps into the element type of an array type. See
 * {@link #getStep getStep}.
 */
TypePath.ARRAY_ELEMENT = 0;
/**
 * A type path step that steps into the nested type of a class type. See
 * {@link #getStep getStep}.
 */
TypePath.INNER_TYPE = 1;
/**
 * A type path step that steps into the bound of a wildcard type. See
 * {@link #getStep getStep}.
 */
TypePath.WILDCARD_BOUND = 2;
/**
 * A type path step that steps into a type argument of a generic type. See
 * {@link #getStep getStep}.
 */
TypePath.TYPE_ARGUMENT = 3;

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
class ClassReader {
    /**
     * Constructs a new {@link ClassReader} object.
     *
     * @param b   the bytecode of the class to be read.
     * @param off the start offset of the class data.
     * @param len the length of the class data.
     */
    constructor(buffer, off = 0, len = buffer.length) {
        this.maxStringLength = 0;
        this.header = 0;
        this.buf = buffer;
        if (this.readShort(off + 6) > Opcodes.V1_8) {
            throw new Error();
        }
        this.items = new Array(this.readUnsignedShort(off + 8));
        let n = this.items.length;
        this.strings = new Array(n);
        let max = 0;
        let index = off + 10;
        for (let i = 1; i < n; ++i) {
            this.items[i] = index + 1;
            let size;
            switch ((buffer[index])) {
                case ClassWriter.FIELD:
                case ClassWriter.METH:
                case ClassWriter.IMETH:
                case ClassWriter.INT:
                case ClassWriter.FLOAT:
                case ClassWriter.NAME_TYPE:
                case ClassWriter.INDY:
                    size = 5;
                    break;
                case ClassWriter.LONG:
                case ClassWriter.DOUBLE:
                    size = 9;
                    ++i;
                    break;
                case ClassWriter.UTF8:
                    size = 3 + this.readUnsignedShort(index + 1);
                    if (size > max) {
                        max = size;
                    }
                    break;
                case ClassWriter.HANDLE:
                    size = 4;
                    break;
                default:
                    size = 3;
                    break;
            }
            index += size;
        }
        this.maxStringLength = max;
        this.header = index;
    }
    /**
     * Returns the class's access flags (see {@link Opcodes}). This value may
     * not reflect Deprecated and Synthetic flags when bytecode is before 1.5
     * and those flags are represented by attributes.
     *
     * @return the class access flags
     * @see ClassVisitor#visit(int, int, String, String, String, String[])
     */
    getAccess() {
        return this.readUnsignedShort(this.header);
    }
    /**
     * Returns the internal name of the class (see
     * {@link Type#getInternalName() getInternalName}).
     *
     * @return the internal class name
     * @see ClassVisitor#visit(int, int, String, String, String, String[])
     */
    getClassName() {
        return this.readClass(this.header + 2, new Array(this.maxStringLength));
    }
    /**
     * Returns the internal of name of the super class (see
     * {@link Type#getInternalName() getInternalName}). For interfaces, the
     * super class is {@link Object}.
     *
     * @return the internal name of super class, or <tt>null</tt> for
     * {@link Object} class.
     * @see ClassVisitor#visit(int, int, String, String, String, String[])
     */
    getSuperName() {
        return this.readClass(this.header + 4, new Array(this.maxStringLength));
    }
    /**
     * Returns the internal names of the class's interfaces (see
     * {@link Type#getInternalName() getInternalName}).
     *
     * @return the array of internal names for all implemented interfaces or
     * <tt>null</tt>.
     * @see ClassVisitor#visit(int, int, String, String, String, String[])
     */
    getInterfaces() {
        let index = this.header + 6;
        let n = this.readUnsignedShort(index);
        let interfaces = new Array(n);
        if (n > 0) {
            let buf = new Array(this.maxStringLength);
            for (let i = 0; i < n; ++i) {
                index += 2;
                interfaces[i] = this.readClass(index, buf);
            }
        }
        return interfaces;
    }
    /**
     * Makes the given visitor visit the Java class of this {@link ClassReader}.
     * This class is the one specified in the constructor (see
     * {@link #ClassReader(byte[]) ClassReader}).
     *
     * @param classVisitor the visitor that must visit this class.
     * @param attrs        prototypes of the attributes that must be parsed during the
     * visit of the class. Any attribute whose type is not equal to
     * the type of one the prototypes will not be parsed: its byte
     * array value will be passed unchanged to the ClassWriter.
     * <i>This may corrupt it if this value contains references to
     * the constant pool, or has syntactic or semantic links with a
     * class element that has been transformed by a class adapter
     * between the reader and the writer</i>.
     * @param flags        option flags that can be used to modify the default behavior
     * of this class. See {@link #SKIP_DEBUG}, {@link #EXPAND_FRAMES}
     * , {@link #SKIP_FRAMES}, {@link #SKIP_CODE}.
     */
    accept(classVisitor, attrs = [], flags = 0) {
        let u = this.header;
        let c = new Array(this.maxStringLength);
        let context = new Context(attrs, flags, c);
        let access = this.readUnsignedShort(u);
        let name = this.readClass(u + 2, c);
        let superClass = this.readClass(u + 4, c);
        let interfaces = new Array(this.readUnsignedShort(u + 6));
        u += 8;
        for (let i = 0; i < interfaces.length; ++i) {
            interfaces[i] = this.readClass(u, c);
            u += 2;
        }
        let signature = null;
        let sourceFile = null;
        let sourceDebug = null;
        let enclosingOwner = null;
        let enclosingName = null;
        let enclosingDesc = null;
        let anns = 0;
        let ianns = 0;
        let tanns = 0;
        let itanns = 0;
        let innerClasses = 0;
        let attributes = null;
        u = this.getAttributes();
        for (let i = this.readUnsignedShort(u); i > 0; --i) {
            let attrName = this.readUTF8(u + 2, c);
            if (("SourceFile" === attrName)) {
                sourceFile = this.readUTF8(u + 8, c);
            }
            else if (("InnerClasses" === attrName)) {
                innerClasses = u + 8;
            }
            else if (("EnclosingMethod" === attrName)) {
                enclosingOwner = this.readClass(u + 8, c);
                let item = this.readUnsignedShort(u + 10);
                if (item !== 0) {
                    enclosingName = this.readUTF8(this.items[item], c);
                    enclosingDesc = this.readUTF8(this.items[item] + 2, c);
                }
            }
            else if (ClassReader.SIGNATURES && ("Signature" === attrName)) {
                signature = this.readUTF8(u + 8, c);
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeVisibleAnnotations" === attrName)) {
                anns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeVisibleTypeAnnotations" === attrName)) {
                tanns = u + 8;
            }
            else if (("Deprecated" === attrName)) {
                access |= Opcodes.ACC_DEPRECATED;
            }
            else if (("Synthetic" === attrName)) {
                access |= Opcodes.ACC_SYNTHETIC | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
            }
            else if (("SourceDebugExtension" === attrName)) {
                let len = this.readInt(u + 4);
                sourceDebug = this.readUTF(u + 8, len, new Array(len));
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeInvisibleAnnotations" === attrName)) {
                ianns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeInvisibleTypeAnnotations" === attrName)) {
                itanns = u + 8;
            }
            else if (("BootstrapMethods" === attrName)) {
                let bootstrapMethods = new Array(this.readUnsignedShort(u + 8));
                for (let j = 0, v = u + 10; j < bootstrapMethods.length; j++) {
                    bootstrapMethods[j] = v;
                    v += 2 + this.readUnsignedShort(v + 2) << 1;
                }
                context.bootstrapMethods = bootstrapMethods;
            }
            else {
                let attr = this.readAttribute(attrs, attrName, u + 8, this.readInt(u + 4), c, -1, null);
                if (attr != null) {
                    attr.next = attributes;
                    attributes = attr;
                }
            }
            u += 6 + this.readInt(u + 4);
        }
        classVisitor.visit(this.readInt(this.items[1] - 7), access, name, signature, superClass, interfaces);
        if ((flags & ClassReader.SKIP_DEBUG) === 0 && (sourceFile != null || sourceDebug != null)) {
            classVisitor.visitSource(sourceFile, sourceDebug);
        }
        if (enclosingOwner != null) {
            classVisitor.visitOuterClass(enclosingOwner, enclosingName, enclosingDesc);
        }
        if (ClassReader.ANNOTATIONS && anns !== 0) {
            for (let i = this.readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
                v = this.readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(this.readUTF8(v, c), true));
            }
        }
        if (ClassReader.ANNOTATIONS && ianns !== 0) {
            for (let i = this.readUnsignedShort(ianns), v = ianns + 2; i > 0; --i) {
                v = this.readAnnotationValues(v + 2, c, true, classVisitor.visitAnnotation(this.readUTF8(v, c), false));
            }
        }
        if (ClassReader.ANNOTATIONS && tanns !== 0) {
            for (let i = this.readUnsignedShort(tanns), v = tanns + 2; i > 0; --i) {
                v = this.readAnnotationTarget(context, v);
                v = this.readAnnotationValues(v + 2, c, true, classVisitor.visitTypeAnnotation(context.typeRef, context.typePath, this.readUTF8(v, c), true));
            }
        }
        if (ClassReader.ANNOTATIONS && itanns !== 0) {
            for (let i = this.readUnsignedShort(itanns), v = itanns + 2; i > 0; --i) {
                v = this.readAnnotationTarget(context, v);
                v = this.readAnnotationValues(v + 2, c, true, classVisitor.visitTypeAnnotation(context.typeRef, context.typePath, this.readUTF8(v, c), false));
            }
        }
        while ((attributes != null)) {
            let attr = attributes.next;
            attributes.next = null;
            classVisitor.visitAttribute(attributes);
            attributes = attr;
        }
        if (innerClasses !== 0) {
            let v = innerClasses + 2;
            for (let i = this.readUnsignedShort(innerClasses); i > 0; --i) {
                classVisitor.visitInnerClass(this.readClass(v, c), this.readClass(v + 2, c), this.readUTF8(v + 4, c), this.readUnsignedShort(v + 6));
                v += 8;
            }
        }
        u = this.header + 10 + 2 * interfaces.length;
        for (let i = this.readUnsignedShort(u - 2); i > 0; --i) {
            u = this.readField(classVisitor, context, u);
        }
        u += 2;
        for (let i = this.readUnsignedShort(u - 2); i > 0; --i) {
            u = this.readMethod(classVisitor, context, u);
        }
        classVisitor.visitEnd();
    }
    /**
     * Reads a field and makes the given visitor visit it.
     *
     * @param classVisitor the visitor that must visit the field.
     * @param context      information about the class being parsed.
     * @param u            the start offset of the field in the class file.
     * @return the offset of the first byte following the field in the class.
     */
    readField(classVisitor, context, u) {
        let c = context.buffer;
        let access = this.readUnsignedShort(u);
        let name = this.readUTF8(u + 2, c);
        let desc = this.readUTF8(u + 4, c);
        u += 6;
        let signature = null;
        let anns = 0;
        let ianns = 0;
        let tanns = 0;
        let itanns = 0;
        let value = null;
        let attributes = null;
        for (let i = this.readUnsignedShort(u); i > 0; --i) {
            let attrName = this.readUTF8(u + 2, c);
            if (("ConstantValue" === attrName)) {
                let item = this.readUnsignedShort(u + 8);
                value = item === 0 ? null : this.readConst(item, c);
            }
            else if (ClassReader.SIGNATURES && ("Signature" === attrName)) {
                signature = this.readUTF8(u + 8, c);
            }
            else if (("Deprecated" === attrName)) {
                access |= Opcodes.ACC_DEPRECATED;
            }
            else if (("Synthetic" === attrName)) {
                access |= Opcodes.ACC_SYNTHETIC | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeVisibleAnnotations" === attrName)) {
                anns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeVisibleTypeAnnotations" === attrName)) {
                tanns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeInvisibleAnnotations" === attrName)) {
                ianns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeInvisibleTypeAnnotations" === attrName)) {
                itanns = u + 8;
            }
            else {
                let attr = this.readAttribute(context.attrs, attrName, u + 8, this.readInt(u + 4), c, -1, null);
                if (attr != null) {
                    attr.next = attributes;
                    attributes = attr;
                }
            }
            u += 6 + this.readInt(u + 4);
        }
        u += 2;
        assert(name);
        let fv = classVisitor.visitField(access, name, desc, signature, value);
        if (fv == null) {
            return u;
        }
        if (ClassReader.ANNOTATIONS && anns !== 0) {
            for (let i = this.readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
                v = this.readAnnotationValues(v + 2, c, true, fv.visitAnnotation(this.readUTF8(v, c), true));
            }
        }
        if (ClassReader.ANNOTATIONS && ianns !== 0) {
            for (let i = this.readUnsignedShort(ianns), v = ianns + 2; i > 0; --i) {
                v = this.readAnnotationValues(v + 2, c, true, fv.visitAnnotation(this.readUTF8(v, c), false));
            }
        }
        if (ClassReader.ANNOTATIONS && tanns !== 0) {
            for (let i = this.readUnsignedShort(tanns), v = tanns + 2; i > 0; --i) {
                v = this.readAnnotationTarget(context, v);
                v = this.readAnnotationValues(v + 2, c, true, fv.visitTypeAnnotation(context.typeRef, context.typePath, this.readUTF8(v, c), true));
            }
        }
        if (ClassReader.ANNOTATIONS && itanns !== 0) {
            for (let i = this.readUnsignedShort(itanns), v = itanns + 2; i > 0; --i) {
                v = this.readAnnotationTarget(context, v);
                v = this.readAnnotationValues(v + 2, c, true, fv.visitTypeAnnotation(context.typeRef, context.typePath, this.readUTF8(v, c), false));
            }
        }
        while ((attributes != null)) {
            let attr = attributes.next;
            attributes.next = null;
            fv.visitAttribute(attributes);
            attributes = attr;
        }
        fv.visitEnd();
        return u;
    }
    /**
     * Reads a method and makes the given visitor visit it.
     *
     * @param classVisitor the visitor that must visit the method.
     * @param context      information about the class being parsed.
     * @param u            the start offset of the method in the class file.
     * @return the offset of the first byte following the method in the class.
     */
    readMethod(classVisitor, context, u) {
        var _a;
        let c = context.buffer;
        context.access = this.readUnsignedShort(u);
        context.name = this.readUTF8(u + 2, c);
        context.desc = this.readUTF8(u + 4, c);
        u += 6;
        let code = 0;
        let exception = 0;
        let exceptions = null;
        let signature = null;
        let methodParameters = 0;
        let anns = 0;
        let ianns = 0;
        let tanns = 0;
        let itanns = 0;
        let dann = 0;
        let mpanns = 0;
        let impanns = 0;
        let firstAttribute = u;
        let attributes = null;
        for (let i = this.readUnsignedShort(u); i > 0; --i) {
            let attrName = this.readUTF8(u + 2, c);
            if (("Code" === attrName)) {
                if ((context.flags & ClassReader.SKIP_CODE) === 0) {
                    code = u + 8;
                }
            }
            else if (("Exceptions" === attrName)) {
                exceptions = new Array(this.readUnsignedShort(u + 8));
                exception = u + 10;
                for (let j = 0; j < exceptions.length; ++j) {
                    exceptions[j] = this.readClass(exception, c);
                    exception += 2;
                }
            }
            else if (ClassReader.SIGNATURES && ("Signature" === attrName)) {
                signature = this.readUTF8(u + 8, c);
            }
            else if (("Deprecated" === attrName)) {
                context.access |= Opcodes.ACC_DEPRECATED;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeVisibleAnnotations" === attrName)) {
                anns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeVisibleTypeAnnotations" === attrName)) {
                tanns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("AnnotationDefault" === attrName)) {
                dann = u + 8;
            }
            else if (("Synthetic" === attrName)) {
                context.access |= Opcodes.ACC_SYNTHETIC | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeInvisibleAnnotations" === attrName)) {
                ianns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeInvisibleTypeAnnotations" === attrName)) {
                itanns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeVisibleParameterAnnotations" === attrName)) {
                mpanns = u + 8;
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeInvisibleParameterAnnotations" === attrName)) {
                impanns = u + 8;
            }
            else if (("MethodParameters" === attrName)) {
                methodParameters = u + 8;
            }
            else {
                let attr = this.readAttribute(context.attrs, attrName, u + 8, this.readInt(u + 4), c, -1, null);
                if (attr != null) {
                    attr.next = attributes;
                    attributes = attr;
                }
            }
            u += 6 + this.readInt(u + 4);
        }
        u += 2;
        let mv = classVisitor.visitMethod(context.access, context.name, context.desc, signature, exceptions);
        if (mv == null) {
            return u;
        }
        if (ClassReader.WRITER && (mv != null && mv instanceof MethodWriter)) {
            let mw = mv;
            if (mw.cw.cr === this && signature === mw.signature) {
                let sameExceptions = false;
                if (exceptions == null) {
                    sameExceptions = mw.exceptionCount === 0;
                }
                else if (exceptions.length === mw.exceptionCount) {
                    sameExceptions = true;
                    for (let j = exceptions.length - 1; j >= 0; --j) {
                        exception -= 2;
                        if (((_a = mw.exceptions) === null || _a === void 0 ? void 0 : _a[j]) !== this.readUnsignedShort(exception)) {
                            sameExceptions = false;
                            break;
                        }
                    }
                }
                if (sameExceptions) {
                    mw.classReaderOffset = firstAttribute;
                    mw.classReaderLength = u - firstAttribute;
                    return u;
                }
            }
        }
        if (methodParameters !== 0) {
            for (let i = this.buf[methodParameters] & 255, v = methodParameters + 1; i > 0; --i, v = v + 4) {
                mv.visitParameter(this.readUTF8(v, c), this.readUnsignedShort(v + 2));
            }
        }
        if (ClassReader.ANNOTATIONS && dann !== 0) {
            let dv = mv.visitAnnotationDefault();
            this.readAnnotationValue(dann, c, null, dv);
            if (dv != null) {
                dv.visitEnd();
            }
        }
        if (ClassReader.ANNOTATIONS && anns !== 0) {
            for (let i = this.readUnsignedShort(anns), v = anns + 2; i > 0; --i) {
                v = this.readAnnotationValues(v + 2, c, true, mv.visitAnnotation(this.readUTF8(v, c), true));
            }
        }
        if (ClassReader.ANNOTATIONS && ianns !== 0) {
            for (let i = this.readUnsignedShort(ianns), v = ianns + 2; i > 0; --i) {
                v = this.readAnnotationValues(v + 2, c, true, mv.visitAnnotation(this.readUTF8(v, c), false));
            }
        }
        if (ClassReader.ANNOTATIONS && tanns !== 0) {
            for (let i = this.readUnsignedShort(tanns), v = tanns + 2; i > 0; --i) {
                v = this.readAnnotationTarget(context, v);
                v = this.readAnnotationValues(v + 2, c, true, mv.visitTypeAnnotation(context.typeRef, context.typePath, this.readUTF8(v, c), true));
            }
        }
        if (ClassReader.ANNOTATIONS && itanns !== 0) {
            for (let i = this.readUnsignedShort(itanns), v = itanns + 2; i > 0; --i) {
                v = this.readAnnotationTarget(context, v);
                v = this.readAnnotationValues(v + 2, c, true, mv.visitTypeAnnotation(context.typeRef, context.typePath, this.readUTF8(v, c), false));
            }
        }
        if (ClassReader.ANNOTATIONS && mpanns !== 0) {
            this.readParameterAnnotations(mv, context, mpanns, true);
        }
        if (ClassReader.ANNOTATIONS && impanns !== 0) {
            this.readParameterAnnotations(mv, context, impanns, false);
        }
        while ((attributes != null)) {
            let attr = attributes.next;
            attributes.next = null;
            mv.visitAttribute(attributes);
            attributes = attr;
        }
        if (code !== 0) {
            mv.visitCode();
            this.readCode(mv, context, code);
        }
        mv.visitEnd();
        return u;
    }
    /**
     * Reads the bytecode of a method and makes the given visitor visit it.
     *
     * @param mv      the visitor that must visit the method's code.
     * @param context information about the class being parsed.
     * @param u       the start offset of the code attribute in the class file.
     */
    readCode(mv, context, u) {
        let b = this.buf;
        let c = context.buffer;
        let maxStack = this.readUnsignedShort(u);
        let maxLocals = this.readUnsignedShort(u + 2);
        let codeLength = this.readInt(u + 4);
        u += 8;
        let codeStart = u;
        let codeEnd = u + codeLength;
        let labels = context.labels = new Array(codeLength + 2);
        this.readLabel(codeLength + 1, labels);
        while ((u < codeEnd)) {
            let offset = u - codeStart;
            let opcode = b[u] & 255;
            switch ((ClassWriter.TYPE[opcode])) {
                case ClassWriter.NOARG_INSN:
                case ClassWriter.IMPLVAR_INSN:
                    u += 1;
                    break;
                case ClassWriter.LABEL_INSN:
                    this.readLabel(offset + this.readShort(u + 1), labels);
                    u += 3;
                    break;
                case ClassWriter.ASM_LABEL_INSN:
                    this.readLabel(offset + this.readUnsignedShort(u + 1), labels);
                    u += 3;
                    break;
                case ClassWriter.LABELW_INSN:
                    this.readLabel(offset + this.readInt(u + 1), labels);
                    u += 5;
                    break;
                case ClassWriter.WIDE_INSN:
                    opcode = b[u + 1] & 255;
                    if (opcode === Opcodes.IINC) {
                        u += 6;
                    }
                    else {
                        u += 4;
                    }
                    break;
                case ClassWriter.TABL_INSN:
                    u = u + 4 - (offset & 3);
                    this.readLabel(offset + this.readInt(u), labels);
                    for (let i = this.readInt(u + 8) - this.readInt(u + 4) + 1; i > 0; --i) {
                        this.readLabel(offset + this.readInt(u + 12), labels);
                        u += 4;
                    }
                    u += 12;
                    break;
                case ClassWriter.LOOK_INSN:
                    u = u + 4 - (offset & 3);
                    this.readLabel(offset + this.readInt(u), labels);
                    for (let i = this.readInt(u + 4); i > 0; --i) {
                        this.readLabel(offset + this.readInt(u + 12), labels);
                        u += 8;
                    }
                    u += 8;
                    break;
                case ClassWriter.VAR_INSN:
                case ClassWriter.SBYTE_INSN:
                case ClassWriter.LDC_INSN:
                    u += 2;
                    break;
                case ClassWriter.SHORT_INSN:
                case ClassWriter.LDCW_INSN:
                case ClassWriter.FIELDORMETH_INSN:
                case ClassWriter.TYPE_INSN:
                case ClassWriter.IINC_INSN:
                    u += 3;
                    break;
                case ClassWriter.ITFMETH_INSN:
                case ClassWriter.INDYMETH_INSN:
                    u += 5;
                    break;
                default:
                    u += 4;
                    break;
            }
        }
        for (let i = this.readUnsignedShort(u); i > 0; --i) {
            let start = this.readLabel(this.readUnsignedShort(u + 2), labels);
            let end = this.readLabel(this.readUnsignedShort(u + 4), labels);
            let handler = this.readLabel(this.readUnsignedShort(u + 6), labels);
            let type = this.readUTF8(this.items[this.readUnsignedShort(u + 8)], c);
            mv.visitTryCatchBlock(start, end, handler, type);
            u += 8;
        }
        u += 2;
        let tanns = null;
        let itanns = null;
        let tann = 0;
        let itann = 0;
        let ntoff = -1;
        let nitoff = -1;
        let varTable = 0;
        let varTypeTable = 0;
        let zip = true;
        let unzip = (context.flags & ClassReader.EXPAND_FRAMES) !== 0;
        let stackMap = 0;
        let stackMapSize = 0;
        let frameCount = 0;
        let frame = null;
        let attributes = null;
        for (let i = this.readUnsignedShort(u); i > 0; --i) {
            let attrName = this.readUTF8(u + 2, c);
            if (("LocalVariableTable" === attrName)) {
                if ((context.flags & ClassReader.SKIP_DEBUG) === 0) {
                    varTable = u + 8;
                    for (let j = this.readUnsignedShort(u + 8), v = u; j > 0; --j) {
                        let label = this.readUnsignedShort(v + 10);
                        if (labels[label] == null) {
                            this.readLabel(label, labels).status |= Label.DEBUG;
                        }
                        label += this.readUnsignedShort(v + 12);
                        if (labels[label] == null) {
                            this.readLabel(label, labels).status |= Label.DEBUG;
                        }
                        v += 10;
                    }
                }
            }
            else if (("LocalVariableTypeTable" === attrName)) {
                varTypeTable = u + 8;
            }
            else if (("LineNumberTable" === attrName)) {
                if ((context.flags & ClassReader.SKIP_DEBUG) === 0) {
                    for (let j = this.readUnsignedShort(u + 8), v = u; j > 0; --j) {
                        let label = this.readUnsignedShort(v + 10);
                        if (labels[label] == null) {
                            this.readLabel(label, labels).status |= Label.DEBUG;
                        }
                        let l = labels[label];
                        while ((l.line > 0)) {
                            if (l.next == null) {
                                l.next = new Label();
                            }
                            l = l.next;
                        }
                        l.line = this.readUnsignedShort(v + 12);
                        v += 4;
                    }
                }
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeVisibleTypeAnnotations" === attrName)) {
                tanns = this.readTypeAnnotations(mv, context, u + 8, true);
                ntoff = tanns.length === 0 || this.readByte(tanns[0]) < 67 ? -1 : this.readUnsignedShort(tanns[0] + 1);
            }
            else if (ClassReader.ANNOTATIONS && ("RuntimeInvisibleTypeAnnotations" === attrName)) {
                itanns = this.readTypeAnnotations(mv, context, u + 8, false);
                nitoff = itanns.length === 0 || this.readByte(itanns[0]) < 67 ? -1 : this.readUnsignedShort(itanns[0] + 1);
            }
            else if (ClassReader.FRAMES && ("StackMapTable" === attrName)) {
                if ((context.flags & ClassReader.SKIP_FRAMES) === 0) {
                    stackMap = u + 10;
                    stackMapSize = this.readInt(u + 4);
                    frameCount = this.readUnsignedShort(u + 8);
                }
            }
            else if (ClassReader.FRAMES && ("StackMap" === attrName)) {
                if ((context.flags & ClassReader.SKIP_FRAMES) === 0) {
                    zip = false;
                    stackMap = u + 10;
                    stackMapSize = this.readInt(u + 4);
                    frameCount = this.readUnsignedShort(u + 8);
                }
            }
            else {
                for (let j = 0; j < context.attrs.length; ++j) {
                    if ((context.attrs[j].type === attrName)) {
                        let attr = context.attrs[j].read(this, u + 8, this.readInt(u + 4), c, codeStart - 8, labels);
                        if (attr != null) {
                            attr.next = attributes;
                            attributes = attr;
                        }
                    }
                }
            }
            u += 6 + this.readInt(u + 4);
        }
        u += 2;
        if (ClassReader.FRAMES && stackMap !== 0) {
            frame = context;
            frame.offset = -1;
            frame.mode = 0;
            frame.localCount = 0;
            frame.localDiff = 0;
            frame.stackCount = 0;
            frame.local = new Array(maxLocals);
            frame.stack = new Array(maxStack);
            if (unzip) {
                this.getImplicitFrame(context);
            }
            for (let i = stackMap; i < stackMap + stackMapSize - 2; ++i) {
                if (b[i] === 8) {
                    let v = this.readUnsignedShort(i + 1);
                    if (v >= 0 && v < codeLength) {
                        if ((b[codeStart + v] & 255) === Opcodes.NEW) {
                            this.readLabel(v, labels);
                        }
                    }
                }
            }
        }
        if ((context.flags & ClassReader.EXPAND_ASM_INSNS) !== 0) {
            mv.visitFrame(Opcodes.F_NEW, maxLocals, null, 0, null);
        }
        let opcodeDelta = (context.flags & ClassReader.EXPAND_ASM_INSNS) === 0 ? -33 : 0;
        u = codeStart;
        while ((u < codeEnd)) {
            let offset = u - codeStart;
            let l = labels[offset];
            if (l != null) {
                let next = l.next;
                l.next = null;
                mv.visitLabel(l);
                if ((context.flags & ClassReader.SKIP_DEBUG) === 0 && l.line > 0) {
                    mv.visitLineNumber(l.line, l);
                    while ((next != null)) {
                        mv.visitLineNumber(next.line, l);
                        next = next.next;
                    }
                }
            }
            while ((ClassReader.FRAMES && frame != null && (frame.offset === offset || frame.offset === -1))) {
                if (frame.offset !== -1) {
                    if (!zip || unzip) {
                        mv.visitFrame(Opcodes.F_NEW, frame.localCount, frame.local, frame.stackCount, frame.stack);
                    }
                    else {
                        mv.visitFrame(frame.mode, frame.localDiff, frame.local, frame.stackCount, frame.stack);
                    }
                }
                if (frameCount > 0) {
                    stackMap = this.readFrame(stackMap, zip, unzip, frame);
                    --frameCount;
                }
                else {
                    frame = null;
                }
            }
            let opcode = b[u] & 255;
            switch ((ClassWriter.TYPE[opcode])) {
                case ClassWriter.NOARG_INSN:
                    mv.visitInsn(opcode);
                    u += 1;
                    break;
                case ClassWriter.IMPLVAR_INSN:
                    if (opcode > Opcodes.ISTORE) {
                        opcode -= 59;
                        mv.visitVarInsn(Opcodes.ISTORE + (opcode >> 2), opcode & 3);
                    }
                    else {
                        opcode -= 26;
                        mv.visitVarInsn(Opcodes.ILOAD + (opcode >> 2), opcode & 3);
                    }
                    u += 1;
                    break;
                case ClassWriter.LABEL_INSN:
                    mv.visitJumpInsn(opcode, labels[offset + this.readShort(u + 1)]);
                    u += 3;
                    break;
                case ClassWriter.LABELW_INSN:
                    mv.visitJumpInsn(opcode + opcodeDelta, labels[offset + this.readInt(u + 1)]);
                    u += 5;
                    break;
                case ClassWriter.ASM_LABEL_INSN:
                    {
                        opcode = opcode < 218 ? opcode - 49 : opcode - 20;
                        let target = labels[offset + this.readUnsignedShort(u + 1)];
                        if (opcode === Opcodes.GOTO || opcode === Opcodes.JSR) {
                            mv.visitJumpInsn(opcode + 33, target);
                        }
                        else {
                            opcode = opcode <= 166 ? ((opcode + 1) ^ 1) - 1 : opcode ^ 1;
                            let endif = new Label();
                            mv.visitJumpInsn(opcode, endif);
                            mv.visitJumpInsn(200, target);
                            mv.visitLabel(endif);
                            if (ClassReader.FRAMES && stackMap !== 0 && (frame == null || frame.offset !== offset + 3)) {
                                mv.visitFrame(ClassWriter.F_INSERT, 0, null, 0, null);
                            }
                        }
                        u += 3;
                        break;
                    }
                case ClassWriter.WIDE_INSN:
                    opcode = b[u + 1] & 255;
                    if (opcode === Opcodes.IINC) {
                        mv.visitIincInsn(this.readUnsignedShort(u + 2), this.readShort(u + 4));
                        u += 6;
                    }
                    else {
                        mv.visitVarInsn(opcode, this.readUnsignedShort(u + 2));
                        u += 4;
                    }
                    break;
                case ClassWriter.TABL_INSN:
                    {
                        u = u + 4 - (offset & 3);
                        let label = offset + this.readInt(u);
                        let min = this.readInt(u + 4);
                        let max = this.readInt(u + 8);
                        let table = new Array(max - min + 1);
                        u += 12;
                        for (let i = 0; i < table.length; ++i) {
                            table[i] = labels[offset + this.readInt(u)];
                            u += 4;
                        }
                        mv.visitTableSwitchInsn(min, max, labels[label], ...table);
                        break;
                    }
                case ClassWriter.LOOK_INSN:
                    {
                        u = u + 4 - (offset & 3);
                        let label = offset + this.readInt(u);
                        let len = this.readInt(u + 4);
                        let keys = new Array(len);
                        let values = new Array(len);
                        u += 8;
                        for (let i = 0; i < len; ++i) {
                            keys[i] = this.readInt(u);
                            values[i] = labels[offset + this.readInt(u + 4)];
                            u += 8;
                        }
                        mv.visitLookupSwitchInsn(labels[label], keys, values);
                        break;
                    }
                case ClassWriter.VAR_INSN:
                    mv.visitVarInsn(opcode, b[u + 1] & 255);
                    u += 2;
                    break;
                case ClassWriter.SBYTE_INSN:
                    mv.visitIntInsn(opcode, b[u + 1]);
                    u += 2;
                    break;
                case ClassWriter.SHORT_INSN:
                    mv.visitIntInsn(opcode, this.readShort(u + 1));
                    u += 3;
                    break;
                case ClassWriter.LDC_INSN:
                    mv.visitLdcInsn(this.readConst(b[u + 1] & 255, c));
                    u += 2;
                    break;
                case ClassWriter.LDCW_INSN:
                    mv.visitLdcInsn(this.readConst(this.readUnsignedShort(u + 1), c));
                    u += 3;
                    break;
                case ClassWriter.FIELDORMETH_INSN:
                case ClassWriter.ITFMETH_INSN:
                    {
                        let cpIndex = this.items[this.readUnsignedShort(u + 1)];
                        let itf = b[cpIndex - 1] === ClassWriter.IMETH;
                        let iowner = this.readClass(cpIndex, c);
                        cpIndex = this.items[this.readUnsignedShort(cpIndex + 2)];
                        let iname = this.readUTF8(cpIndex, c);
                        let idesc = this.readUTF8(cpIndex + 2, c);
                        if (opcode < Opcodes.INVOKEVIRTUAL) {
                            mv.visitFieldInsn(opcode, iowner, iname, idesc);
                        }
                        else {
                            mv.visitMethodInsn(opcode, iowner, iname, idesc, itf);
                        }
                        if (opcode === Opcodes.INVOKEINTERFACE) {
                            u += 5;
                        }
                        else {
                            u += 3;
                        }
                        break;
                    }
                case ClassWriter.INDYMETH_INSN:
                    {
                        let cpIndex = this.items[this.readUnsignedShort(u + 1)];
                        let bsmIndex = context.bootstrapMethods[this.readUnsignedShort(cpIndex)];
                        let bsm = this.readConst(this.readUnsignedShort(bsmIndex), c);
                        let bsmArgCount = this.readUnsignedShort(bsmIndex + 2);
                        let bsmArgs = new Array(bsmArgCount);
                        bsmIndex += 4;
                        for (let i = 0; i < bsmArgCount; i++) {
                            bsmArgs[i] = this.readConst(this.readUnsignedShort(bsmIndex), c);
                            bsmIndex += 2;
                        }
                        cpIndex = this.items[this.readUnsignedShort(cpIndex + 2)];
                        let iname = this.readUTF8(cpIndex, c);
                        let idesc = this.readUTF8(cpIndex + 2, c);
                        mv.visitInvokeDynamicInsn(iname, idesc, bsm, ...bsmArgs);
                        u += 5;
                        break;
                    }
                case ClassWriter.TYPE_INSN:
                    mv.visitTypeInsn(opcode, this.readClass(u + 1, c));
                    u += 3;
                    break;
                case ClassWriter.IINC_INSN:
                    mv.visitIincInsn(b[u + 1] & 255, b[u + 2]);
                    u += 3;
                    break;
                default:
                    mv.visitMultiANewArrayInsn(this.readClass(u + 1, c), b[u + 3] & 255);
                    u += 4;
                    break;
            }
            while ((tanns != null && tann < tanns.length && ntoff <= offset)) {
                if (ntoff === offset) {
                    let v = this.readAnnotationTarget(context, tanns[tann]);
                    this.readAnnotationValues(v + 2, c, true, mv.visitInsnAnnotation(context.typeRef, context.typePath, this.readUTF8(v, c), true));
                }
                ntoff = ++tann >= tanns.length || this.readByte(tanns[tann]) < 67 ? -1 : this.readUnsignedShort(tanns[tann] + 1);
            }
            while ((itanns != null && itann < itanns.length && nitoff <= offset)) {
                if (nitoff === offset) {
                    let v = this.readAnnotationTarget(context, itanns[itann]);
                    this.readAnnotationValues(v + 2, c, true, mv.visitInsnAnnotation(context.typeRef, context.typePath, this.readUTF8(v, c), false));
                }
                nitoff = ++itann >= itanns.length || this.readByte(itanns[itann]) < 67 ? -1 : this.readUnsignedShort(itanns[itann] + 1);
            }
        }
        if (labels[codeLength] != null) {
            mv.visitLabel(labels[codeLength]);
        }
        if ((context.flags & ClassReader.SKIP_DEBUG) === 0 && varTable !== 0) {
            let typeTable = null;
            if (varTypeTable !== 0) {
                u = varTypeTable + 2;
                typeTable = new Array(this.readUnsignedShort(varTypeTable) * 3);
                for (let i = typeTable.length; i > 0;) {
                    typeTable[--i] = u + 6;
                    typeTable[--i] = this.readUnsignedShort(u + 8);
                    typeTable[--i] = this.readUnsignedShort(u);
                    u += 10;
                }
            }
            u = varTable + 2;
            for (let i = this.readUnsignedShort(varTable); i > 0; --i) {
                let start = this.readUnsignedShort(u);
                let length = this.readUnsignedShort(u + 2);
                let index = this.readUnsignedShort(u + 8);
                let vsignature = null;
                if (typeTable != null) {
                    for (let j = 0; j < typeTable.length; j += 3) {
                        if (typeTable[j] === start && typeTable[j + 1] === index) {
                            vsignature = this.readUTF8(typeTable[j + 2], c);
                            break;
                        }
                    }
                }
                mv.visitLocalVariable(this.readUTF8(u + 4, c), this.readUTF8(u + 6, c), vsignature, labels[start], labels[start + length], index);
                u += 10;
            }
        }
        if (tanns != null) {
            for (let i = 0; i < tanns.length; ++i) {
                if ((this.readByte(tanns[i]) >> 1) === (64 >> 1)) {
                    let v = this.readAnnotationTarget(context, tanns[i]);
                    v = this.readAnnotationValues(v + 2, c, true, mv.visitLocalVariableAnnotation(context.typeRef, context.typePath, context.start, context.end, context.index, this.readUTF8(v, c), true));
                }
            }
        }
        if (itanns != null) {
            for (let i = 0; i < itanns.length; ++i) {
                if ((this.readByte(itanns[i]) >> 1) === (64 >> 1)) {
                    let v = this.readAnnotationTarget(context, itanns[i]);
                    v = this.readAnnotationValues(v + 2, c, true, mv.visitLocalVariableAnnotation(context.typeRef, context.typePath, context.start, context.end, context.index, this.readUTF8(v, c), false));
                }
            }
        }
        while ((attributes != null)) {
            let attr = attributes.next;
            attributes.next = null;
            mv.visitAttribute(attributes);
            attributes = attr;
        }
        mv.visitMaxs(maxStack, maxLocals);
    }
    /**
     * Parses a type annotation table to find the labels, and to visit the try
     * catch block annotations.
     *
     * @param u       the start offset of a type annotation table.
     * @param mv      the method visitor to be used to visit the try catch block
     * annotations.
     * @param context information about the class being parsed.
     * @param visible if the type annotation table to parse contains runtime visible
     * annotations.
     * @return the start offset of each type annotation in the parsed table.
     */
    readTypeAnnotations(mv, context, u, visible) {
        let c = context.buffer;
        let offsets = new Array(this.readUnsignedShort(u));
        u += 2;
        for (let i = 0; i < offsets.length; ++i) {
            offsets[i] = u;
            let target = this.readInt(u);
            switch ((target >>> 24)) {
                case 0:
                case 1:
                case 22:
                    u += 2;
                    break;
                case 19:
                case 20:
                case 21:
                    u += 1;
                    break;
                case 64:
                case 65:
                    for (let j = this.readUnsignedShort(u + 1); j > 0; --j) {
                        let start = this.readUnsignedShort(u + 3);
                        let length = this.readUnsignedShort(u + 5);
                        this.readLabel(start, context.labels);
                        this.readLabel(start + length, context.labels);
                        u += 6;
                    }
                    u += 3;
                    break;
                case 71:
                case 72:
                case 73:
                case 74:
                case 75:
                    u += 4;
                    break;
                default:
                    u += 3;
                    break;
            }
            let pathLength = this.readByte(u);
            if ((target >>> 24) === 66) {
                let path = pathLength === 0 ? null : new TypePath(this.buf, u);
                u += 1 + 2 * pathLength;
                u = this.readAnnotationValues(u + 2, c, true, mv.visitTryCatchAnnotation(target, path, this.readUTF8(u, c), visible));
            }
            else {
                u = this.readAnnotationValues(u + 3 + 2 * pathLength, c, true, null);
            }
        }
        return offsets;
    }
    /**
     * Parses the header of a type annotation to extract its target_type and
     * target_path (the result is stored in the given context), and returns the
     * start offset of the rest of the type_annotation structure (i.e. the
     * offset to the type_index field, which is followed by
     * num_element_value_pairs and then the name,value pairs).
     *
     * @param context information about the class being parsed. This is where the
     * extracted target_type and target_path must be stored.
     * @param u       the start offset of a type_annotation structure.
     * @return the start offset of the rest of the type_annotation structure.
     */
    readAnnotationTarget(context, u) {
        let target = this.readInt(u);
        switch ((target >>> 24)) {
            case 0:
            case 1:
            case 22:
                target &= -65536;
                u += 2;
                break;
            case 19:
            case 20:
            case 21:
                target &= -16777216;
                u += 1;
                break;
            case 64:
            case 65:
                {
                    target &= -16777216;
                    let n = this.readUnsignedShort(u + 1);
                    context.start = new Array(n);
                    context.end = new Array(n);
                    context.index = new Array(n);
                    u += 3;
                    for (let i = 0; i < n; ++i) {
                        let start = this.readUnsignedShort(u);
                        let length = this.readUnsignedShort(u + 2);
                        context.start[i] = this.readLabel(start, context.labels);
                        context.end[i] = this.readLabel(start + length, context.labels);
                        context.index[i] = this.readUnsignedShort(u + 4);
                        u += 6;
                    }
                    break;
                }
            case 71:
            case 72:
            case 73:
            case 74:
            case 75:
                target &= -16776961;
                u += 4;
                break;
            default:
                target &= (target >>> 24) < 67 ? -256 : -16777216;
                u += 3;
                break;
        }
        let pathLength = this.readByte(u);
        context.typeRef = target;
        context.typePath = pathLength === 0 ? null : new TypePath(this.buf, u);
        return u + 1 + 2 * pathLength;
    }
    /**
     * Reads parameter annotations and makes the given visitor visit them.
     *
     * @param mv      the visitor that must visit the annotations.
     * @param context information about the class being parsed.
     * @param v       start offset in {@link #b b} of the annotations to be read.
     * @param visible <tt>true</tt> if the annotations to be read are visible at
     * runtime.
     */
    readParameterAnnotations(mv, context, v, visible) {
        let i;
        let n = this.buf[v++] & 255;
        let synthetics = Type.getArgumentTypes(context.desc).length - n;
        let av = null;
        for (i = 0; i < synthetics; ++i) {
            av = mv.visitParameterAnnotation(i, "Ljava/lang/Synthetic;", false);
            if (av != null) {
                av.visitEnd();
            }
        }
        let c = context.buffer;
        for (; i < n + synthetics; ++i) {
            let j = this.readUnsignedShort(v);
            v += 2;
            for (; j > 0; --j) {
                av = mv.visitParameterAnnotation(i, this.readUTF8(v, c), visible);
                v = this.readAnnotationValues(v + 2, c, true, av);
            }
        }
    }
    /**
     * Reads the values of an annotation and makes the given visitor visit them.
     *
     * @param v     the start offset in {@link #b b} of the values to be read
     * (including the unsigned short that gives the number of
     * values).
     * @param buf   buffer to be used to call {@link #readUTF8 readUTF8},
     * {@link #readClass(int, int[]) readClass} or {@link #readConst
     * readConst}.
     * @param named if the annotation values are named or not.
     * @param av    the visitor that must visit the values.
     * @return the end offset of the annotation values.
     */
    readAnnotationValues(v, buf, named, av) {
        let i = this.readUnsignedShort(v);
        v += 2;
        if (named) {
            for (; i > 0; --i) {
                v = this.readAnnotationValue(v + 2, buf, this.readUTF8(v, buf), av);
            }
        }
        else {
            for (; i > 0; --i) {
                v = this.readAnnotationValue(v, buf, null, av);
            }
        }
        if (av != null) {
            av.visitEnd();
        }
        return v;
    }
    /**
     * Reads a value of an annotation and makes the given visitor visit it.
     *
     * @param v    the start offset in {@link #b b} of the value to be read
     * (<i>not including the value name constant pool index</i>).
     * @param buf  buffer to be used to call {@link #readUTF8 readUTF8},
     * {@link #readClass(int, int[]) readClass} or {@link #readConst
     * readConst}.
     * @param name the name of the value to be read.
     * @param av   the visitor that must visit the value.
     * @return the end offset of the annotation value.
     */
    readAnnotationValue(v, buf, name, av) {
        name = name !== null && name !== void 0 ? name : "";
        let i;
        if (av == null) {
            switch ((this.buf[v] & 255)) {
                case ("e").charCodeAt(0):
                    return v + 5;
                case ("@").charCodeAt(0):
                    return this.readAnnotationValues(v + 3, buf, true, null);
                case ("[").charCodeAt(0):
                    return this.readAnnotationValues(v + 1, buf, false, null);
                default:
                    return v + 3;
            }
        }
        switch ((this.buf[v++] & 255)) {
            case ("I").charCodeAt(0):
            case ("J").charCodeAt(0):
            case ("F").charCodeAt(0):
            case ("D").charCodeAt(0):
                av.visit(name, this.readConst(this.readUnsignedShort(v), buf));
                v += 2;
                break;
            case ("B").charCodeAt(0):
                av.visit(name, (this.readInt(this.items[this.readUnsignedShort(v)]) | 0));
                v += 2;
                break;
            case ("Z").charCodeAt(0):
                av.visit(name, this.readInt(this.items[this.readUnsignedShort(v)]) === 0 ? false : true);
                v += 2;
                break;
            case ("S").charCodeAt(0):
                av.visit(name, (this.readInt(this.items[this.readUnsignedShort(v)]) | 0));
                v += 2;
                break;
            case ("C").charCodeAt(0):
                av.visit(name, String.fromCharCode(this.readInt(this.items[this.readUnsignedShort(v)])));
                v += 2;
                break;
            case ("s").charCodeAt(0):
                av.visit(name, this.readUTF8(v, buf));
                v += 2;
                break;
            case ("e").charCodeAt(0):
                av.visitEnum(name, this.readUTF8(v, buf), this.readUTF8(v + 2, buf));
                v += 4;
                break;
            case ("c").charCodeAt(0):
                av.visit(name, Type.getType(this.readUTF8(v, buf)));
                v += 2;
                break;
            case ("@").charCodeAt(0):
                v = this.readAnnotationValues(v + 2, buf, true, av.visitAnnotation(name, this.readUTF8(v, buf)));
                break;
            case ("[").charCodeAt(0):
                let size = this.readUnsignedShort(v);
                v += 2;
                if (size === 0) {
                    return this.readAnnotationValues(v - 2, buf, false, av.visitArray(name));
                }
                switch ((this.buf[v++] & 255)) {
                    case ("B").charCodeAt(0):
                        let bv = new Array(size);
                        for (i = 0; i < size; i++) {
                            bv[i] = (this.readInt(this.items[this.readUnsignedShort(v)]) | 0);
                            v += 3;
                        }
                        av.visit(name, bv);
                        --v;
                        break;
                    case ("Z").charCodeAt(0):
                        let zv = new Array(size);
                        for (i = 0; i < size; i++) {
                            zv[i] = this.readInt(this.items[this.readUnsignedShort(v)]) !== 0;
                            v += 3;
                        }
                        av.visit(name, zv);
                        --v;
                        break;
                    case ("S").charCodeAt(0):
                        let sv = new Array(size);
                        for (i = 0; i < size; i++) {
                            sv[i] = (this.readInt(this.items[this.readUnsignedShort(v)]) | 0);
                            v += 3;
                        }
                        av.visit(name, sv);
                        --v;
                        break;
                    case ("C").charCodeAt(0):
                        let cv = new Array(size);
                        for (i = 0; i < size; i++) {
                            cv[i] = String.fromCharCode(this.readInt(this.items[this.readUnsignedShort(v)]));
                            v += 3;
                        }
                        av.visit(name, cv);
                        --v;
                        break;
                    case ("I").charCodeAt(0):
                        let iv = new Array(size);
                        for (i = 0; i < size; i++) {
                            iv[i] = this.readInt(this.items[this.readUnsignedShort(v)]);
                            v += 3;
                        }
                        av.visit(name, iv);
                        --v;
                        break;
                    case ("J").charCodeAt(0):
                        let lv = new Array(size);
                        for (i = 0; i < size; i++) {
                            lv[i] = this.readLong(this.items[this.readUnsignedShort(v)]);
                            v += 3;
                        }
                        av.visit(name, lv);
                        --v;
                        break;
                    case ("F").charCodeAt(0):
                        let fv = new Array(size);
                        for (i = 0; i < size; i++) {
                            fv[i] = intBitsToFloat(this.readInt(this.items[this.readUnsignedShort(v)]));
                            v += 3;
                        }
                        av.visit(name, fv);
                        --v;
                        break;
                    case ("D").charCodeAt(0):
                        let dv = new Array(size);
                        for (i = 0; i < size; i++) {
                            dv[i] = longBitsToDouble(this.readLong(this.items[this.readUnsignedShort(v)]));
                            v += 3;
                        }
                        av.visit(name, dv);
                        --v;
                        break;
                    default:
                        v = this.readAnnotationValues(v - 3, buf, false, av.visitArray(name));
                }
        }
        return v;
    }
    /**
     * Computes the implicit frame of the method currently being parsed (as
     * defined in the given {@link Context}) and stores it in the given context.
     *
     * @param frame information about the class being parsed.
     */
    getImplicitFrame(frame) {
        let desc = frame.desc;
        let locals = frame.local;
        let local = 0;
        if ((frame.access & Opcodes.ACC_STATIC) === 0) {
            if (("<init>" === frame.name)) {
                locals[local++] = Opcodes.UNINITIALIZED_THIS;
            }
            else {
                locals[local++] = this.readClass(this.header + 2, frame.buffer);
            }
        }
        let i = 1;
        loop: while ((true)) {
            let j = i;
            switch (((desc.charAt(i++)).charCodeAt(0))) {
                case ("Z").charCodeAt(0):
                case ("C").charCodeAt(0):
                case ("B").charCodeAt(0):
                case ("S").charCodeAt(0):
                case ("I").charCodeAt(0):
                    locals[local++] = Opcodes.INTEGER;
                    break;
                case ("F").charCodeAt(0):
                    locals[local++] = Opcodes.FLOAT;
                    break;
                case ("J").charCodeAt(0):
                    locals[local++] = Opcodes.LONG;
                    break;
                case ("D").charCodeAt(0):
                    locals[local++] = Opcodes.DOUBLE;
                    break;
                case ("[").charCodeAt(0):
                    while ((desc.charAt(i) === ("["))) {
                        ++i;
                    }
                    if (desc.charAt(i) === ("L")) {
                        ++i;
                        while ((desc.charAt(i) !== (";"))) {
                            ++i;
                        }
                    }
                    locals[local++] = desc.substring(j, ++i);
                    break;
                case ("L").charCodeAt(0):
                    while ((desc.charAt(i) !== (";"))) {
                        ++i;
                    }
                    locals[local++] = desc.substring(j + 1, i++);
                    break;
                default:
                    break loop;
            }
        }
        frame.localCount = local;
    }
    /**
     * Reads a stack map frame and stores the result in the given
     * {@link Context} object.
     *
     * @param stackMap the start offset of a stack map frame in the class file.
     * @param zip      if the stack map frame at stackMap is compressed or not.
     * @param unzip    if the stack map frame must be uncompressed.
     * @param frame    where the parsed stack map frame must be stored.
     * @return the offset of the first byte following the parsed frame.
     */
    readFrame(stackMap, zip, unzip, frame) {
        let c = frame.buffer;
        let labels = frame.labels;
        let tag;
        let delta;
        if (zip) {
            tag = this.buf[stackMap++] & 255;
        }
        else {
            tag = MethodWriter.FULL_FRAME;
            frame.offset = -1;
        }
        frame.localDiff = 0;
        if (tag < MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME) {
            delta = tag;
            frame.mode = Opcodes.F_SAME;
            frame.stackCount = 0;
        }
        else if (tag < MethodWriter.RESERVED) {
            delta = tag - MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME;
            stackMap = this.readFrameType(frame.stack, 0, stackMap, c, labels);
            frame.mode = Opcodes.F_SAME1;
            frame.stackCount = 1;
        }
        else {
            delta = this.readUnsignedShort(stackMap);
            stackMap += 2;
            if (tag === MethodWriter.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {
                stackMap = this.readFrameType(frame.stack, 0, stackMap, c, labels);
                frame.mode = Opcodes.F_SAME1;
                frame.stackCount = 1;
            }
            else if (tag >= MethodWriter.CHOP_FRAME && tag < MethodWriter.SAME_FRAME_EXTENDED) {
                frame.mode = Opcodes.F_CHOP;
                frame.localDiff = MethodWriter.SAME_FRAME_EXTENDED - tag;
                frame.localCount -= frame.localDiff;
                frame.stackCount = 0;
            }
            else if (tag === MethodWriter.SAME_FRAME_EXTENDED) {
                frame.mode = Opcodes.F_SAME;
                frame.stackCount = 0;
            }
            else if (tag < MethodWriter.FULL_FRAME) {
                let local = unzip ? frame.localCount : 0;
                for (let i = tag - MethodWriter.SAME_FRAME_EXTENDED; i > 0; i--) {
                    stackMap = this.readFrameType(frame.local, local++, stackMap, c, labels);
                }
                frame.mode = Opcodes.F_APPEND;
                frame.localDiff = tag - MethodWriter.SAME_FRAME_EXTENDED;
                frame.localCount += frame.localDiff;
                frame.stackCount = 0;
            }
            else {
                frame.mode = Opcodes.F_FULL;
                let n = this.readUnsignedShort(stackMap);
                stackMap += 2;
                frame.localDiff = n;
                frame.localCount = n;
                for (let local = 0; n > 0; n--) {
                    stackMap = this.readFrameType(frame.local, local++, stackMap, c, labels);
                }
                n = this.readUnsignedShort(stackMap);
                stackMap += 2;
                frame.stackCount = n;
                for (let stack = 0; n > 0; n--) {
                    stackMap = this.readFrameType(frame.stack, stack++, stackMap, c, labels);
                }
            }
        }
        frame.offset += delta + 1;
        this.readLabel(frame.offset, labels);
        return stackMap;
    }
    /**
     * Reads a stack map frame type and stores it at the given index in the
     * given array.
     *
     * @param frame  the array where the parsed type must be stored.
     * @param index  the index in 'frame' where the parsed type must be stored.
     * @param v      the start offset of the stack map frame type to read.
     * @param buf    a buffer to read strings.
     * @param labels the labels of the method currently being parsed, indexed by
     * their offset. If the parsed type is an Uninitialized type, a
     * new label for the corresponding NEW instruction is stored in
     * this array if it does not already exist.
     * @return the offset of the first byte after the parsed type.
     */
    readFrameType(frame, index, v, buf, labels) {
        let type = this.buf[v++] & 255;
        switch ((type)) {
            case 0:
                frame[index] = Opcodes.TOP;
                break;
            case 1:
                frame[index] = Opcodes.INTEGER;
                break;
            case 2:
                frame[index] = Opcodes.FLOAT;
                break;
            case 3:
                frame[index] = Opcodes.DOUBLE;
                break;
            case 4:
                frame[index] = Opcodes.LONG;
                break;
            case 5:
                frame[index] = Opcodes.NULL;
                break;
            case 6:
                frame[index] = Opcodes.UNINITIALIZED_THIS;
                break;
            case 7:
                frame[index] = this.readClass(v, buf);
                v += 2;
                break;
            default:
                frame[index] = this.readLabel(this.readUnsignedShort(v), labels);
                v += 2;
        }
        return v;
    }
    /**
     * Returns the label corresponding to the given offset. The default
     * implementation of this method creates a label for the given offset if it
     * has not been already created.
     *
     * @param offset a bytecode offset in a method.
     * @param labels the already created labels, indexed by their offset. If a
     * label already exists for offset this method must not create a
     * new one. Otherwise it must store the new label in this array.
     * @return a non null Label, which must be equal to labels[offset].
     */
    readLabel(offset, labels) {
        if (labels[offset] == null) {
            labels[offset] = new Label();
        }
        return labels[offset];
    }
    /**
     * Returns the start index of the attribute_info structure of this class.
     *
     * @return the start index of the attribute_info structure of this class.
     */
    getAttributes() {
        let u = this.header + 8 + this.readUnsignedShort(this.header + 6) * 2;
        for (let i = this.readUnsignedShort(u); i > 0; --i) {
            for (let j = this.readUnsignedShort(u + 8); j > 0; --j) {
                u += 6 + this.readInt(u + 12);
            }
            u += 8;
        }
        u += 2;
        for (let i = this.readUnsignedShort(u); i > 0; --i) {
            for (let j = this.readUnsignedShort(u + 8); j > 0; --j) {
                u += 6 + this.readInt(u + 12);
            }
            u += 8;
        }
        return u + 2;
    }
    /**
     * Reads an attribute in {@link #b b}.
     *
     * @param attrs   prototypes of the attributes that must be parsed during the
     * visit of the class. Any attribute whose type is not equal to
     * the type of one the prototypes is ignored (i.e. an empty
     * {@link Attribute} instance is returned).
     * @param type    the type of the attribute.
     * @param off     index of the first byte of the attribute's content in
     * {@link #b b}. The 6 attribute header bytes, containing the
     * type and the length of the attribute, are not taken into
     * account here (they have already been read).
     * @param len     the length of the attribute's content.
     * @param buf     buffer to be used to call {@link #readUTF8 readUTF8},
     * {@link #readClass(int, int[]) readClass} or {@link #readConst
     * readConst}.
     * @param codeOff index of the first byte of code's attribute content in
     * {@link #b b}, or -1 if the attribute to be read is not a code
     * attribute. The 6 attribute header bytes, containing the type
     * and the length of the attribute, are not taken into account
     * here.
     * @param labels  the labels of the method's code, or <tt>null</tt> if the
     * attribute to be read is not a code attribute.
     * @return the attribute that has been read, or <tt>null</tt> to skip this
     * attribute.
     */
    readAttribute(attrs, type, off, len, buf, codeOff, labels) {
        for (let i = 0; i < attrs.length; ++i) {
            if ((attrs[i].type === type)) {
                return attrs[i].read(this, off, len, buf, codeOff, labels);
            }
        }
        return new Attribute(type).read(this, off, len, null, -1, null);
    }
    /**
     * Returns the number of constant pool items in {@link #b b}.
     *
     * @return the number of constant pool items in {@link #b b}.
     */
    getItemCount() {
        return this.items.length;
    }
    /**
     * Returns the start index of the constant pool item in {@link #b b}, plus
     * one. <i>This method is intended for {@link Attribute} sub classes, and is
     * normally not needed by class generators or adapters.</i>
     *
     * @param item the index a constant pool item.
     * @return the start index of the constant pool item in {@link #b b}, plus
     * one.
     */
    getItem(item) {
        return this.items[item];
    }
    /**
     * Returns the maximum length of the strings contained in the constant pool
     * of the class.
     *
     * @return the maximum length of the strings contained in the constant pool
     * of the class.
     */
    getMaxStringLength() {
        return this.maxStringLength;
    }
    /**
     * Reads a byte value in {@link #b b}. <i>This method is intended for
     * {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.</i>
     *
     * @param index the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    readByte(index) {
        // return this.buf.readInt8(index);
        return this.buf[index] & 255;
    }
    /**
     * Reads an unsigned short value in {@link #b b}. <i>This method is intended
     * for {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.</i>
     *
     * @param index the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    readUnsignedShort(index) {
        // return this.buf.readUInt16BE(index);
        let b = this.buf;
        return ((b[index] & 255) << 8) | (b[index + 1] & 255);
    }
    /**
     * Reads a signed short value in {@link #b b}. <i>This method is intended
     * for {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.</i>
     *
     * @param index the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    readShort(index) {
        let b = this.buf;
        return (b[index] << 8) | (b[index + 1]);
    }
    /**
     * Reads a signed int value in {@link #b b}. <i>This method is intended for
     * {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.</i>
     *
     * @param index the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    readInt(index) {
        // return this.buf.readInt32BE(index);
        let b = this.buf;
        return ((b[index] & 255) << 24) | ((b[index + 1] & 255) << 16) | ((b[index + 2] & 255) << 8) | (b[index + 3]);
    }
    /**
     * Reads a signed long value in {@link #b b}. <i>This method is intended for
     * {@link Attribute} sub classes, and is normally not needed by class
     * generators or adapters.</i>
     *
     * @param index the start index of the value to be read in {@link #b b}.
     * @return the read value.
     */
    readLong(index) {
        let l1 = this.readInt(index);
        let l0 = this.readInt(index + 4) & 4294967295;
        return new long_1(l1, l0);
    }
    /**
     * Reads an UTF8 string constant pool item in {@link #b b}. <i>This method
     * is intended for {@link Attribute} sub classes, and is normally not needed
     * by class generators or adapters.</i>
     *
     * @param index the start index of an unsigned short value in {@link #b b},
     * whose value is the index of an UTF8 constant pool item.
     * @param buf   buffer to be used to read the item. This buffer must be
     * sufficiently large. It is not automatically resized.
     * @return the String corresponding to the specified UTF8 item.
     */
    readUTF8(index, buf) {
        let item = this.readUnsignedShort(index);
        if (index === 0 || item === 0) {
            return "";
        }
        let s = this.strings[item];
        if (s != null) {
            return s;
        }
        index = this.items[item];
        this.strings[item] = this.readUTF(index + 2, this.readUnsignedShort(index), buf);
        return this.strings[item];
    }
    /**
     * Reads UTF8 string in {@link #b b}.
     *
     * @param index  start offset of the UTF8 string to be read.
     * @param utfLen length of the UTF8 string to be read.
     * @param buf    buffer to be used to read the string. This buffer must be
     * sufficiently large. It is not automatically resized.
     * @return the String corresponding to the specified UTF8 string.
     */
    readUTF(index, utfLen, buf) {
        let endIndex = index + utfLen;
        let b = this.buf;
        let strLen = 0;
        let c;
        let st = 0;
        let cc = 0;
        while (index < endIndex) {
            c = b[index++];
            switch (st) {
                case 0:
                    c = c & 255;
                    if (c < 128) {
                        buf[strLen++] = c;
                    }
                    else if (c < 224 && c > 191) {
                        cc = (c & 31);
                        st = 1;
                    }
                    else {
                        cc = (c & 15);
                        st = 2;
                    }
                    break;
                case 1:
                    buf[strLen++] = ((cc << 6) | (c & 63));
                    st = 0;
                    break;
                case 2:
                    cc = ((cc << 6) | (c & 63));
                    st = 1;
                    break;
            }
        }
        return buf.slice(0, strLen).map((c) => String.fromCharCode(c)).join("");
    }
    /**
     * Reads a class constant pool item in {@link #b b}. <i>This method is
     * intended for {@link Attribute} sub classes, and is normally not needed by
     * class generators or adapters.</i>
     *
     * @param index the start index of an unsigned short value in {@link #b b},
     * whose value is the index of a class constant pool item.
     * @param buf   buffer to be used to read the item. This buffer must be
     * sufficiently large. It is not automatically resized.
     * @return the String corresponding to the specified class item.
     */
    readClass(index, buf) {
        var _a;
        return (_a = this.readUTF8(this.items[this.readUnsignedShort(index)], buf)) !== null && _a !== void 0 ? _a : "";
    }
    /**
     * Reads a numeric or string constant pool item in {@link #b b}. <i>This
     * method is intended for {@link Attribute} sub classes, and is normally not
     * needed by class generators or adapters.</i>
     *
     * @param item the index of a constant pool item.
     * @param buf  buffer to be used to read the item. This buffer must be
     * sufficiently large. It is not automatically resized.
     * @return the {@link Integer}, {@link Float}, {@link Long}, {@link Double},
     * {@link String}, {@link Type} or {@link Handle} corresponding to
     * the given constant pool item.
     */
    readConst(item, buf) {
        let index = this.items[item];
        switch ((this.buf[index - 1])) {
            case ClassWriter.INT:
                return this.readInt(index);
            case ClassWriter.FLOAT:
                return intBitsToFloat(this.readInt(index));
            case ClassWriter.LONG:
                return this.readLong(index);
            case ClassWriter.DOUBLE:
                return longBitsToDouble(this.readLong(index));
            case ClassWriter.CLASS:
                return Type.getObjectType(this.readUTF8(index, buf));
            case ClassWriter.STR:
                return this.readUTF8(index, buf);
            case ClassWriter.MTYPE:
                return Type.getMethodType(this.readUTF8(index, buf));
            default:
                let tag = this.readByte(index);
                let items = this.items;
                let cpIndex = items[this.readUnsignedShort(index + 1)];
                let itf = this.buf[cpIndex - 1] === ClassWriter.IMETH;
                let owner = this.readClass(cpIndex, buf);
                cpIndex = items[this.readUnsignedShort(cpIndex + 2)];
                let name = this.readUTF8(cpIndex, buf);
                let desc = this.readUTF8(cpIndex + 2, buf);
                return new Handle(tag, owner, name, desc, itf);
        }
    }
}
/**
* True to enable signatures support.
*/
ClassReader.SIGNATURES = true;
/**
 * True to enable annotations support.
 */
ClassReader.ANNOTATIONS = true;
/**
 * True to enable stack map frames support.
 */
ClassReader.FRAMES = true;
/**
 * True to enable bytecode writing support.
 */
ClassReader.WRITER = true;
/**
 * True to enable JSR_W and GOTO_W support.
 */
ClassReader.RESIZE = true;
/**
 * Flag to skip method code. If this class is set <code>CODE</code>
 * attribute won't be visited. This can be used, for example, to retrieve
 * annotations for methods and method parameters.
 */
ClassReader.SKIP_CODE = 1;
/**
 * Flag to skip the debug information in the class. If this flag is set the
 * debug information of the class is not visited, i.e. the
 * {@link MethodVisitor#visitLocalVariable visitLocalVariable} and
 * {@link MethodVisitor#visitLineNumber visitLineNumber} methods will not be
 * called.
 */
ClassReader.SKIP_DEBUG = 2;
/**
 * Flag to skip the stack map frames in the class. If this flag is set the
 * stack map frames of the class is not visited, i.e. the
 * {@link MethodVisitor#visitFrame visitFrame} method will not be called.
 * This flag is useful when the {@link ClassWriter#COMPUTE_FRAMES} option is
 * used: it avoids visiting frames that will be ignored and recomputed from
 * scratch in the class writer.
 */
ClassReader.SKIP_FRAMES = 4;
/**
 * Flag to expand the stack map frames. By default stack map frames are
 * visited in their original format (i.e. "expanded" for classes whose
 * version is less than V1_6, and "compressed" for the other classes). If
 * this flag is set, stack map frames are always visited in expanded format
 * (this option adds a decompression/recompression step in ClassReader and
 * ClassWriter which degrades performances quite a lot).
 */
ClassReader.EXPAND_FRAMES = 8;
/**
 * Flag to expand the ASM pseudo instructions into an equivalent sequence of
 * standard bytecode instructions. When resolving a forward jump it may
 * happen that the signed 2 bytes offset reserved for it is not sufficient
 * to store the bytecode offset. In this case the jump instruction is
 * replaced with a temporary ASM pseudo instruction using an unsigned 2
 * bytes offset (see Label#resolve). This internal flag is used to re-read
 * classes containing such instructions, in order to replace them with
 * standard instructions. In addition, when this flag is used, GOTO_W and
 * JSR_W are <i>not</i> converted into GOTO and JSR, to make sure that
 * infinite loops where a GOTO_W is replaced with a GOTO in ClassReader and
 * converted back to a GOTO_W in ClassWriter cannot occur.
 */
ClassReader.EXPAND_ASM_INSNS = 256;

/*
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/* Generated from Java with JSweet 1.2.0-SNAPSHOT - http://www.jsweet.org */
/**
 * A reference to a type appearing in a class, field or method declaration, or
 * on an instruction. Such a reference designates the part of the class where
 * the referenced type is appearing (e.g. an 'extends', 'implements' or 'throws'
 * clause, a 'new' instruction, a 'catch' clause, a type cast, a local variable
 * declaration, etc).
 *
 * @author Eric Bruneton
 */
class TypeReference {
    /**
     * Creates a new TypeReference.
     *
     * @param typeRef
     * the int encoded value of the type reference, as received in a
     * visit method related to type annotations, like
     * visitTypeAnnotation.
     */
    constructor(typeRef) {
        this.value = 0;
        this.value = typeRef;
    }
    /**
     * Returns a type reference of the given sort.
     *
     * @param sort
     * {@link #FIELD FIELD}, {@link #METHOD_RETURN METHOD_RETURN},
     * {@link #METHOD_RECEIVER METHOD_RECEIVER},
     * {@link #LOCAL_VARIABLE LOCAL_VARIABLE},
     * {@link #RESOURCE_VARIABLE RESOURCE_VARIABLE},
     * {@link #INSTANCEOF INSTANCEOF}, {@link #NEW NEW},
     * {@link #CONSTRUCTOR_REFERENCE CONSTRUCTOR_REFERENCE}, or
     * {@link #METHOD_REFERENCE METHOD_REFERENCE}.
     * @return a type reference of the given sort.
     */
    static newTypeReference(sort) {
        return new TypeReference(sort << 24);
    }
    /**
     * Returns a reference to a type parameter of a generic class or method.
     *
     * @param sort
     * {@link #CLASS_TYPE_PARAMETER CLASS_TYPE_PARAMETER} or
     * {@link #METHOD_TYPE_PARAMETER METHOD_TYPE_PARAMETER}.
     * @param paramIndex
     * the type parameter index.
     * @return a reference to the given generic class or method type parameter.
     */
    static newTypeParameterReference(sort, paramIndex) {
        return new TypeReference((sort << 24) | (paramIndex << 16));
    }
    /**
     * Returns a reference to a type parameter bound of a generic class or
     * method.
     *
     * @param sort
     * {@link #CLASS_TYPE_PARAMETER CLASS_TYPE_PARAMETER} or
     * {@link #METHOD_TYPE_PARAMETER METHOD_TYPE_PARAMETER}.
     * @param paramIndex
     * the type parameter index.
     * @param boundIndex
     * the type bound index within the above type parameters.
     * @return a reference to the given generic class or method type parameter
     * bound.
     */
    static newTypeParameterBoundReference(sort, paramIndex, boundIndex) {
        return new TypeReference((sort << 24) | (paramIndex << 16) | (boundIndex << 8));
    }
    /**
     * Returns a reference to the super class or to an interface of the
     * 'implements' clause of a class.
     *
     * @param itfIndex
     * the index of an interface in the 'implements' clause of a
     * class, or -1 to reference the super class of the class.
     * @return a reference to the given super type of a class.
     */
    static newSuperTypeReference(itfIndex) {
        itfIndex &= 65535;
        return new TypeReference((TypeReference.CLASS_EXTENDS << 24) | (itfIndex << 8));
    }
    /**
     * Returns a reference to the type of a formal parameter of a method.
     *
     * @param paramIndex
     * the formal parameter index.
     *
     * @return a reference to the type of the given method formal parameter.
     */
    static newFormalParameterReference(paramIndex) {
        return new TypeReference((TypeReference.METHOD_FORMAL_PARAMETER << 24) | (paramIndex << 16));
    }
    /**
     * Returns a reference to the type of an exception, in a 'throws' clause of
     * a method.
     *
     * @param exceptionIndex
     * the index of an exception in a 'throws' clause of a method.
     *
     * @return a reference to the type of the given exception.
     */
    static newExceptionReference(exceptionIndex) {
        return new TypeReference((TypeReference.THROWS << 24) | (exceptionIndex << 8));
    }
    /**
     * Returns a reference to the type of the exception declared in a 'catch'
     * clause of a method.
     *
     * @param tryCatchBlockIndex
     * the index of a try catch block (using the order in which they
     * are visited with visitTryCatchBlock).
     *
     * @return a reference to the type of the given exception.
     */
    static newTryCatchReference(tryCatchBlockIndex) {
        return new TypeReference((TypeReference.EXCEPTION_PARAMETER << 24) | (tryCatchBlockIndex << 8));
    }
    /**
     * Returns a reference to the type of a type argument in a constructor or
     * method call or reference.
     *
     * @param sort
     * {@link #CAST CAST},
     * {@link #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
     * CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT},
     * {@link #METHOD_INVOCATION_TYPE_ARGUMENT
     * METHOD_INVOCATION_TYPE_ARGUMENT},
     * {@link #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
     * CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or
     * {@link #METHOD_REFERENCE_TYPE_ARGUMENT
     * METHOD_REFERENCE_TYPE_ARGUMENT}.
     * @param argIndex
     * the type argument index.
     *
     * @return a reference to the type of the given type argument.
     */
    static newTypeArgumentReference(sort, argIndex) {
        return new TypeReference((sort << 24) | argIndex);
    }
    /**
     * Returns the sort of this type reference.
     *
     * @return {@link #CLASS_TYPE_PARAMETER CLASS_TYPE_PARAMETER},
     * {@link #METHOD_TYPE_PARAMETER METHOD_TYPE_PARAMETER},
     * {@link #CLASS_EXTENDS CLASS_EXTENDS},
     * {@link #CLASS_TYPE_PARAMETER_BOUND CLASS_TYPE_PARAMETER_BOUND},
     * {@link #METHOD_TYPE_PARAMETER_BOUND METHOD_TYPE_PARAMETER_BOUND},
     * {@link #FIELD FIELD}, {@link #METHOD_RETURN METHOD_RETURN},
     * {@link #METHOD_RECEIVER METHOD_RECEIVER},
     * {@link #METHOD_FORMAL_PARAMETER METHOD_FORMAL_PARAMETER},
     * {@link #THROWS THROWS}, {@link #LOCAL_VARIABLE LOCAL_VARIABLE},
     * {@link #RESOURCE_VARIABLE RESOURCE_VARIABLE},
     * {@link #EXCEPTION_PARAMETER EXCEPTION_PARAMETER},
     * {@link #INSTANCEOF INSTANCEOF}, {@link #NEW NEW},
     * {@link #CONSTRUCTOR_REFERENCE CONSTRUCTOR_REFERENCE},
     * {@link #METHOD_REFERENCE METHOD_REFERENCE}, {@link #CAST CAST},
     * {@link #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
     * CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT},
     * {@link #METHOD_INVOCATION_TYPE_ARGUMENT
     * METHOD_INVOCATION_TYPE_ARGUMENT},
     * {@link #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
     * CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or
     * {@link #METHOD_REFERENCE_TYPE_ARGUMENT
     * METHOD_REFERENCE_TYPE_ARGUMENT}.
     */
    getSort() {
        return this.value >>> 24;
    }
    /**
     * Returns the index of the type parameter referenced by this type
     * reference. This method must only be used for type references whose sort
     * is {@link #CLASS_TYPE_PARAMETER CLASS_TYPE_PARAMETER},
     * {@link #METHOD_TYPE_PARAMETER METHOD_TYPE_PARAMETER},
     * {@link #CLASS_TYPE_PARAMETER_BOUND CLASS_TYPE_PARAMETER_BOUND} or
     * {@link #METHOD_TYPE_PARAMETER_BOUND METHOD_TYPE_PARAMETER_BOUND}.
     *
     * @return a type parameter index.
     */
    getTypeParameterIndex() {
        return (this.value & 16711680) >> 16;
    }
    /**
     * Returns the index of the type parameter bound, within the type parameter
     * {@link #getTypeParameterIndex}, referenced by this type reference. This
     * method must only be used for type references whose sort is
     * {@link #CLASS_TYPE_PARAMETER_BOUND CLASS_TYPE_PARAMETER_BOUND} or
     * {@link #METHOD_TYPE_PARAMETER_BOUND METHOD_TYPE_PARAMETER_BOUND}.
     *
     * @return a type parameter bound index.
     */
    getTypeParameterBoundIndex() {
        return (this.value & 65280) >> 8;
    }
    /**
     * Returns the index of the "super type" of a class that is referenced by
     * this type reference. This method must only be used for type references
     * whose sort is {@link #CLASS_EXTENDS CLASS_EXTENDS}.
     *
     * @return the index of an interface in the 'implements' clause of a class,
     * or -1 if this type reference references the type of the super
     * class.
     */
    getSuperTypeIndex() {
        return (((this.value & 16776960) >> 8) | 0);
    }
    /**
     * Returns the index of the formal parameter whose type is referenced by
     * this type reference. This method must only be used for type references
     * whose sort is {@link #METHOD_FORMAL_PARAMETER METHOD_FORMAL_PARAMETER}.
     *
     * @return a formal parameter index.
     */
    getFormalParameterIndex() {
        return (this.value & 16711680) >> 16;
    }
    /**
     * Returns the index of the exception, in a 'throws' clause of a method,
     * whose type is referenced by this type reference. This method must only be
     * used for type references whose sort is {@link #THROWS THROWS}.
     *
     * @return the index of an exception in the 'throws' clause of a method.
     */
    getExceptionIndex() {
        return (this.value & 16776960) >> 8;
    }
    /**
     * Returns the index of the try catch block (using the order in which they
     * are visited with visitTryCatchBlock), whose 'catch' type is referenced by
     * this type reference. This method must only be used for type references
     * whose sort is {@link #EXCEPTION_PARAMETER EXCEPTION_PARAMETER} .
     *
     * @return the index of an exception in the 'throws' clause of a method.
     */
    getTryCatchBlockIndex() {
        return (this.value & 16776960) >> 8;
    }
    /**
     * Returns the index of the type argument referenced by this type reference.
     * This method must only be used for type references whose sort is
     * {@link #CAST CAST}, {@link #CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
     * CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT},
     * {@link #METHOD_INVOCATION_TYPE_ARGUMENT METHOD_INVOCATION_TYPE_ARGUMENT},
     * {@link #CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
     * CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or
     * {@link #METHOD_REFERENCE_TYPE_ARGUMENT METHOD_REFERENCE_TYPE_ARGUMENT}.
     *
     * @return a type parameter index.
     */
    getTypeArgumentIndex() {
        return this.value & 255;
    }
    /**
     * Returns the int encoded value of this type reference, suitable for use in
     * visit methods related to type annotations, like visitTypeAnnotation.
     *
     * @return the int encoded value of this type reference.
     */
    getValue() {
        return this.value;
    }
}
/**
 * The sort of type references that target a type parameter of a generic
 * class. See {@link #getSort getSort}.
 */
TypeReference.CLASS_TYPE_PARAMETER = 0;
/**
 * The sort of type references that target a type parameter of a generic
 * method. See {@link #getSort getSort}.
 */
TypeReference.METHOD_TYPE_PARAMETER = 1;
/**
 * The sort of type references that target the super class of a class or one
 * of the interfaces it implements. See {@link #getSort getSort}.
 */
TypeReference.CLASS_EXTENDS = 16;
/**
 * The sort of type references that target a bound of a type parameter of a
 * generic class. See {@link #getSort getSort}.
 */
TypeReference.CLASS_TYPE_PARAMETER_BOUND = 17;
/**
 * The sort of type references that target a bound of a type parameter of a
 * generic method. See {@link #getSort getSort}.
 */
TypeReference.METHOD_TYPE_PARAMETER_BOUND = 18;
/**
 * The sort of type references that target the type of a field. See
 * {@link #getSort getSort}.
 */
TypeReference.FIELD = 19;
/**
 * The sort of type references that target the return type of a method. See
 * {@link #getSort getSort}.
 */
TypeReference.METHOD_RETURN = 20;
/**
 * The sort of type references that target the receiver type of a method.
 * See {@link #getSort getSort}.
 */
TypeReference.METHOD_RECEIVER = 21;
/**
 * The sort of type references that target the type of a formal parameter of
 * a method. See {@link #getSort getSort}.
 */
TypeReference.METHOD_FORMAL_PARAMETER = 22;
/**
 * The sort of type references that target the type of an exception declared
 * in the throws clause of a method. See {@link #getSort getSort}.
 */
TypeReference.THROWS = 23;
/**
 * The sort of type references that target the type of a local variable in a
 * method. See {@link #getSort getSort}.
 */
TypeReference.LOCAL_VARIABLE = 64;
/**
 * The sort of type references that target the type of a resource variable
 * in a method. See {@link #getSort getSort}.
 */
TypeReference.RESOURCE_VARIABLE = 65;
/**
 * The sort of type references that target the type of the exception of a
 * 'catch' clause in a method. See {@link #getSort getSort}.
 */
TypeReference.EXCEPTION_PARAMETER = 66;
/**
 * The sort of type references that target the type declared in an
 * 'instanceof' instruction. See {@link #getSort getSort}.
 */
TypeReference.INSTANCEOF = 67;
/**
 * The sort of type references that target the type of the object created by
 * a 'new' instruction. See {@link #getSort getSort}.
 */
TypeReference.NEW = 68;
/**
 * The sort of type references that target the receiver type of a
 * constructor reference. See {@link #getSort getSort}.
 */
TypeReference.CONSTRUCTOR_REFERENCE = 69;
/**
 * The sort of type references that target the receiver type of a method
 * reference. See {@link #getSort getSort}.
 */
TypeReference.METHOD_REFERENCE = 70;
/**
 * The sort of type references that target the type declared in an explicit
 * or implicit cast instruction. See {@link #getSort getSort}.
 */
TypeReference.CAST = 71;
/**
 * The sort of type references that target a type parameter of a generic
 * constructor in a constructor call. See {@link #getSort getSort}.
 */
TypeReference.CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT = 72;
/**
 * The sort of type references that target a type parameter of a generic
 * method in a method call. See {@link #getSort getSort}.
 */
TypeReference.METHOD_INVOCATION_TYPE_ARGUMENT = 73;
/**
 * The sort of type references that target a type parameter of a generic
 * constructor in a constructor reference. See {@link #getSort getSort}.
 */
TypeReference.CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT = 74;
/**
 * The sort of type references that target a type parameter of a generic
 * method in a method reference. See {@link #getSort getSort}.
 */
TypeReference.METHOD_REFERENCE_TYPE_ARGUMENT = 75;

export { AnnotationVisitor, Attribute, ClassReader, ClassVisitor, FieldVisitor, Handle, Label, MethodVisitor, Opcodes, Type, TypePath, TypeReference };
//# sourceMappingURL=index.esm.js.map
