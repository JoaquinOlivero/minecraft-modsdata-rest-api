import { Handle } from "./Handle";
import { Label } from "./Label";
import { AnnotationVisitor } from "./AnnotationVisitor";
import { TypePath } from "./TypePath";
import { Attribute } from "./Attribute";
export declare abstract class MethodVisitor {
    /**
     * The ASM API version implemented by this visitor. The value of this field
     * must be one of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     */
    api: number;
    /**
     * The method visitor to which this visitor must delegate method calls. May
     * be null.
     */
    mv: MethodVisitor | null;
    /**
     * Constructs a new {@link MethodVisitor}.
     *
     * @param api
     * the ASM API version implemented by this visitor. Must be one
     * of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param mv
     * the method visitor to which this visitor must delegate method
     * calls. May be null.
     */
    constructor(api: number, mv?: MethodVisitor | null);
    /**
     * Visits a parameter of this method.
     *
     * @param name
     * parameter name or null if none is provided.
     * @param access
     * the parameter's access flags, only <tt>ACC_FINAL</tt>,
     * <tt>ACC_SYNTHETIC</tt> or/and <tt>ACC_MANDATED</tt> are
     * allowed (see {@link Opcodes}).
     */
    visitParameter(name: string | null, access: number): void;
    /**
     * Visits the default value of this annotation interface method.
     *
     * @return a visitor to the visit the actual default value of this
     * annotation interface method, or <tt>null</tt> if this visitor is
     * not interested in visiting this default value. The 'name'
     * parameters passed to the methods of this annotation visitor are
     * ignored. Moreover, exacly one visit method must be called on this
     * annotation visitor, followed by visitEnd.
     */
    visitAnnotationDefault(): AnnotationVisitor | null;
    /**
     * Visits an annotation of this method.
     *
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitAnnotation(desc: string | null, visible: boolean): AnnotationVisitor | null;
    /**
     * Visits an annotation on a type in the method signature.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#METHOD_TYPE_PARAMETER
     * METHOD_TYPE_PARAMETER},
     * {@link TypeReference#METHOD_TYPE_PARAMETER_BOUND
     * METHOD_TYPE_PARAMETER_BOUND},
     * {@link TypeReference#METHOD_RETURN METHOD_RETURN},
     * {@link TypeReference#METHOD_RECEIVER METHOD_RECEIVER},
     * {@link TypeReference#METHOD_FORMAL_PARAMETER
     * METHOD_FORMAL_PARAMETER} or {@link TypeReference#THROWS
     * THROWS}. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitTypeAnnotation(typeRef: number, typePath: TypePath | null, desc: string | null, visible: boolean): AnnotationVisitor | null;
    /**
     * Visits an annotation of a parameter this method.
     *
     * @param parameter
     * the parameter index.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitParameterAnnotation(parameter: number, desc: string | null, visible: boolean): AnnotationVisitor | null;
    /**
     * Visits a non standard attribute of this method.
     *
     * @param attr
     * an attribute.
     */
    visitAttribute(attr: Attribute): void;
    /**
     * Starts the visit of the method's code, if any (i.e. non abstract method).
     */
    visitCode(): void;
    /**
     * Visits the current state of the local variables and operand stack
     * elements. This method must(*) be called <i>just before</i> any
     * instruction <b>i</b> that follows an unconditional branch instruction
     * such as GOTO or THROW, that is the target of a jump instruction, or that
     * starts an exception handler block. The visited types must describe the
     * values of the local variables and of the operand stack elements <i>just
     * before</i> <b>i</b> is executed.<br>
     * <br>
     * (*) this is mandatory only for classes whose version is greater than or
     * equal to {@link Opcodes#V1_6 V1_6}. <br>
     * <br>
     * The frames of a method must be given either in expanded form, or in
     * compressed form (all frames must use the same format, i.e. you must not
     * mix expanded and compressed frames within a single method):
     * <ul>
     * <li>In expanded form, all frames must have the F_NEW type.</li>
     * <li>In compressed form, frames are basically "deltas" from the state of
     * the previous frame:
     * <ul>
     * <li>{@link Opcodes#F_SAME} representing frame with exactly the same
     * locals as the previous frame and with the empty stack.</li>
     * <li>{@link Opcodes#F_SAME1} representing frame with exactly the same
     * locals as the previous frame and with single value on the stack (
     * <code>nStack</code> is 1 and <code>stack[0]</code> contains value for the
     * type of the stack item).</li>
     * <li>{@link Opcodes#F_APPEND} representing frame with current locals are
     * the same as the locals in the previous frame, except that additional
     * locals are defined (<code>nLocal</code> is 1, 2 or 3 and
     * <code>local</code> elements contains values representing added types).</li>
     * <li>{@link Opcodes#F_CHOP} representing frame with current locals are the
     * same as the locals in the previous frame, except that the last 1-3 locals
     * are absent and with the empty stack (<code>nLocals</code> is 1, 2 or 3).</li>
     * <li>{@link Opcodes#F_FULL} representing complete frame data.</li>
     * </ul>
     * </li>
     * </ul>
     * <br>
     * In both cases the first frame, corresponding to the method's parameters
     * and access flags, is implicit and must not be visited. Also, it is
     * illegal to visit two or more frames for the same code location (i.e., at
     * least one instruction must be visited between two calls to visitFrame).
     *
     * @param type
     * the type of this stack map frame. Must be
     * {@link Opcodes#F_NEW} for expanded frames, or
     * {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},
     * {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or
     * {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for
     * compressed frames.
     * @param nLocal
     * the number of local variables in the visited frame.
     * @param local
     * the local variable types in this frame. This array must not be
     * modified. Primitive types are represented by
     * {@link Opcodes#TOP}, {@link Opcodes#INTEGER},
     * {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
     * {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
     * {@link Opcodes#UNINITIALIZED_THIS} (long and double are
     * represented by a single element). Reference types are
     * represented by String objects (representing internal names),
     * and uninitialized types by Label objects (this label
     * designates the NEW instruction that created this uninitialized
     * value).
     * @param nStack
     * the number of operand stack elements in the visited frame.
     * @param stack
     * the operand stack types in this frame. This array must not be
     * modified. Its content has the same format as the "local"
     * array.
     * @throws IllegalStateException
     * if a frame is visited just after another one, without any
     * instruction between the two (unless this frame is a
     * Opcodes#F_SAME frame, in which case it is silently ignored).
     */
    visitFrame(type?: any, nLocal?: any, local?: any, nStack?: any, stack?: any): any;
    /**
     * Visits a zero operand instruction.
     *
     * @param opcode
     * the opcode of the instruction to be visited. This opcode is
     * either NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1,
     * ICONST_2, ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1,
     * FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD,
     * LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD,
     * IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE,
     * SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1,
     * DUP2_X2, SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB,
     * IMUL, LMUL, FMUL, DMUL, IDIV, LDIV, FDIV, DDIV, IREM, LREM,
     * FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR,
     * IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D,
     * L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B, I2C, I2S,
     * LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,
     * DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER,
     * or MONITOREXIT.
     */
    visitInsn(opcode: number): void;
    /**
     * Visits an instruction with a single int operand.
     *
     * @param opcode
     * the opcode of the instruction to be visited. This opcode is
     * either BIPUSH, SIPUSH or NEWARRAY.
     * @param operand
     * the operand of the instruction to be visited.<br>
     * When opcode is BIPUSH, operand value should be between
     * Byte.MIN_VALUE and Byte.MAX_VALUE.<br>
     * When opcode is SIPUSH, operand value should be between
     * Short.MIN_VALUE and Short.MAX_VALUE.<br>
     * When opcode is NEWARRAY, operand value should be one of
     * {@link Opcodes#T_BOOLEAN}, {@link Opcodes#T_CHAR},
     * {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE},
     * {@link Opcodes#T_BYTE}, {@link Opcodes#T_SHORT},
     * {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
     */
    visitIntInsn(opcode: number, operand: number): void;
    /**
     * Visits a local variable instruction. A local variable instruction is an
     * instruction that loads or stores the value of a local variable.
     *
     * @param opcode
     * the opcode of the local variable instruction to be visited.
     * This opcode is either ILOAD, LLOAD, FLOAD, DLOAD, ALOAD,
     * ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
     * @param var
     * the operand of the instruction to be visited. This operand is
     * the index of a local variable.
     */
    visitVarInsn(opcode: number, __var: number): void;
    /**
     * Visits a type instruction. A type instruction is an instruction that
     * takes the internal name of a class as parameter.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.
     * @param type
     * the operand of the instruction to be visited. This operand
     * must be the internal name of an object or array class (see
     * {@link Type#getInternalName() getInternalName}).
     */
    visitTypeInsn(opcode: number, type: string): void;
    /**
     * Visits a field instruction. A field instruction is an instruction that
     * loads or stores the value of a field of an object.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
     * @param owner
     * the internal name of the field's owner class (see
     * {@link Type#getInternalName() getInternalName}).
     * @param name
     * the field's name.
     * @param desc
     * the field's descriptor (see {@link Type Type}).
     */
    visitFieldInsn(opcode: number, owner: string, name: string | null, desc: string | null): void;
    /**
     * Visits a method instruction. A method instruction is an instruction that
     * invokes a method.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or
     * INVOKEINTERFACE.
     * @param owner
     * the internal name of the method's owner class (see
     * {@link Type#getInternalName() getInternalName}).
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor (see {@link Type Type}).
     */
    visitMethodInsn$int$java_lang_String$java_lang_String$java_lang_String(opcode: number, owner: string, name: string, desc: string): void;
    /**
     * Visits a method instruction. A method instruction is an instruction that
     * invokes a method.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or
     * INVOKEINTERFACE.
     * @param owner
     * the internal name of the method's owner class (see
     * {@link Type#getInternalName() getInternalName}).
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor (see {@link Type Type}).
     * @param itf
     * if the method's owner class is an interface.
     */
    visitMethodInsn(opcode?: any, owner?: any, name?: any, desc?: any, itf?: any): any;
    /**
     * Visits an invokedynamic instruction.
     *
     * @param name
     * the method's name.
     * @param desc
     * the method's descriptor (see {@link Type Type}).
     * @param bsm
     * the bootstrap method.
     * @param bsmArgs
     * the bootstrap method constant arguments. Each argument must be
     * an {@link Integer}, {@link Float}, {@link Long},
     * {@link Double}, {@link String}, {@link Type} or {@link Handle}
     * value. This method is allowed to modify the content of the
     * array so a caller should expect that this array may change.
     */
    visitInvokeDynamicInsn(name: string, desc: string, bsm: Handle, ...bsmArgs: any[]): void;
    /**
     * Visits a jump instruction. A jump instruction is an instruction that may
     * jump to another instruction.
     *
     * @param opcode
     * the opcode of the type instruction to be visited. This opcode
     * is either IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ,
     * IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE,
     * IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
     * @param label
     * the operand of the instruction to be visited. This operand is
     * a label that designates the instruction to which the jump
     * instruction may jump.
     */
    visitJumpInsn(opcode: number, label: Label): void;
    /**
     * Visits a label. A label designates the instruction that will be visited
     * just after it.
     *
     * @param label
     * a {@link Label Label} object.
     */
    visitLabel(label: Label): void;
    /**
     * Visits a LDC instruction. Note that new constant types may be added in
     * future versions of the Java Virtual Machine. To easily detect new
     * constant types, implementations of this method should check for
     * unexpected constant types, like this:
     *
     * <pre>
     * if (cst instanceof Integer) {
     * // ...
     * } else if (cst instanceof Float) {
     * // ...
     * } else if (cst instanceof Long) {
     * // ...
     * } else if (cst instanceof Double) {
     * // ...
     * } else if (cst instanceof String) {
     * // ...
     * } else if (cst instanceof Type) {
     * int sort = ((Type) cst).getSort();
     * if (sort == Type.OBJECT) {
     * // ...
     * } else if (sort == Type.ARRAY) {
     * // ...
     * } else if (sort == Type.METHOD) {
     * // ...
     * } else {
     * // throw an exception
     * }
     * } else if (cst instanceof Handle) {
     * // ...
     * } else {
     * // throw an exception
     * }
     * </pre>
     *
     * @param cst
     * the constant to be loaded on the stack. This parameter must be
     * a non null {@link Integer}, a {@link Float}, a {@link Long}, a
     * {@link Double}, a {@link String}, a {@link Type} of OBJECT or
     * ARRAY sort for <tt>.class</tt> constants, for classes whose
     * version is 49.0, a {@link Type} of METHOD sort or a
     * {@link Handle} for MethodType and MethodHandle constants, for
     * classes whose version is 51.0.
     */
    visitLdcInsn(cst: any): void;
    /**
     * Visits an IINC instruction.
     *
     * @param var
     * index of the local variable to be incremented.
     * @param increment
     * amount to increment the local variable by.
     */
    visitIincInsn(__var: number, increment: number): void;
    /**
     * Visits a TABLESWITCH instruction.
     *
     * @param min
     * the minimum key value.
     * @param max
     * the maximum key value.
     * @param dflt
     * beginning of the default handler block.
     * @param labels
     * beginnings of the handler blocks. <tt>labels[i]</tt> is the
     * beginning of the handler block for the <tt>min + i</tt> key.
     */
    visitTableSwitchInsn(min: number, max: number, dflt: Label, ...labels: Label[]): void;
    /**
     * Visits a LOOKUPSWITCH instruction.
     *
     * @param dflt
     * beginning of the default handler block.
     * @param keys
     * the values of the keys.
     * @param labels
     * beginnings of the handler blocks. <tt>labels[i]</tt> is the
     * beginning of the handler block for the <tt>keys[i]</tt> key.
     */
    visitLookupSwitchInsn(dflt: Label, keys: number[], labels: Label[]): void;
    /**
     * Visits a MULTIANEWARRAY instruction.
     *
     * @param desc
     * an array type descriptor (see {@link Type Type}).
     * @param dims
     * number of dimensions of the array to allocate.
     */
    visitMultiANewArrayInsn(desc: string, dims: number): void;
    /**
     * Visits an annotation on an instruction. This method must be called just
     * <i>after</i> the annotated instruction. It can be called several times
     * for the same instruction.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#INSTANCEOF INSTANCEOF},
     * {@link TypeReference#NEW NEW},
     * {@link TypeReference#CONSTRUCTOR_REFERENCE
     * CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE
     * METHOD_REFERENCE}, {@link TypeReference#CAST CAST},
     * {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
     * CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT},
     * {@link TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT
     * METHOD_INVOCATION_TYPE_ARGUMENT},
     * {@link TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
     * CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or
     * {@link TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT
     * METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitInsnAnnotation(typeRef: number, typePath: TypePath | null, desc: string | null, visible: boolean): AnnotationVisitor | null;
    /**
     * Visits a try catch block.
     *
     * @param start
     * beginning of the exception handler's scope (inclusive).
     * @param end
     * end of the exception handler's scope (exclusive).
     * @param handler
     * beginning of the exception handler's code.
     * @param type
     * internal name of the type of exceptions handled by the
     * handler, or <tt>null</tt> to catch any exceptions (for
     * "finally" blocks).
     * @throws IllegalArgumentException
     * if one of the labels has already been visited by this visitor
     * (by the {@link #visitLabel visitLabel} method).
     */
    visitTryCatchBlock(start: Label, end: Label, handler: Label, type: string | null): void;
    /**
     * Visits an annotation on an exception handler type. This method must be
     * called <i>after</i> the {@link #visitTryCatchBlock} for the annotated
     * exception handler. It can be called several times for the same exception
     * handler.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#EXCEPTION_PARAMETER
     * EXCEPTION_PARAMETER}. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitTryCatchAnnotation(typeRef: number, typePath: TypePath | null, desc: string | null, visible: boolean): AnnotationVisitor | null;
    /**
     * Visits a local variable declaration.
     *
     * @param name
     * the name of a local variable.
     * @param desc
     * the type descriptor of this local variable.
     * @param signature
     * the type signature of this local variable. May be
     * <tt>null</tt> if the local variable type does not use generic
     * types.
     * @param start
     * the first instruction corresponding to the scope of this local
     * variable (inclusive).
     * @param end
     * the last instruction corresponding to the scope of this local
     * variable (exclusive).
     * @param index
     * the local variable's index.
     * @throws IllegalArgumentException
     * if one of the labels has not already been visited by this
     * visitor (by the {@link #visitLabel visitLabel} method).
     */
    visitLocalVariable(name: string | null, desc: string | null, signature: string | null, start: Label, end: Label, index: number): void;
    /**
     * Visits an annotation on a local variable type.
     *
     * @param typeRef
     * a reference to the annotated type. The sort of this type
     * reference must be {@link TypeReference#LOCAL_VARIABLE
     * LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE
     * RESOURCE_VARIABLE}. See {@link TypeReference}.
     * @param typePath
     * the path to the annotated type argument, wildcard bound, array
     * element type, or static inner type within 'typeRef'. May be
     * <tt>null</tt> if the annotation targets 'typeRef' as a whole.
     * @param start
     * the fist instructions corresponding to the continuous ranges
     * that make the scope of this local variable (inclusive).
     * @param end
     * the last instructions corresponding to the continuous ranges
     * that make the scope of this local variable (exclusive). This
     * array must have the same size as the 'start' array.
     * @param index
     * the local variable's index in each range. This array must have
     * the same size as the 'start' array.
     * @param desc
     * the class descriptor of the annotation class.
     * @param visible
     * <tt>true</tt> if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or <tt>null</tt> if
     * this visitor is not interested in visiting this annotation.
     */
    visitLocalVariableAnnotation(typeRef: number, typePath: TypePath | null, start: Label[], end: Label[], index: number[], desc: string | null, visible: boolean): AnnotationVisitor | null;
    /**
     * Visits a line number declaration.
     *
     * @param line
     * a line number. This number refers to the source file from
     * which the class was compiled.
     * @param start
     * the first instruction corresponding to this line number.
     * @throws IllegalArgumentException
     * if <tt>start</tt> has not already been visited by this
     * visitor (by the {@link #visitLabel visitLabel} method).
     */
    visitLineNumber(line: number, start: Label): void;
    /**
     * Visits the maximum stack size and the maximum number of local variables
     * of the method.
     *
     * @param maxStack
     * maximum stack size of the method.
     * @param maxLocals
     * maximum number of local variables for the method.
     */
    visitMaxs(maxStack: number, maxLocals: number): void;
    /**
     * Visits the end of the method. This method, which is the last one to be
     * called, is used to inform the visitor that all the annotations and
     * attributes of the method have been visited.
     */
    visitEnd(): void;
}
//# sourceMappingURL=MethodVisitor.d.ts.map